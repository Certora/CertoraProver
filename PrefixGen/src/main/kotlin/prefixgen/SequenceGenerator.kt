/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package prefixgen

import bridge.Method
import bridge.SingleDeployedContract
import bridge.types.PrimitiveType
import bridge.types.SolcLocation
import bridge.types.SolidityTypeDescription
import com.certora.collect.*
import datastructures.memoized
import datastructures.stdcollections.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.encodeToStream
import prefixgen.CodeGen.buildable
import prefixgen.CodeGen.pp
import prefixgen.FileUtils.deserialize
import prefixgen.FileUtils.serialize
import prefixgen.data.*
import prefixgen.data.TaggedFile.Companion.into
import prefixgen.selection.SelectorGenerator
import utils.*
import java.io.File
import java.io.FileOutputStream
import java.io.OutputStream

/**
 * A class for generating new test cases.
 * [setupCodeFile] is the file which holds the user
 * `setUp` function, [sdcDataFile] holds the SDC data for the test contracts
 * as generated by the certoraRun builder. [initialBindingFile] is the json file
 * that describes the bindings created by [setupCodeFile].
 *
 * [maxDepth] is the length of sequences generated by this class,
 * [generator] controls how functions are chosen for inclusion in test cases.
 * the `targetContractType` the TYPE of the main contract to generate sequences upon.
 * There **MUST** be a storage variable bound in [initialBindingFile] that matches this type.
 */
@OptIn(ExperimentalSerializationApi::class)
@Suppress("JSON_FORMAT_REDUNDANT")
class SequenceGenerator(
    private val setupCodeFile: File,
    private val initialBindingFile: TaggedFile<Map<String, InitialBinding>>,
    private val sdcDataFile: TaggedFile<Map<String, SingleDeployedContract>>,
    targetContractType: String,
    val maxDepth: Int,
    val generator: SelectorGenerator
) {
    constructor(s: SceneData, targetContractType: String, maxDepth: Int, generator: SelectorGenerator) : this(
        File(s.setupFile),
        File(s.initialBinding).into(),
        File(s.sdcFile).into(),
        targetContractType,
        maxDepth,
        generator
    )

    interface ResumableArtifact {
        val soliditySource: String
        fun serializeData(output: OutputStream)
        fun saveToPath(path: String)
    }

    /**
     * The state monad [T]. Represents a computation that takes some state [StateAccumulator],
     * and the produces a value of type [T] and a new state.
     *
     * Bind is defined by [StateMonad.bind]. Described intuitively, composing two
     * state monads yields a new state monad which:
     * 1. accepts a state S, and invokes the first monad to generate a value t and new state S'
     * 2. Passes uses `t` to generate the second [StateMonad]<U> M.
     * 3. Invokes M using state S' yielding a value u and new state S''.
     */
    private fun interface StateMonad<T> {
        fun step(
            s: StateAccumulator
        ): Pair<StateAccumulator, T>

        companion object {
            fun <T> ret(x: T) = StateMonad<T> { s ->
                s to x
            }
        }
    }

    /**
     * Compose this state monad with [f], which mutates the state yielded by this state monad.
     */
    private fun <T> StateMonad<T>.sideEffect(f: (StateAccumulator) -> StateAccumulator) : StateMonad<T> {
        return StateMonad { acc ->
            val (newState, res) = this@sideEffect.step(acc)
            f(newState) to res
        }
    }

    /**
     * Should maybe be called `run` but that's kind of an overloaded term in Kotlin.
     * Per [finish], takes a computation whose only interesting result is the resulting state,
     * and run that computation from a starting state [s], returning the side effected state.
     */
    private fun StateMonad<Unit>.sideEffect(s: StateAccumulator) = this.step(s).first


    /**
     * Compose this [StateMonad] with [f], see [StateMonad] for the high-level description
     * for what this is doing.
     */
    private fun <T, U> StateMonad<T>.bind(f: (T) -> StateMonad<U>) : StateMonad<U> {
        return StateMonad { s ->
            val (sNext, t) = this.step(s)
            f(t).step(sNext)
        }
    }

    /**
     * Compose two [StateMonad] and use the values `t` and `u` as arguments to [f].
     *
     * Despite the name "parallel", the monad represented by `this` is executed sequentially with [other];
     * the state yielded by invoking `this` is fed into [other].
     */
    private fun <T, U, R> StateMonad<T>.parallelBind(other: StateMonad<U>, f: (T, U) -> StateMonad<R>) : StateMonad<R> {
        return StateMonad { s ->
            val (s1, t) = this.step(s)
            val (s2, u) = other.step(s1)
            f(t, u).step(s2)
        }
    }

    /**
     * Turn a function (state, T) -> (state, U) and an argument of type [T] yielding
     * a [StateMonad]<U>.
     *
     * So called because the partial application of [arg] to the receiver function yields a (State) -> (State, U)
     * which is indeed a [StateMonad]<U>.
     */
    private fun <T, U> ((StateAccumulator, T) -> Pair<StateAccumulator, U>).curry(arg: T): StateMonad<U> {
        return StateMonad { s ->
            this(s, arg)
        }
    }

    /**
     * After using this [StateMonad] to generate a state S' and value t of type [T],
     * call [f] with t and S' to yield a final state. This final state is considered
     * the "result" of the resulting state monad, thus this returns a [StateMonad]<Unit> (indicating
     * that only the side effects of the computation are important).
     */
    private fun <T> StateMonad<T>.finish(f: (T, StateAccumulator) -> StateAccumulator) : StateMonad<Unit> {
        return StateMonad { s ->
            val (sNext, t) = this.step(s)
            val res = f(t, sNext)
            res to Unit
        }
    }

    /**
     * Commutes the list monad with the state monad. In particular, sequentially
     * execute each state monad in this receiver list; the state yielded by
     * applying element i is used to execute the monad at element i + 1.
     * The values yielded by executing each monad are joined into a list,
     * and returned along with the state yielded by executing the final element.
     */
    private fun <T> List<StateMonad<T>>.commute(): StateMonad<List<T>> {
        val inputs = this
        return StateMonad { s ->
            var stateIt = s
            val toRet = mutableListOf<T>()
            for(thunk in inputs) {
                val (newState, res) = thunk.step(stateIt)
                stateIt = newState
                toRet.add(res)
            }
            stateIt to toRet
        }
    }

    /**
     * Turns a Monad that returns a value of type [T] into one that returns [U]
     * by mapping the value returned by this monad via [f].
     */
    private fun <T, U> StateMonad<T>.map(f: (T) -> U): StateMonad<U> {
        return StateMonad<U> { s ->
            val (newState, res) = this.step(s)
            newState to f(res)
        }
    }


    private val initialBindings = initialBindingFile.deserialize()

    private val setupCode = setupCodeFile.readText()

    private fun File.toAbsolutePath() = this.toPath().toAbsolutePath().toString()

    private fun TaggedFile<*>.toAbsolutePath() = this.f.toAbsolutePath()

    /**
     * Find the SDC for the provided type
     */
    private val targetContract = sdcDataFile.deserialize<Map<String, SingleDeployedContract>>().findEntry { _, sdc ->
            sdc.primary_contract == targetContractType
    }?.let { (_, sdc) ->
        sdc.contracts.find { instance ->
            instance.name == targetContractType
        }
    } ?: throw IllegalArgumentException("Contract type $targetContractType not found in provided SDC data")

    /**
     * Find all methods which are
     * 1. external
     * 2. Not view/pure
     * 3. Have arguments we can build (via [CodeGen.buildable]
     *
     * This is the "vocab" for the sequences we build.
     */
    private val vocab = targetContract.methods.filter {
        (it.visibility == Method.MethodVisibility.public || it.visibility == Method.MethodVisibility.external) &&
        !it.stateMutability.isView && !it.stateMutability.isPure && it.fullArgs.all {
            it.location != SolcLocation.storage && it.typeDesc.buildable()
        }
    }

    /**
     * Generate the selector over this universe/vocab. See [SelectorGenerator] for a discussion of this API.
     */
    private val selector = generator.selectorFor(vocab)

    /**
     * Find the storage variable which holds the target contract type.
     */
    private val contractReceiver = initialBindings.findEntry { _, initialBinding ->
        initialBinding.ty is SolidityTypeDescription.Contract && initialBinding.ty.contractName == targetContractType
    }?.first ?: throw IllegalArgumentException("No storage variable bound to type $targetContractType in initial bindings")


    companion object {
        const val maxArrayLen = 3

        const val maximumUniverseSize = 5

        const val inputParamName = "inputVars"

    }

    /**
     * Get the current sequence of calls for the sequence represented by [StateAccumulator]
     */
    private fun StateAccumulator.currSequence() : TreapList<String> {
        return this.fixedPrefix.currCalls.toTreapList() + this.ast.mapNotNull {
            (it as? SimpleSolidityAst.FunctionCall)?.sighash
        }.toTreapList()
    }

    /**
     * Represents a partially or completely built sequence.
     * Can be directly compiled as it implements [Compiler.CompilationInput].
     *
     * [knownAliases] maps a [SolidityTypeDescription] to the set of source
     * identifiers which hold an instance of this type. It is an unchecked invariant that the keys
     * of this map are [bindable]
     * [idCounter] is a monotonically increasing counter to generate fresh variables.
     * [statements] are intended to be comments inserted before/after the "real" operations
     * (should probably be removed in favor of updating [ast] directly, oh well)
     *
     * [ast] is the body of the fuzz test, consisting of binding arguments to functions, and then invoking that function.
     * [fixedPrefix] and [importManager] have the same interpretation as in [Compiler.CompilationInput].
     *
     * NB: [knownAliases] *should* be initialized with the values bound in [fixedPrefix]'s [FixedPrefix.storageVars]
     * along with the [initialBindings] in the user provided setup function.
     *
     * One final note on the API documentation: we will frequently say something is a "monadic operation", which means
     * that in addition to the "real" return value, the function will return the updated [StateAccumulator].
     * We'll also say something "monadically returns X" indicating that in addition to the real return value X, we return
     * the updated state.
     *
     * Q: Why [SolidityTypeDescription] and not [spec.cvlast.typedescriptors.EVMTypeDescriptor]?
     * A: We deal with two reference types, strings and bytes. We could insist on some canonicialization scheme
     * where we always insist that the relevant [spec.cvlast.typedescriptors.EVMLocationSpecifier] field is always null,
     * but that laxity in representation bothered me.
     * [SolidityTypeDescription] lets us just say "string" or "bytes" without even mentioning locations (which is what we want).
     * It does mean that the [upcastFor] implementation is uh, something.
     */
    private data class StateAccumulator(
        val knownAliases: TreapMap<SolidityTypeDescription, TreapSet<Identifier>>,
        val idCounter: Int,

        val statements: TreapList<String>,

        override val ast: TreapList<SimpleSolidityAst>,
        override val importManager: ImportManager,
        override val fixedPrefix: FixedPrefix
    ) : Compiler.CompilationInput {
        fun import(ud: SolidityTypeDescription.UserDefined) = this.copy(
            importManager = this.importManager.importType(ud)
        )

        /**
         * For every value returned from this function call for which we can track aliases,
         * create a new identifier to hold that return value, and update [knownAliases] accordingly.
         * Monadically returns the list of bindings created, with null elements in the list
         * indicating that that return value is not bound.
         */
        fun allocReturns(l: List<SolidityTypeDescription>) : Pair<StateAccumulator, List<VarDef?>> {
            var idAcc = this.idCounter
            val toRet = mutableListOf<VarDef?>()
            val typeIds = knownAliases.builder()
            for(ty in l) {
                if(!ty.bindable()) {
                    toRet.add(null)
                    continue
                }
                val rawId = "returnVal${idAcc++}"
                val id = rawId
                typeIds[ty] = (typeIds[ty] ?: treapSetOf()) + id
                toRet.add(
                    VarDef(
                        rawId = rawId,
                        ty = ty
                    )
                )
            }
            return this.copy(
                idCounter = idAcc,
                knownAliases = typeIds.build()
            ) to toRet
        }

        fun incr(by: Int = 1) = this.copy(
            idCounter = this.idCounter + by
        )

        /**
         * Monadic operation which pushes a [SimpleSolidityAst.BindEnum] for [ty] onto the [ast], and returns the chosen variable name.
         */
        fun generateFreshEnum(ty: SolidityTypeDescription.UserDefined.Enum) : Pair<StateAccumulator, SymExp.Symbol> {
            val disc = "enumDiscriminator${this.idCounter}"
            val res = disc + "_Chosen"
            return this.push(SimpleSolidityAst.BindEnum(
                rawId = res,
                ty = ty,
                inputDiscriminator = disc
            )).incr() to SymExp.Symbol(res)
        }

        /**
         * Monadically generate a new binding for [ty]; this new binding is return as a [SymExp.Symbol].
         *
         * Depending on [mustAliasFor], this value may be a must alias for previous compatible
         * values for [ty].
         *
         * The choice of aliases for [ty] is controlled by [getAliases].
         */
        fun generateFreshPrimitive(ty: SolidityTypeDescription) : Pair<StateAccumulator, SymExp.Symbol> {
            val aliases = getAliases(ty)
            val must = mustAliasFor(ty, aliases)
            /**
             * If we must alias an existing binding do *not* create a new type alias
             */
            if(must) {
                /**
                 * If this is a must aliasing we must, well, have aliases.
                 * Generate a [SimpleSolidityAst.BindMust]
                 */
                check(aliases.isNotEmpty())
                var idCounterMut = idCounter
                val phantomId = "phantomRef${idCounterMut++}"
                val discriminator = "mustAliasDisc${idCounterMut++}"
                val freshDescriminator = Discriminator(
                    discriminator,
                    aliases,
                    must = true
                )
                /**
                 * NB: we do NOT update knownAliases, as nothing should try to alias `phantomId` (it is itself
                 * an alias)
                 */
                return this.push(SimpleSolidityAst.BindMust(
                    ty = ty,
                    boundId = phantomId,
                    discriminator = freshDescriminator
                )).copy(idCounter = idCounterMut) to SymExp.Symbol(phantomId)
            }

            /**
             * Otherwise, choose between any aliases (if any) and a fresh value.
             */
            var idCounterMut = idCounter


            val inputId = "inputField${idCounterMut++}"
            val boundId = "boundVar${idCounterMut++}"
            return this.push(
                SimpleSolidityAst.BindInputChoice(
                    boundId = boundId,
                    ty = ty,
                    inputId = inputId,
                    aliases = aliases.takeIf { l -> l.isNotEmpty() }?.let { al ->
                        Discriminator(
                            aliases = al,
                            must = false,
                            discriminator = "aliasDiscr${idCounterMut++}"
                        )
                    }
                )
            ).copy(
                /**
                 * Note here that we ARE updating the [knownAliases] map with our fresh binding,
                 * as, if it is chosen to be fresh, other values can alias it
                 */
                idCounter = idCounterMut,
                knownAliases = knownAliases.update(ty, treapSetOf()) { curr ->
                    curr + boundId
                }
            ) to SymExp.Symbol(boundId)
        }

        /**
         * Indicates that we should stop generating fresh values and *always* pick an alias.
         * Currently, this (heuristically) simply bounds the universe size for addresses to be 4.
         */
        private fun mustAliasFor(
            ty: SolidityTypeDescription,
            aliases: List<Alias>
        ) = ty is SolidityTypeDescription.Primitive && ty.primitiveName == PrimitiveType.address && aliases.size >= 4

        /**
         * Heuristically never use aliases for `uintK` types.
         * Otherwise, get all direct aliases for [ty], (via [knownAliases])
         * and all type conversion aliases (via [typeConversionAliasesFor]).
         */
        private fun getAliases(ty: SolidityTypeDescription) : List<Alias> {
            if(ty is SolidityTypeDescription.Primitive && ty.primitiveName.ordinal in (PrimitiveType.uint8.ordinal .. PrimitiveType.uint256.ordinal)) {
                return listOf()
            }
            return knownAliases[ty]?.map { alias ->
                alias.direct()
            }.orEmpty() + typeConversionAliasesFor(ty)
        }

        /**
         * Push [c] onto the ast, turning any auxiliary [statements] into a [SimpleSolidityAst.Literal]
         */
        fun push(c: SimpleSolidityAst) : StateAccumulator {
            return if(this.statements.isNotEmpty()) {
                this.copy(
                    ast = this.ast + listOf(SimpleSolidityAst.Literal(statements), c),
                    statements = treapListOf()
                )
            } else {
                this.copy(
                    ast = this.ast + c
                )
            }
        }

        companion object {
            /**
             * Given [Extendable] data, and the initial bindings [init],
             * build a [StateAccumulator] that let's us extend a previous fuzz test generated in some
             * previous execution of [SequenceGenerator].
             *
             * XXX(jtoman): why are we passing [init] here when it's present in [Extendable.sceneData] I wonder...
             */
            fun extendFrom(r: Extendable, init: Map<String, InitialBinding>) : StateAccumulator {
                var knownAliases = treapMapOf<SolidityTypeDescription, TreapSet<Identifier>>()

                /**
                 * Register [vd] as a known alias for the given type.
                 */
                fun update(vd: VarDef) {
                    knownAliases = knownAliases.update(vd.ty, treapSetOf()) { curr ->
                        curr + vd.rawId
                    }
                }

                r.fixedPrefix.storageVars.forEach { vd ->
                    update(vd)
                }
                init.forEachEntry { (nm, bind) ->
                    update(VarDef(bind.ty, nm))
                }
                /**
                 * Walk the AST, updating the known aliases with the non-must aliasing bindings
                 * created by the statements.
                 */
                for(a in r.ast) {
                    when(a) {
                        is SimpleSolidityAst.BindInputChoice -> {
                            update(vd = VarDef(a.ty, a.boundId))
                        }
                        is SimpleSolidityAst.SemanticLine,
                        is SimpleSolidityAst.BindArray,
                        is SimpleSolidityAst.BindEnum,
                        is SimpleSolidityAst.BindMust -> {
                            /* these explicitly do not create potential aliases */
                        }
                        is SimpleSolidityAst.FunctionCall -> {
                            a.binds?.forEach { vd ->
                                if(vd != null) {
                                    update(vd)
                                }
                            }
                        }
                        is SimpleSolidityAst.Literal -> {
                            // this is for comments
                        }
                    }
                }
                return StateAccumulator(
                    knownAliases = knownAliases,
                    idCounter = r.counter,
                    fixedPrefix = r.fixedPrefix,
                    statements = treapListOf(),
                    ast = r.ast.toTreapList(),
                    importManager = r.importManager
                )
            }

            /**
             * Values that we can track aliases for. A strict subset of [CodeGen.buildable]; as we do not do aliasing
             * of composite types like, arrays, structs, or static arrays, building those fresh each time from their
             * smaller components.
             */
            fun SolidityTypeDescription.bindable() = when(this) {
                is SolidityTypeDescription.Function,
                is SolidityTypeDescription.Mapping,
                is SolidityTypeDescription.StaticArray,
                is SolidityTypeDescription.UserDefined.Struct,
                is SolidityTypeDescription.Array -> false
                is SolidityTypeDescription.Contract,
                is SolidityTypeDescription.PackedBytes,
                is SolidityTypeDescription.StringType,
                is SolidityTypeDescription.UserDefined.Enum,
                is SolidityTypeDescription.UserDefined.ValueType,
                is SolidityTypeDescription.Primitive -> true
            }

            /**
             * Mutually recurses with [upcastFor].
             * Records that [t] can be upcast to some type, and then find the types
             * that can be upcast to [t], as the `can upcast` relationship is transitive.
             */
            private fun recurseAnd(
                t: PrimitiveType
            ): List<PrimitiveType> {
                return listOf(t) + upcastFor(t)
            }

            /**
             * LISTEN.
             * This is an unfortunate side effect of using [SolidityTypeDescription] instead of [spec.cvlast.typedescriptors.EVMTypeDescriptor].
             * It's ugly but it's auto generated, so who cares.
             *
             * Anyway, given some type `T` returns a list of the types that can be upcast
             * (i.e., without losing information) to `T`.
             */
            private val upcastFor: (PrimitiveType) -> List<PrimitiveType> =
                memoized<PrimitiveType, List<PrimitiveType>>(reentrant = true) { ty ->
                    when (ty) {
                        PrimitiveType.uint8 -> listOf()
                        PrimitiveType.uint16 -> recurseAnd(PrimitiveType.uint8)
                        PrimitiveType.uint24 -> recurseAnd(PrimitiveType.uint16)
                        PrimitiveType.uint32 -> recurseAnd(PrimitiveType.uint24)
                        PrimitiveType.uint40 -> recurseAnd(PrimitiveType.uint32)
                        PrimitiveType.uint48 -> recurseAnd(PrimitiveType.uint40)
                        PrimitiveType.uint56 -> recurseAnd(PrimitiveType.uint48)
                        PrimitiveType.uint64 -> recurseAnd(PrimitiveType.uint56)
                        PrimitiveType.uint72 -> recurseAnd(PrimitiveType.uint64)
                        PrimitiveType.uint80 -> recurseAnd(PrimitiveType.uint72)
                        PrimitiveType.uint88 -> recurseAnd(PrimitiveType.uint80)
                        PrimitiveType.uint96 -> recurseAnd(PrimitiveType.uint88)
                        PrimitiveType.uint104 -> recurseAnd(PrimitiveType.uint96)
                        PrimitiveType.uint112 -> recurseAnd(PrimitiveType.uint104)
                        PrimitiveType.uint120 -> recurseAnd(PrimitiveType.uint112)
                        PrimitiveType.uint128 -> recurseAnd(PrimitiveType.uint120)
                        PrimitiveType.uint136 -> recurseAnd(PrimitiveType.uint128)
                        PrimitiveType.uint144 -> recurseAnd(PrimitiveType.uint136)
                        PrimitiveType.uint152 -> recurseAnd(PrimitiveType.uint144)
                        PrimitiveType.uint160 -> recurseAnd(PrimitiveType.uint152)
                        PrimitiveType.uint168 -> recurseAnd(PrimitiveType.uint160)
                        PrimitiveType.uint176 -> recurseAnd(PrimitiveType.uint168)
                        PrimitiveType.uint184 -> recurseAnd(PrimitiveType.uint176)
                        PrimitiveType.uint192 -> recurseAnd(PrimitiveType.uint184)
                        PrimitiveType.uint200 -> recurseAnd(PrimitiveType.uint192)
                        PrimitiveType.uint208 -> recurseAnd(PrimitiveType.uint200)
                        PrimitiveType.uint216 -> recurseAnd(PrimitiveType.uint208)
                        PrimitiveType.uint224 -> recurseAnd(PrimitiveType.uint216)
                        PrimitiveType.uint232 -> recurseAnd(PrimitiveType.uint224)
                        PrimitiveType.uint240 -> recurseAnd(PrimitiveType.uint232)
                        PrimitiveType.uint248 -> recurseAnd(PrimitiveType.uint240)
                        PrimitiveType.uint256 -> recurseAnd(PrimitiveType.uint248)
                        PrimitiveType.int8 -> listOf()
                        PrimitiveType.int16 -> recurseAnd(PrimitiveType.int8)
                        PrimitiveType.int24 -> recurseAnd(PrimitiveType.int16)
                        PrimitiveType.int32 -> recurseAnd(PrimitiveType.int24)
                        PrimitiveType.int40 -> recurseAnd(PrimitiveType.int32)
                        PrimitiveType.int48 -> recurseAnd(PrimitiveType.int40)
                        PrimitiveType.int56 -> recurseAnd(PrimitiveType.int48)
                        PrimitiveType.int64 -> recurseAnd(PrimitiveType.int56)
                        PrimitiveType.int72 -> recurseAnd(PrimitiveType.int64)
                        PrimitiveType.int80 -> recurseAnd(PrimitiveType.int72)
                        PrimitiveType.int88 -> recurseAnd(PrimitiveType.int80)
                        PrimitiveType.int96 -> recurseAnd(PrimitiveType.int88)
                        PrimitiveType.int104 -> recurseAnd(PrimitiveType.int96)
                        PrimitiveType.int112 -> recurseAnd(PrimitiveType.int104)
                        PrimitiveType.int120 -> recurseAnd(PrimitiveType.int112)
                        PrimitiveType.int128 -> recurseAnd(PrimitiveType.int120)
                        PrimitiveType.int136 -> recurseAnd(PrimitiveType.int128)
                        PrimitiveType.int144 -> recurseAnd(PrimitiveType.int136)
                        PrimitiveType.int152 -> recurseAnd(PrimitiveType.int144)
                        PrimitiveType.int160 -> recurseAnd(PrimitiveType.int152)
                        PrimitiveType.int168 -> recurseAnd(PrimitiveType.int160)
                        PrimitiveType.int176 -> recurseAnd(PrimitiveType.int168)
                        PrimitiveType.int184 -> recurseAnd(PrimitiveType.int176)
                        PrimitiveType.int192 -> recurseAnd(PrimitiveType.int184)
                        PrimitiveType.int200 -> recurseAnd(PrimitiveType.int192)
                        PrimitiveType.int208 -> recurseAnd(PrimitiveType.int200)
                        PrimitiveType.int216 -> recurseAnd(PrimitiveType.int208)
                        PrimitiveType.int224 -> recurseAnd(PrimitiveType.int216)
                        PrimitiveType.int232 -> recurseAnd(PrimitiveType.int224)
                        PrimitiveType.int240 -> recurseAnd(PrimitiveType.int232)
                        PrimitiveType.int248 -> recurseAnd(PrimitiveType.int240)
                        PrimitiveType.int256 -> recurseAnd(PrimitiveType.int248)
                        PrimitiveType.bytes1 -> listOf()
                        PrimitiveType.bytes2 -> recurseAnd(PrimitiveType.bytes1)
                        PrimitiveType.bytes3 -> recurseAnd(PrimitiveType.bytes2)
                        PrimitiveType.bytes4 -> recurseAnd(PrimitiveType.bytes3)
                        PrimitiveType.bytes5 -> recurseAnd(PrimitiveType.bytes4)
                        PrimitiveType.bytes6 -> recurseAnd(PrimitiveType.bytes5)
                        PrimitiveType.bytes7 -> recurseAnd(PrimitiveType.bytes6)
                        PrimitiveType.bytes8 -> recurseAnd(PrimitiveType.bytes7)
                        PrimitiveType.bytes9 -> recurseAnd(PrimitiveType.bytes8)
                        PrimitiveType.bytes10 -> recurseAnd(PrimitiveType.bytes9)
                        PrimitiveType.bytes11 -> recurseAnd(PrimitiveType.bytes10)
                        PrimitiveType.bytes12 -> recurseAnd(PrimitiveType.bytes11)
                        PrimitiveType.bytes13 -> recurseAnd(PrimitiveType.bytes12)
                        PrimitiveType.bytes14 -> recurseAnd(PrimitiveType.bytes13)
                        PrimitiveType.bytes15 -> recurseAnd(PrimitiveType.bytes14)
                        PrimitiveType.bytes16 -> recurseAnd(PrimitiveType.bytes15)
                        PrimitiveType.bytes17 -> recurseAnd(PrimitiveType.bytes16)
                        PrimitiveType.bytes18 -> recurseAnd(PrimitiveType.bytes17)
                        PrimitiveType.bytes19 -> recurseAnd(PrimitiveType.bytes18)
                        PrimitiveType.bytes20 -> recurseAnd(PrimitiveType.bytes19)
                        PrimitiveType.bytes21 -> recurseAnd(PrimitiveType.bytes20)
                        PrimitiveType.bytes22 -> recurseAnd(PrimitiveType.bytes21)
                        PrimitiveType.bytes23 -> recurseAnd(PrimitiveType.bytes22)
                        PrimitiveType.bytes24 -> recurseAnd(PrimitiveType.bytes23)
                        PrimitiveType.bytes25 -> recurseAnd(PrimitiveType.bytes24)
                        PrimitiveType.bytes26 -> recurseAnd(PrimitiveType.bytes25)
                        PrimitiveType.bytes27 -> recurseAnd(PrimitiveType.bytes26)
                        PrimitiveType.bytes28 -> recurseAnd(PrimitiveType.bytes27)
                        PrimitiveType.bytes29 -> recurseAnd(PrimitiveType.bytes28)
                        PrimitiveType.bytes30 -> recurseAnd(PrimitiveType.bytes29)
                        PrimitiveType.bytes31 -> recurseAnd(PrimitiveType.bytes30)
                        PrimitiveType.bytes32 -> recurseAnd(PrimitiveType.bytes31)
                        PrimitiveType.uint -> recurseAnd(PrimitiveType.uint256)
                        PrimitiveType.int -> recurseAnd(PrimitiveType.int256)
                        PrimitiveType.nonreentrant_lock,
                        PrimitiveType.byte,
                        PrimitiveType.address,
                        PrimitiveType.bool -> listOf()
                    }
                }
        }

        private fun Identifier.direct() = Alias(
            this, "%s"
        )

        private fun Identifier.wrap(target: String) = Alias(this, "$target(%s)")

        private operator fun <V> TreapMap<SolidityTypeDescription, V>.get(pt: PrimitiveType) = this[SolidityTypeDescription.Primitive(pt)]

        /**
         * Find identifiers that can be converted to [ty] without losing information.
         */
        private fun typeConversionAliasesFor(
            ty: SolidityTypeDescription
        ) : List<Alias> {
            return when(ty) {
                is SolidityTypeDescription.Function,
                is SolidityTypeDescription.Array,
                is SolidityTypeDescription.Mapping,
                is SolidityTypeDescription.UserDefined.Struct,
                is SolidityTypeDescription.StaticArray -> throw UnsupportedOperationException("Should not be generating $ty")
                /**
                 * Find any extant `address` variables that could be cast to this contract.
                 *
                 * NB: we could look for other contract types, and then cast them through address to this contract type,
                 * but that seems pretty "noisy".
                 */
                is SolidityTypeDescription.Contract -> {
                    knownAliases[SolidityTypeDescription.builtinPrimitive("address")!!]?.map { addrVar ->
                        addrVar.wrap(ty.contractName)
                    }.orEmpty()
                }
                /**
                 * Find all strings (directly cast via `bytes()`) and all `byteK` (which can be encodePacked).
                 */
                is SolidityTypeDescription.PackedBytes -> {
                    recurseAnd(PrimitiveType.bytes32).flatMap { bytesKAlias ->
                        knownAliases[bytesKAlias]?.map { alias ->
                            Alias(
                                alias,
                                "abi.encodePacked(%s)"
                            )
                        }.orEmpty()
                    } + knownAliases[SolidityTypeDescription.StringType()]?.map { stringAlias ->
                        stringAlias.wrap("bytes")
                    }.orEmpty()
                }
                /**
                 * Find all of the "straightforward" upcasts via [upcastFor]. As a special case,
                 * for `address`, also allow casting known Contract types to `address`
                 */
                is SolidityTypeDescription.Primitive -> {
                    upcastFor(ty.primitiveName).flatMap { canUpcastType ->
                        knownAliases[SolidityTypeDescription.Primitive(canUpcastType)]?.map { alias ->
                            alias.wrap(ty.primitiveName.name)
                        }.orEmpty()
                    } + if(ty.primitiveName == PrimitiveType.address) {
                        knownAliases.flatMap { (ty, k) ->
                            if(ty !is SolidityTypeDescription.Contract) {
                                return@flatMap listOf()
                            } else {
                                k.map { alias ->
                                    alias.wrap("address")
                                }
                            }
                        }
                    } else {
                        listOf()
                    }
                }
                /**
                 * The "dual" of bytes.
                 */
                is SolidityTypeDescription.StringType -> {
                    recurseAnd(PrimitiveType.bytes32).flatMap { bytesKAlias ->
                        knownAliases[bytesKAlias]?.map { alias ->
                            Alias(
                                alias,
                                "string(abi.encodePacked(%s))"
                            )
                        }.orEmpty()
                    } + knownAliases[SolidityTypeDescription.PackedBytes()]?.map { bytesAlias ->
                        bytesAlias.wrap("string")
                    }.orEmpty()
                }
                // unsupported, maybe should throw
                is SolidityTypeDescription.UserDefined.Enum -> listOf()
                is SolidityTypeDescription.UserDefined.ValueType -> listOf()
            }
        }

        /**
         * Monadic operation which generates an array of maximum length [maxArrayLen].
         * Each element of the array is generated by [generateFreshPrimitive].
         */
        fun generateFreshArray(ty: SolidityTypeDescription.Array): Pair<StateAccumulator, SymExp> {
            val baseType = ty.dynamicArrayBaseType
            check(baseType is SolidityTypeDescription.Primitive)
            val lenVar = "arrayLen${idCounter}"
            val outputVar = "boundArray${idCounter + 1}"
            val elems = mutableListOf<SymExp.Symbol>()
            var stateIt = this.incr(by = 2)
            for(i in (0 ..< maxArrayLen)) {
                // kotlin yells at me for an unused variable
                // using forEach on the range has ah *hEaVy* performance cost
                // I give up, just ignore the unused var
                unused(i)
                val (nxtState, e) = generateFreshPrimitive(baseType)
                elems.add(e)
                stateIt = nxtState
            }
            return stateIt.push(
                c = SimpleSolidityAst.BindArray(
                    rawId = outputVar,
                    elems = elems,
                    lengthSym = lenVar,
                    elemType = baseType
                )
            ) to SymExp.Symbol(outputVar)
        }
    }

    /**
     * Returns a [StateMonad] which monadically returns a [SymExp.Symbol]
     * which holds a value of type [ty], or returns null if [ty] isn't supported.
     */
    private fun generateValue(
        ty: SolidityTypeDescription,
    ) : StateMonad<SymExp>? {
        check(ty.buildable())
        return when(ty) {
            is SolidityTypeDescription.Array -> {
                return StateMonad { state ->
                    state.generateFreshArray(ty)
                }
            }
            is SolidityTypeDescription.PackedBytes,
            is SolidityTypeDescription.Primitive,
            is SolidityTypeDescription.StringType,
            is SolidityTypeDescription.Contract -> {
                return StateMonad { st ->
                    st.generateFreshPrimitive(ty)
                }
            }
            is SolidityTypeDescription.UserDefined.ValueType,
            is SolidityTypeDescription.Function,
            is SolidityTypeDescription.Mapping -> `impossible!`
            is SolidityTypeDescription.StaticArray -> {
                val endPoint = ty.staticArraySize.intValueExact()
                (0 ..< endPoint).monadicMap { _ ->
                    generateValue(ty.staticArrayBaseType)
                }?.commute()?.map { elems ->
                    SymExp.StaticArrayLiteral(
                        elems = elems,
                        elemTy = ty.staticArrayBaseType.pp()
                    )
                }
            }
            is SolidityTypeDescription.UserDefined.Enum -> {
                return StateMonad { s ->
                    s.import(ty).generateFreshEnum(ty)
                }
            }
            is SolidityTypeDescription.UserDefined.Struct -> {
                ty.structMembers.monadicMap { fld ->
                    generateValue(fld.type)
                }?.commute()?.map { fld ->
                    SymExp.StructLiteral(
                        fields = fld,
                        structName = ty.qualifiedName
                    )
                }?.let { t ->
                    return StateMonad { s ->
                        t.step(s.import(ty))
                    }
                }
            }
        }
    }

    /**
     * Start generating sequences from scratch, without a fixed prefix or existing AST, and just uses the initial bindigns and setup function from the user.
     * The "entry point" for prefix generation (hence the name).
     */
    fun entry(): Sequence<ResumableArtifact> {
        val startState = StateAccumulator(
            idCounter = 0,
            statements = treapListOf(),
            ast = treapListOf(),
            importManager = ImportManager(imports = mapOf()),
            fixedPrefix = FixedPrefix(
                setup = listOf(),
                storageVars = setOf(),
                currCalls = listOf()
            ),
            knownAliases = initialBindings.entries.groupBy {
                it.value.ty
            }.mapValues { (_, ent) ->
                ent.mapToTreapSet { (id, _) ->
                    id
                }
            }.toTreapMap()
        )
        return sequence<Artifact> {
            crossProduct(startState, 0, treapListOf())
        }
    }

    /**
     * Given an [idCounter], and a known [fixedPrefix] which represents some concrete trace
     * found by foundry, start generating new *symbolic* traces.
     * [imports] are the imports necessary for [fixedPrefix].
     */
    fun resume(
        idCounter: Int,
        fixedPrefix: FixedPrefix,
        imports: ImportManager
    ): Sequence<ResumableArtifact> {
        var typeIds = treapMapOf<SolidityTypeDescription, TreapSet<Identifier>>()
        for((init, bind) in initialBindings) {
            typeIds = typeIds.updateEntry(bind.ty, init) { curr, toInsert ->
                (curr ?: treapSetOf()) + toInsert
            }
        }

        for((ty, sd) in fixedPrefix.storageVars) {
            typeIds = typeIds.updateEntry(ty, sd) { curr, toInsert ->
                (curr ?: treapSetOf()) + toInsert
            }
        }
        val startState = StateAccumulator(
            idCounter = idCounter,
            importManager = imports,
            knownAliases = typeIds,
            ast = treapListOf(),
            statements = treapListOf(),
            fixedPrefix = fixedPrefix
        )
        return sequence {
            crossProduct(startState, 0, startState.currSequence())
        }
    }

    /**
     * Holds the *file names* of the [setupFile] (which defines `setUp()`),
     * the [sdcDataFile] which holds the SDC data from certora build, and the [initialBinding]
     * json file.
     *
     * We use this so that every TestCase "points to" the data that seeded its generation, without copying the data
     * hundreds of times. We could literally make hard or symbolic links, but that would start *significantly* cluttering the
     * directory structure.
     */
    @KSerializable
    data class SceneData(
        val setupFile: String,
        val initialBinding: String,
        val sdcFile: String
    ) : AmbiSerializable

    /**
     * An extension of the [Compiler.CompilationInput] which supports extending the ast.
     * This includes the [sceneData] and the [counter].
     */
    @KSerializable
    sealed interface Extendable : Compiler.CompilationInput {
        val counter: Int
        val sceneData: SceneData
    }

    /**
     * An [Extendable] that can be used for CEX interpretation.
     * In particular, includes information about the chosen parameters/struct fields
     * from the [Compiler], which are necessary to parse [prefixgen.fuzzer.RunData].
     */
    @KSerializable
    data class ResumeData(
        val structIds: List<VarDef>,
        val topLevelParams: List<VarDef>,
        override val ast: List<SimpleSolidityAst>,
        override val fixedPrefix: FixedPrefix,
        override val counter: Int,
        override val importManager: ImportManager,
        override val sceneData: SceneData
    ) : Compiler.CompilationInput, Extendable {
        companion object {
            val JSON = Json { allowStructuredMapKeys = true }

        }

    }

    data class Artifact(
        val solFile: String,
        val data: ResumeData,
    ) : ResumableArtifact {
        override val soliditySource: String
            get() = solFile

        @OptIn(ExperimentalSerializationApi::class)
        override fun serializeData(output: OutputStream) {
            ResumeData.JSON.encodeToStream(data, output)
        }

        override fun saveToPath(path: String) {
            FileOutputStream(File("$path.sol")).use {
                val buffer = it.bufferedWriter()
                buffer.write(solFile)
                buffer.flush()
            }
            File("$path${TestCase.resumeExtension}").into<Extendable>().serialize(
                data
            )
        }

    }

    /**
     * Compile the [StateAccumulator] [s] into an [Artifact], which
     * consists of the solidity source code of the test and the [ResumeData],
     * which is everything needed to either interpret a concrete CEX or extend the
     * test case.
     */
    private fun compile(s: StateAccumulator) : Artifact {
        val contractSource = Compiler.compileFuzzContract(
            initialBindings = initialBindings,
            setupCode = setupCode,
            s = s
        )
        return Artifact(
            solFile = contractSource.soliditySource,
            data = ResumeData(
                ast = s.ast,
                counter = s.idCounter,
                fixedPrefix = s.fixedPrefix,
                importManager = s.importManager,
                sceneData = SceneData(
                    setupFile = setupCodeFile.toAbsolutePath(),
                    initialBinding = initialBindingFile.toAbsolutePath(),
                    sdcFile = sdcDataFile.toAbsolutePath()
                ),
                structIds = contractSource.structFields,
                topLevelParams = contractSource.otherParams
            ),
        )
    }

    /**
     * In some [state] at [currDepth] (out of [maxDepth]) with [currSeq] calls already present (across
     * the [StateAccumulator.fixedPrefix] and the [StateAccumulator.ast],
     * generate extensions of the test case.
     *
     * Under random generation settings, by using a sequence we let the user generate as many test cases as they want.
     */
    private suspend fun SequenceScope<Artifact>.crossProduct(
        state: StateAccumulator,
        currDepth: Int,
        currSeq: TreapList<String>
    ) {
        /**
         * If we've hit max depth, compile the current state into a [Artifact], yield, and return.
         *
         */
        if(currDepth == maxDepth) {
            yield(compile(state))
            return
        }
        /**
         * Otherwise, stream some choices of the next function to call based on the
         * current depth, and generate a test case extension for those choices.
         */
        for(toCall in selector.generateChoice(currDepth, maxDepth, currSeq)) {
            val argGen = toCall.fullArgs.withIndex().monadicMap { (ind, it) ->
                generateValue(it.typeDesc)?.let { gen ->
                    StateMonad.ret(Unit).sideEffect { s ->
                        s.copy(
                            statements = s.statements + listOf("\n /* Bind argument ${toCall.paramNames[ind]} */")
                        )
                    }.bind { gen }
                }
            }?.commute() ?: continue
            val bindGen = if(toCall.returns.isEmpty()) {
                StateMonad.ret(null)
            } else {
                StateMonad { s ->
                    s.allocReturns(toCall.returns.map { it.typeDesc })
                }
            }
            val senderGen = StateAccumulator::generateFreshPrimitive.curry(SolidityTypeDescription.Primitive(PrimitiveType.address))
            val nextState = argGen.parallelBind(bindGen) { args, bind ->
                senderGen.finish { sender, state ->
                    state.push(
                        SimpleSolidityAst.FunctionCall(
                            args = args,
                            binds = bind,
                            asSender = sender,
                            functionName = toCall.name,
                            contract = contractReceiver,
                            sighash = toCall.sighash!!
                        )
                    )
                }
            }.sideEffect(state)
            crossProduct(nextState, currDepth + 1, currSeq + toCall.sighash!!)
        }
    }

    /**
     * Extend a symbolic state [resume], generating [ResumableArtifact].
     */
    fun extend(resume: Extendable) : Sequence<ResumableArtifact> {
        val state = StateAccumulator.extendFrom(
            resume, initialBindings
        )
        return sequence<Artifact> {
            crossProduct(
                state, 0, state.currSequence()
            )
        }
    }
}
