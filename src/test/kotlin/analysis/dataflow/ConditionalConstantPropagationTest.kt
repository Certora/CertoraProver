/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package analysis.dataflow

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import tac.Tag
import vc.data.TACBuilderAuxiliaries
import vc.data.TACExpr
import vc.data.TACProgramBuilder
import vc.data.TACSymbol
import java.math.BigInteger

class ConditionalConstantPropagationTest : TACBuilderAuxiliaries() {

    fun intConstExp(v: Long) = TACExpr.Sym.Const(intConst(v), Tag.Int)
    val constTrueExp = TACExpr.Sym.Const(TACSymbol.Const(BigInteger.ONE, Tag.Bool), Tag.Bool)
    val constFalseExp = TACExpr.Sym.Const(TACSymbol.Const(BigInteger.ZERO, Tag.Bool), Tag.Bool)
    fun varExp(v: TACSymbol.Var) = TACExpr.Sym.Var(v)

    @Test
    fun simpleCCPTest() {

        val originalProg = TACProgramBuilder {
            val x = intVar("CCPSimpleTest_x")
            val y = intVar("CCPSimpleTest_y")
            val jumpExp = boolVar("CCPSimpleTest_jumpCond")
            x assign 1
            jumpExp assign (x.asSym() lt intConstExp(2))
            jumpCond(jumpExp)
            jump {
                y assign IntAdd(intConstExp(5), x.asSym())
            }
            jump {
                y assign intConstExp(33)
            }
        }

        val newProg = ConditionalConstantPropagation.optimize(originalProg.code)

        val expectedProg = TACProgramBuilder {
            val x = intVar("CCPSimpleTest_x")
            val y = intVar("CCPSimpleTest_y")
            val jumpExp = boolVar("CCPSimpleTest_jumpCond")
            x assign 1
            jumpExp assign constTrueExp
            jump {
                // It breaks if you just write 6 and not intConstExp(6)
                y assign intConstExp(6)
            }
        }

        assertEquals(expectedProg.code.digest(), newProg.digest())
    }

    @Test
    fun mergeControlFlowCCPTest() {

        val originalProg = TACProgramBuilder {
            val x = intVar("CCPSimpleTest_x")
            val y = intVar("CCPSimpleTest_y")
            val z = intVar("CCPSimpleTest_z")
            val jumpExp = boolVar("CCPSimpleTest_jumpCond")
            x assign 1
            // if (x < 2)  { y = 5 + x } else { y = 33 }
            jumpExp assign (x.asSym() lt intConstExp(2))
            jumpCond(jumpExp)
            jump(1) {
                y assign IntAdd(intConstExp(5), x.asSym())
                jump(3) {
                    z assign IntMul(y.asSym(), y.asSym())
                }
            }
            jump(2) {
                y assign intConstExp(33)
                jump(3)
            }
        }

        val newProg = ConditionalConstantPropagation.optimize(originalProg.code)

        val expectedProg = TACProgramBuilder {
            val x = intVar("CCPSimpleTest_x")
            val y = intVar("CCPSimpleTest_y")
            val z = intVar("CCPSimpleTest_z")
            val jumpExp = boolVar("CCPSimpleTest_jumpCond")
            x assign 1
            jumpExp assign constTrueExp
            jump {
                y assign intConstExp(6)
                jump {
                    z assign intConstExp(36)
                }
            }
        }

        assertEquals(expectedProg.code.digest(), newProg.digest())
    }

    // This is based on a code pattern observed in TAC generated by real
    // contracts where several instances of `assume !false` are generated
    // CCP should convert these to `assume true` and a later pass
    // will delete commands that are exactly `assume true`
    @Test
    fun assumeFalseTest() {
        val originalProg = TACProgramBuilder {
            val tmp = boolVar("assumeFalseTest_tmp15581559")
            val r2 = intVar("assumeFalseTest_r2")
            jump {
                assumeExp(LNot(constFalseExp))
                assumeExp(LNot(constFalseExp))
            }
            jump {
                assumeExp(LNot(constFalseExp))
                assumeExp(LNot(constFalseExp))
                tmp assign Eq(varExp(r2), intConstExp(0))
            }
        }

        val newProg = ConditionalConstantPropagation.optimize(originalProg.code)

        val expectedProg = TACProgramBuilder {
            val tmp = boolVar("assumeFalseTest_tmp15581559")
            val r2 = intVar("assumeFalseTest_r2")
            jump {
                assumeExp(constTrueExp)
                assumeExp(constTrueExp)
            }
            jump {
                assumeExp(constTrueExp)
                assumeExp(constTrueExp)
                tmp assign Eq(varExp(r2), intConstExp(0))
            }
        }

        assertEquals(expectedProg.code.digest(), newProg.digest())
    }

    // This one is also based on an example TAC pattern from real
    // client contracts.
    @Test
    fun stakedTokenConstantProp() {
        val originalProg = TACProgramBuilder {
            val r123 = intVar("stakedTokenConstantProp_r123")
            val r128 = intVar("stakedTokenConstantProp_r128")
            val r134 = intVar("stakedTokenConstantProp_r134")
            val r46 = intVar("stakedTokenConstantProp_r46")
            assumeExp(Eq(intConstExp(0x24), varExp(r123)))
            // skiping assignment to R128 since IDK how to build that RHS expr
            // and it looks irrelevant to the rest
            assumeExp(Gt(varExp(r128), intConstExp(0x0)))
            assumeExp(LNot(Lt(varExp(r123), intConstExp(0x4))))
            assumeExp(LNot(Gt(intConstExp(0x3950935), varExp(r46))))
            assumeExp(LNot(Eq(intConstExp(0x3950935), varExp(r46))))
            assumeExp(Eq(intConstExp(0x70a08231), varExp(r46)))
            r134 assign IntSub(varExp(r123), intConstExp(0x4))
            assumeExp(LNot(Lt(varExp(r134), intConstExp(0x20))))
        }

        val newProg = ConditionalConstantPropagation.optimize(originalProg.code)

        val expectedProg = TACProgramBuilder {
            val r123 = intVar("stakedTokenConstantProp_r123")
            val r128 = intVar("stakedTokenConstantProp_r128")
            val r134 = intVar("stakedTokenConstantProp_r134")
            val r46 = intVar("stakedTokenConstantProp_r46")
            assumeExp(Eq(intConstExp(0x24), varExp(r123)))
            // skiping assignment to R128 since IDK how to build that RHS expr
            // and it looks irrelevant to the rest
            assumeExp(Gt(varExp(r128), intConstExp(0x0)))
            assumeExp(constTrueExp)
            assumeExp(LNot(Gt(intConstExp(0x3950935), varExp(r46))))
            assumeExp(LNot(Eq(intConstExp(0x3950935), varExp(r46))))
            assumeExp(Eq(intConstExp(0x70a08231), varExp(r46)))
            r134 assign intConstExp(0x20)
            assumeExp(constTrueExp)
        }

        assertEquals(expectedProg.code.digest(), newProg.digest())

    }

}
