/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

@file:Suppress("ForbiddenMethodCall")
package infra

import datastructures.stdcollections.*

/**
 * This file generates solidity tests for the [analysis.alloc.ReturnBufferAnalysis], using low-level assembly to test as many
 * reasonable combinations of return buffer allocations as possible (check returnsize before/after RC checks,
 * or before/after FP writes, use min(returnsize, k) or just returnsize for the bounds check, etc.)
 *
 * The various "generator" classes are used in a cross product to generate the low-level yul for each test.
 */

private interface AllocSizeGenerator {
    fun generate(boundVar: String): Pair<String, List<String>>
    val description: String
}

private data class SizeGenResult(val sizeOperand: String, val commands: List<String>, val decl: List<String>)

private interface SizeGenerator {
    fun generate(): SizeGenResult
    val description: String
}

private const val sz = "0x40"

private const val contractPrefix = """
/*
  These tests were automatically generated by running ReturnBufferAnalysisTestGen
*/
contract Test {
	struct SomeStruct {
		uint a;
		uint b;
	}
"""

private const val structPointerName = "ret"

private const val fpPointerName = "fp"

private const val rcVarName = "rc"

private const val rcRevertCode = "if eq($rcVarName, 0) { revert(0, 0) }"

private fun methodBodySetup(nm: String, valueConf: ValuePassing, extraDecl: List<String>): String {
    return """
        function $nm(${valueConf.paramString}) external returns (uint) {
            SomeStruct memory $structPointerName;
            ${
                extraDecl.joinToString("\n") { varName ->
                    "uint $varName;"
                }
            }
            assembly {
               	let $fpPointerName := mload(0x40)
			    mstore($fpPointerName, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // selector of transferFrom, not important
                let $rcVarName := call(gas(), caller(), ${valueConf.valueArg}, $fpPointerName, 0x4, $fpPointerName, $sz)
    """.trimIndent()
}

private const val methodBodySuffix = """

        $structPointerName := $fpPointerName
    }
    uint[] memory forceAlloc = new uint[]($structPointerName.a);
    return $structPointerName.b + forceAlloc[0];
}
"""

private val allocSizeCases = listOf(object : AllocSizeGenerator {
    override fun generate(boundVar: String): Pair<String, List<String>> {
        return sz to listOf()
    }

    override val description: String
        get() = "ConstantSize"

}, object : AllocSizeGenerator {
    override fun generate(boundVar: String): Pair<String, List<String>> {
        val resultVar = "rounded"
        return resultVar to listOf(
            "let r1 := add($boundVar, 0x1f)",
            "let $resultVar := and(r1, not(0x1f))"
        )
    }

    override val description: String
        get() = "DynamicSizeRound"
})

private enum class BoundLocation(val testName: String) {
    PRE_RC_BOUND("PreRCBound"),
    PRE_FP("PreFPWrite"),
    POST_FP("PostFPWrite")
}

private val boundOperandCases = listOf(object : SizeGenerator {
    override fun generate(): SizeGenResult {
        val v = "boundVar"
        return SizeGenResult(
            v,
            listOf("""
                    let $v := returndatasize()
                """.trimIndent()),
            listOf()
        )
    }

    override val description: String
        get() = "ReturnSizeDirect"

}, object : SizeGenerator {
    override fun generate(): SizeGenResult {
        val v = "t"

        return SizeGenResult(
            v,
            listOf(
                """
                        switch lt(returndatasize(), $sz)
                           case 0 {
                              $v := $sz
                           }
                           default {
                              $v := returndatasize()
                           }
                    """.trimIndent()
            ),
            listOf(v)
        )
    }

    override val description: String
        get() = "BoundedReturnSizeDisj"
})

private enum class ValuePassing(val paramString: String, val valueArg: String, val testName: String) {
    WITH_VALUE("uint amount", "amount", "WithValue"),
    WITHOUT_VALUE("", "0", "NoValue")
}

fun main() {
    println(contractPrefix)

    for(szCase in allocSizeCases) {
        for(boundLoc in BoundLocation.entries) {
            for(valueConf in ValuePassing.entries) {
                for (boundGen in boundOperandCases) {
                    val caseName = "implicitCopy${valueConf.testName}${szCase.description}${boundLoc.testName}${boundGen.description}"
                    val boundInfo = boundGen.generate()

                    val boundSetupCode = boundInfo.commands.joinToString("\n")

                    val boundCode = """
                    if lt(${boundInfo.sizeOperand}, $sz) { revert(0, 0) }
                """.trimIndent()

                    println(methodBodySetup(caseName, valueConf, boundInfo.decl))
                    if (boundLoc == BoundLocation.PRE_RC_BOUND) {
                        println(boundSetupCode)
                        println(boundCode)
                    }
                    println(rcRevertCode)
                    if (boundLoc != BoundLocation.PRE_RC_BOUND) {
                        println(boundSetupCode)
                    }
                    if (boundLoc == BoundLocation.PRE_FP) {
                        println(boundCode)
                    }
                    val (allocAmount, allocCode) = szCase.generate(boundInfo.sizeOperand)
                    println(
                        """
                    ${allocCode.joinToString("\n")}
                    mstore(0x40, add($fpPointerName, $allocAmount))
                """.trimIndent()
                    )
                    if (boundLoc == BoundLocation.POST_FP) {
                        println(boundCode)
                    }
                    println(methodBodySuffix)
                }
            }
        }
    }

    println("}")
}
