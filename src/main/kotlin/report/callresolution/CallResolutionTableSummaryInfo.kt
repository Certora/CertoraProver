/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

@file:kotlinx.serialization.UseSerializers(BigIntegerSerializer::class)
package report.callresolution

import analysis.icfg.Havocer
import analysis.icfg.SummaryApplicationReason
import com.certora.collect.*
import config.Config
import datastructures.stdcollections.*
import scene.*
import utils.*
import java.io.Serializable

/**
 * Encapsulates information about an application of a function call summary.
 * This information is intended to be shown at the CallResolutionTable of
 * the report.
 */
@Treapable
sealed class CallResolutionTableSummaryInfo : Serializable {



    protected abstract fun MutableMap<String, String>.buildSummaryInfoMap()

    /**
     * Why was the associated summary applied?
     */
    abstract val applicationReason: SummaryApplicationReason

    /**
     * Maps attributes ([String]s) to descriptions/details thereof ([String]s). These attributes should include
     * information about the application of the summary associated with this [CallResolutionTableSummaryInfo].
     * Each entry is intended to be shown at the report's Call Resolution table.
     */
    val info: Map<String, String> by lazy {
        buildMap {
            put(SummaryApplicationReason(), applicationReason.reasonMsg)
            buildSummaryInfoMap()
        }
    }

    /**
     * Indicates whether the associated summary application should be shown
     * as a warning in the Call Resolution table.
     */
    abstract val callResolutionTableRowStatus: CallResolutionTableRow.Status

    override fun toString(): String = info.entries.joinToString(
        prefix = "summary info { ",
        postfix = " }",
        separator = ", "
    ) { (attribute, details) -> "$attribute: $details" }


    /**
     * Wraps [applicationReason] with no additional info.
     */
    @KSerializable
    data class DefaultInfo(override val applicationReason: SummaryApplicationReason) :
        CallResolutionTableSummaryInfo() {

        override val callResolutionTableRowStatus: CallResolutionTableRow.Status
            get() = CallResolutionTableRow.Status.Ok

        override fun MutableMap<String, String>.buildSummaryInfoMap() {}
    }

    /**
     * Summary information that shows a list of alternative callee implementations.
     */
    interface WithDispatchedCalleesInfo {

        val alternativeCalleesHeader: String

        @Treapable
        data class PossibleCallee(val contractName: String, val displaySig: String): Serializable {
            constructor(method: ITACMethod):
                this(method.getContainingContract().name, method.soliditySignature ?: method.name)
        }

        val alternativeCallees: Collection<PossibleCallee>

        /**
         * Returns a non-null message if this [WithDispatchedCalleesInfo] should
         * report a vacuity warning to the user.
         */
        val vacuousDispatcherMsgOrNull: String?

        /**
         * Builds from [alternativeCallees] an attribute consisting of a comma
         * separated list of contracts, if [WithDispatchedCalleesInfo] returns null;
         * otherwise, uses the message generated by [WithDispatchedCalleesInfo].
         */
        fun MutableMap<String, String>.buildCalleesInfo() {
            put(
                alternativeCalleesHeader,
                vacuousDispatcherMsgOrNull ?: alternativeCallees
                    .joinToString(separator = " | ", prefix = "[", postfix = "]") {
                        "${it.contractName}.${it.displaySig}"
                }
            )
        }
    }

    data class DispatchedInfo(
        override val applicationReason: SummaryApplicationReason,
        override val alternativeCallees: Collection<WithDispatchedCalleesInfo.PossibleCallee>,
        val nonOptimisticHavocInfo: HavocInfo.NonOptimisticDispatcherHavoc?,
    ) : CallResolutionTableSummaryInfo(), WithDispatchedCalleesInfo {
        override val alternativeCalleesHeader: String
            get() = "resolved callees"

        private val isOptimisticDispatcher: Boolean
            get() = nonOptimisticHavocInfo == null
        override val callResolutionTableRowStatus: CallResolutionTableRow.Status
            get() = vacuousDispatcherMsgOrNull?.let {
                if (isOptimisticDispatcher) {
                    CallResolutionTableRow.Status.NotOk.Error(msg = it, shouldReport = true)
                } else {
                    CallResolutionTableRow.Status.NotOk.Warning(msg = it, shouldReport = true)
                }
            } ?: CallResolutionTableRow.Status.Ok


        override val vacuousDispatcherMsgOrNull: String?
            get() = (applicationReason as? SummaryApplicationReason.Spec)?.loc
                ?.let { "in $it " }.orEmpty().let { loc ->
                if (alternativeCallees.isEmpty()) {
                    "empty dispatcher ${loc}${
                        if (isOptimisticDispatcher) {
                            "that makes all statements that follow it unreachable ('else' case is 'assume false')"
                        } else {
                            "that is effectively an AUTO havoc summary ('else' case is havoc)"
                        }
                    }"
                } else {
                    null
                }
            }


        override fun MutableMap<String, String>.buildSummaryInfoMap() {
            buildCalleesInfo()
            if (nonOptimisticHavocInfo != null) {
                put("non-optimistic havoc scope", nonOptimisticHavocInfo.havocType.toString())
            }
        }

        override fun toString(): String = super.toString()
    }

    sealed class HavocInfo : CallResolutionTableSummaryInfo() {

        abstract val havocType: Havocer.HavocType

        protected fun MutableMap<String, String>.buildHavocInfoMap(
            havocCauseMsg: String? = null
        ) {
            put("havoc scope", havocType.toString())
            havocCauseMsg?.also { msg -> put("havoc cause", msg) }
        }

        data class NonOptimisticDispatcherHavoc(
            override val havocType: Havocer.HavocType,
            override val applicationReason: SummaryApplicationReason
        ) : HavocInfo() {
            override val callResolutionTableRowStatus: CallResolutionTableRow.Status
                get() = CallResolutionTableRow.Status.Ok

            override fun MutableMap<String, String>.buildSummaryInfoMap() {
                buildHavocInfoMap("'else' case of non-optimistic dispatcher summary")
            }
        }

        /**
         * The Prover failed to resolve the callee, thus, defaults to havoc.
         */
        data class UnresolvedCall(override val havocType: Havocer.HavocType) : HavocInfo() {
            override val callResolutionTableRowStatus: CallResolutionTableRow.Status
                get() = CallResolutionTableRow.Status.NotOk.Warning(
                    msg = "The Prover could not resolve the callee, thus, havoc'd the call",
                    shouldReport = false
                )
            override val applicationReason: SummaryApplicationReason.Prover
                get() = SummaryApplicationReason.Prover
            override fun MutableMap<String, String>.buildSummaryInfoMap() {
                buildHavocInfoMap("The Prover could not resolve the callee, thus, havoc'd the call")
            }
        }

        data class HavocDeclaredInSpec(
            override val havocType: Havocer.HavocType,
            override val applicationReason: SummaryApplicationReason.Spec
        ) : HavocInfo() {
            override val callResolutionTableRowStatus: CallResolutionTableRow.Status
                get() = CallResolutionTableRow.Status.Ok

            override fun MutableMap<String, String>.buildSummaryInfoMap() {
                // It's clear that the spec opted for havocing, so we don't show the "havoc cause" in the report
                buildHavocInfoMap()
            }
        }

        data class HavocSelectedOnCli(
            override val havocType: Havocer.HavocType,
            override val applicationReason: SummaryApplicationReason.Cli,
            val havocCauseMsg: String
        ) : HavocInfo() {
            override val callResolutionTableRowStatus: CallResolutionTableRow.Status
                get() = CallResolutionTableRow.Status.Ok

            override fun MutableMap<String, String>.buildSummaryInfoMap() {
                buildHavocInfoMap(havocCauseMsg)
            }
        }

        /**
         * A summarization internal failure/error. The Prover defaults to havoc.
         */
        data class SummarizationFailureHavoc(override val havocType: Havocer.HavocType, val errorMsg: String) :
            HavocInfo() {
            override val callResolutionTableRowStatus: CallResolutionTableRow.Status
                get() = CallResolutionTableRow.Status.NotOk.Error(
                    msg = "The prover havoc'd due to summarization failure",
                    shouldReport = true
                )

            override fun MutableMap<String, String>.buildSummaryInfoMap() {
                buildHavocInfoMap(errorMsg)
            }

            override val applicationReason: SummaryApplicationReason.Prover
                get() = SummaryApplicationReason.Prover
        }
    }

    data class FallbackDispatched(
        val contractsWithExplicitFallback: Collection<String>
    ) : CallResolutionTableSummaryInfo(), WithDispatchedCalleesInfo {
        override val alternativeCallees: Collection<WithDispatchedCalleesInfo.PossibleCallee>
            get() = contractsWithExplicitFallback.map { WithDispatchedCalleesInfo.PossibleCallee(it, "fallback") }
        override val alternativeCalleesHeader: String
            get() = "alternative explicit fallbacks"
        override val applicationReason: SummaryApplicationReason.Cli
            get() = SummaryApplicationReason.Cli(Config.OptimisticFallback.userFacingName())

        override val vacuousDispatcherMsgOrNull: String?
            get() = if (contractsWithExplicitFallback.isEmpty()) {
                "There are no contracts with custom fallback() function implementation"
            } else { null }

        override val callResolutionTableRowStatus: CallResolutionTableRow.Status
            get() = vacuousDispatcherMsgOrNull?.let {
                CallResolutionTableRow.Status.NotOk.Warning(msg = it, shouldReport = true)
            }
                ?: CallResolutionTableRow.Status.Ok

        override fun MutableMap<String, String>.buildSummaryInfoMap() {
            buildCalleesInfo()
        }
    }

}
