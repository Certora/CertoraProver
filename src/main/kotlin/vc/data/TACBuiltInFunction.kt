/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

@file:kotlinx.serialization.UseSerializers(BigIntegerSerializer::class)
package vc.data

import analysis.pta.abi.TransientCallId
import com.certora.collect.*
import config.Config
import datastructures.stdcollections.*
import evm.*
import smt.solverscript.LExpressionFactory
import smt.solverscript.functionsymbols.*
import tac.MetaMap
import tac.Tag
import utils.*
import utils.SignUtilities.isInUnsignedBounds
import utils.SignUtilities.isInSignedBounds
import utils.SignUtilities.maxSignedValueOfBitwidth
import utils.SignUtilities.to2sComplement
import utils.SignUtilities.from2sComplement
import utils.SignUtilities.signExtend
import vc.data.TACBuiltInFunction.TwosComplement.Unwrap.bitWidth
import vc.data.TACBuiltInFunction.TwosComplement.Wrap.bitWidth
import java.io.Serializable
import java.math.BigInteger


/**
 * [TACBuiltInFunction]:
 * TACBuiltInFunctions, or Bifs are operators that are built into TAC, but not as heavily as the standard operators (like Add, IntAdd, BwAnd, LAnd, etc).
 * They're used by constructing a TACExpr.Apply(<bif>, <operands>)
 * basically we have them so it's relatively easy for us to add new operators in TAC.
 * (for comparison, adding a standard operator to TACExpr, would have us change every single when that goes over TACExpr s -- bifs are a bit easier usually)
 *
 * To add a new kind of [TACBuiltInFunction], just add a new subclass here.
 * Most requirements should be enforced by Kotlin (i.e. being serializable, stable hash, giving a name and signature).
 *
 * The only thing that is only checked on runtime is uniqueness of the names:
 * No two different [TACBuiltInFunction] objects may have the same name.
 * (will throw in `TACSerializationTools.writeSymbolTable`)
 *
 * Note that in case of a `object`, the name is just the `eName`; in case of a `class`, the name is generated by combining `eName` and `printInstanceId`.
 *
 */
@KSerializable
@Treapable
sealed class TACBuiltInFunction : AmbiSerializable {

    abstract val eName: BuiltInFuncName
    abstract val paramSorts: List<Tag>
    abstract val returnSort: Tag

    val name: String
        get() = "$eName${printInstanceId()}"

    /** returns null if params can't be evaluated for some reason */
    open fun eval(params : List<BigInteger>) : BigInteger? {
        require(params.size == paramSorts.size) {
            "calling $name with $params, but it takes only ${paramSorts.size} parameters"
        }
        return null
    }

    /**
     *  Prints a unique name alias.
     *  When you add a new type you should update here:
     *  If this is a class rather than an object,
     *   one should add a branch here that each instantiation is unique and matches [TACSymbolConstants.IdentifierRegex].
     *  o.w. just add the name in the end of this list (as all the other bif objects)
     */
    fun printInstanceId() : String = when(this) {
        is Hash.SimpleHashApplication -> "_${arity}_$hashFamily"
        is OpaqueIdentity -> "_$tag"
        is PartitionInitialize -> "${this.transientId.transientId}_${this.partitionId}"
        is ReadTransientPartition -> "${this.transientId.transientId}_${this.partitionId}"
        is SignedPromotion -> "_${returnSort.bitwidth}"
        is UnsignedPromotion -> "_${returnSort.bitwidth}"
        is SafeSignedNarrow -> "_${returnSort.bitwidth}"
        is SafeUnsignedNarrow -> "_${returnSort.bitwidth}"
        is SafeMathNarrow -> "_${returnSort}"
        is SafeMathPromotion -> ""
        //the rest are objects and don't have params:
        DisjointSighashes,
        Hash.Addition,
        Hash.Basic,
        Hash.FromSkey,
        Hash.ToSkey,
        LinkContractAddress,
        NoSMulOverAndUnderflowCheck,
        NoSAddOverAndUnderflowCheck,
        NoSSubOverAndUnderflowCheck,
        PrecompiledECRecover,
        TwosComplement.Unwrap,
        TwosComplement.Wrap,
        NoAddOverflowCheck,
        NoMulOverflowCheck,
        ToStorageKey -> ""
    }

    /*
       DisjointSighashes(addr) returns a non-deterministic value that is definitely NOT
       equal to a sighash of the contract addr.

       This can (and should) be simplified away as part of rule-preprocessing.
     */
    @KSerializable
    object DisjointSighashes : TACBuiltInFunction() {
        override fun hashCode() = hashObject(this)
        fun readResolve(): Any = DisjointSighashes
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.disjoint_sighashes
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            return { _ ->
                throw UnsupportedOperationException("DisjointSighashes should have been instrumented away before VC generation")
            }
        }

    }

    @KSerializable
    object LinkContractAddress : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.link_library
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            throw UnsupportedOperationException("This should have been replaced a long time ago")
        }

        override fun hashCode(): Int = hashObject(this)

        fun readResolve() : Any {
            return LinkContractAddress
        }

    }

    /** Please do not use this in `when`-constructs in order to find out which TACBuiltinFunction you're seeing -- just
     * switch over the TACBuiltInFunction itself and use its class hierarchy directly. */
    enum class BuiltInFuncName {
        smul_no_ofl_udfl,  // true iff signed op1*op2 does not overflow and does not underflow
        sadd_no_ofl_udfl, // true iff signed op1+op2 does not overflow and does not underflow
        ssub_no_ofl_udfl, // true iff signed op1-op2 does not overflow and does not underflow
        add_noofl,  // true iff op1+op2 does not overflow
        mul_noofl,    // true iff op1*op2 has no overflow
        opaque_identity,  // the identity function
        ecrecover,
        wrap_twos_complement,
        unwrap_twos_complement,
        skey_basic,
        skey_add,
        hash,
        to_skey,
        from_skey,
        safe_math_promotion,
        safe_math_narrow,
        signed_promotion,
        unsigned_promotion,
        signed_narrow,
        unsigned_narrow,
        disjoint_sighashes,
        link_library,
        to_storage_key,
        partition_init,
        transient_read,
        ;
    }

    fun toTACFunctionSym(): TACExpr.TACFunctionSym.BuiltIn = TACExpr.TACFunctionSym.BuiltIn(this)

    fun toInScopeBuiltinFunc(): FunctionInScope.Builtin = FunctionInScope.Builtin(this)

    open val ufAttribute: UFAttribute = UFAttribute.None

    fun getLExpressionBuilder(
        lxf: LExpressionFactory,
        symbolTable: TACSymbolTable,
        meta: MetaMap?,
    ): (List<TACExpr>) -> LExpression = getLExpressionBuilder(ToLExpression.Conv(lxf, symbolTable), meta)

    abstract fun getLExpressionBuilder(
        conv: ToLExpression.Conv,
        meta: MetaMap?,
    ): (List<TACExpr>) -> LExpression

    @KSerializable
    sealed class WithSMTFunctionSymbol(
        override val eName: BuiltInFuncName,
        override val paramSorts: List<Tag>,
        override val returnSort: Tag
    ) : TACBuiltInFunction(), Serializable {

        abstract val smtFuncSym: FunctionSymbol

        override fun getLExpressionBuilder(
            conv: ToLExpression.Conv,
            meta: MetaMap?,
        ): (List<TACExpr>) -> LExpression =
            { args ->
                check(args.size == this.paramSorts.size)
                conv.lxf.applyExp(
                    this.smtFuncSym,
                    args.map { conv(it, meta) }
                )
            }
    }

    @KSerializable
    object NoSMulOverAndUnderflowCheck : WithSMTFunctionSymbol(
        BuiltInFuncName.smul_no_ofl_udfl,
        listOf(Tag.Bit256, Tag.Bit256),
        Tag.Bool
    ) {
        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoSMulOverUnderflow
        override fun hashCode() = hashObject(this)
        fun readResolve(): Any = NoSMulOverAndUnderflowCheck

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                (params[0].from2sComplement() * params[1].from2sComplement()).let(::isInSignedBounds)
            }.toBigInteger()
    }

    // Add
    @KSerializable
    object NoAddOverflowCheck : WithSMTFunctionSymbol(
        BuiltInFuncName.add_noofl,
        listOf(Tag.Bit256, Tag.Bit256),
        Tag.Bool
    ) {

        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoAddOverflow

        override fun hashCode() = hashObject(this)
        fun readResolve(): Any = NoAddOverflowCheck

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                (params.sumOf { it } < EVM_MOD_GROUP256).toBigInteger()
            }
    }

    // Add
    @KSerializable
    object NoSAddOverAndUnderflowCheck : WithSMTFunctionSymbol(
        BuiltInFuncName.sadd_no_ofl_udfl,
        listOf(Tag.Bit256, Tag.Bit256),
        Tag.Bool
    ) {
        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoSAddOverUnderflow

        override fun hashCode() = hashObject(this)
        fun readResolve(): Any = NoSAddOverAndUnderflowCheck

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                (params.sumOf { it.from2s() } in MIN_EVM_INT256_AS_MATH_INT..MAX_EVM_INT256).toBigInteger()
            }
    }

    // Add
    @KSerializable
    object NoSSubOverAndUnderflowCheck : WithSMTFunctionSymbol(
        BuiltInFuncName.ssub_no_ofl_udfl,
        listOf(Tag.Bit256, Tag.Bit256),
        Tag.Bool
    ) {
        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoSSubOverUnderflow

        override fun hashCode() = hashObject(this)
        fun readResolve(): Any = NoSSubOverAndUnderflowCheck

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                ((params[0].from2s() - params[1].from2s())
                    in MIN_EVM_INT256_AS_MATH_INT..MAX_EVM_INT256).toBigInteger()
            }
    }

    // Mul
    @KSerializable
    object NoMulOverflowCheck : WithSMTFunctionSymbol(
        BuiltInFuncName.mul_noofl,
        listOf(Tag.Bit256, Tag.Bit256),
        Tag.Bool
    ) {

        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoMulOverflow

        override fun hashCode() = hashObject(this)
        fun readResolve(): Any = NoMulOverflowCheck

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                ((params[0] * params[1]) < EVM_MOD_GROUP256).toBigInteger()
            }
    }

    @KSerializable
    data class OpaqueIdentity(val tag: Tag) : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.opaque_identity

        override val paramSorts: List<Tag>
            get() = listOf(tag)

        override val returnSort: Tag
            get() = tag

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression =
            { args ->
                check(args.size == 1)
                conv(args.first(), meta)
            }
    }

    @KSerializable
    object PrecompiledECRecover : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.ecrecover
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256, Tag.Int, Tag.Bit256, Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256

        override fun hashCode() = hashObject(this)
        fun readResolve(): Any = PrecompiledECRecover

        // Note - we implement this as a multiselect instead of an UF application so that grounding will "see" it as
        // a use site for quantified variables.
        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression =
            { args ->
                check(args.size == this.paramSorts.size)
                val tag = Tag.GhostMap(paramSorts, returnSort)
                conv.lxf {
                    multiSelect(const(name, tag), args.map { conv(it, meta) }, tag)
                }
            }
    }

    /**
     * NB the bifs herein assume type correctness guaranteed by VM Converters
     */
    @KSerializable
    sealed class TwosComplement: TACBuiltInFunction() {
        abstract val paramSort: Tag
        override val paramSorts: List<Tag>
            get() = listOf(paramSort)
        protected val bitWidth = Config.VMConfig.registerBitwidth

        /**
         * Takes a parameter encoded as an arbitrary precision integer and converts it to a two's complement value
         * of bitwidth [bitWidth]
         *
         * Assumes input value will fit into a two's complement bitvector of size [bitwidth] (this is verified inside
         * the converter logic)
         */
        @KSerializable
        object Wrap : TwosComplement() {
            override val eName: BuiltInFuncName = BuiltInFuncName.wrap_twos_complement
            override val paramSort: Tag = Tag.Int
            override val returnSort: Tag.Bits = Tag.Bit256

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression {
                return { e ->
                    conv.lxf {
                        conv(e.single(),meta).let { lExp ->
                            ite(lExp ge ZERO, lExp, lExp + twoTo(bitWidth)) safeMathNarrow returnSort
                        }
                    }
                }
            }

            override fun hashCode() = hashObject(this)
            fun readResolve(): Any = Wrap

            override fun eval(params: List<BigInteger>): BigInteger? =
                super.eval(params).let {
                    runIf(isInSignedBounds(params[0])) {
                        params[0].to2sComplement()
                    }
                }
        }

        /**
         * Takes a parameter encoded as a two's complement value of bitwidth [bitWidth] and converts it to an arbitrary
         * precision signed integer
         */
        @KSerializable
        object Unwrap : TwosComplement() {
            override val eName: BuiltInFuncName = BuiltInFuncName.unwrap_twos_complement
            override val paramSort: Tag = Tag.Bit256
            override val returnSort: Tag = Tag.Int

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression {
                return { e ->
                    conv.lxf {
                        conv(e.single(), meta).let { lExp ->
                            // TODO: smt test
                            ite(
                                lExp intLe litInt(maxSignedValueOfBitwidth(bitWidth)),
                                lExp,
                                lExp - twoTo(bitWidth)
                            )
                        }
                    }
                }
            }

            override fun hashCode() = hashObject(this)
            fun readResolve(): Any = Unwrap

            override fun eval(params: List<BigInteger>): BigInteger =
                super.eval(params).let {
                    require(isInUnsignedBounds(params[0])) {
                        "${params[0]} is a parameter of ${eName}, breaking the 2s-complement unwrapping invariant"
                    }
                    params[0].from2sComplement()
                }
        }

    }

    @KSerializable
    object ToStorageKey : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.to_storage_key
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256
        override val ufAttribute: UFAttribute
            get() = UFAttribute.None

        override fun hashCode(): Int = hashObject(this)

        fun readResolve(): Any = ToStorageKey

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            throw UnsupportedOperationException("Should have been replaced by SKey annotation")
        }
    }

    @KSerializable
    sealed class Hash : TACBuiltInFunction() {

        companion object {
            // TODO [CERT-1790]: have Tag.BuiltinSort or so instead? https://certora.atlassian.net/browse/CERT-1790
            val skeySort = Tag.UserDefined.UninterpretedSort(storageKeySortName)
        }

        @KSerializable
        object Basic : Hash() {
            override fun hashCode() = hashObject(this)

            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.skey_basic
            override val paramSorts: List<Tag>
                get() = listOf(Tag.Int)
            override val returnSort: Tag
                get() = skeySort

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression = { args ->
                conv.lxf.applyExp(
                    NonSMTInterpretedFunctionSymbol.Hash.Basic,
                    args.map { conv(it, meta) }
                )
            }

            private fun readResolve(): Any = Basic
        }

        @KSerializable
        data class SimpleHashApplication(val arity: Int, val hashFamily: HashFamily) : Hash() {
            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.hash
            override val paramSorts: List<Tag>
                get() =
                    if (hashFamily.requiresLargeGaps) {
                        List(arity) { skeySort }
                    } else {
                        List(arity) { Tag.Bit256 }
                    }
            override val returnSort: Tag
                get() =
                    if (hashFamily.requiresLargeGaps) {
                        skeySort
                    } else {
                        Tag.Bit256
                    }

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression =
                { args ->
                    conv.lxf.applyExp(
                        NonSMTInterpretedFunctionSymbol.Hash.SimpleHashN(arity, hashFamily),
                        args.map { conv(it, meta) }
                    )
                }
        }

        @KSerializable
        object Addition : Hash() {
            override fun hashCode() = hashObject(this)

            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.skey_add
            override val paramSorts: List<Tag>
                get() = listOf(skeySort, Tag.Int)
            override val returnSort: Tag
                get() = skeySort

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression = { args ->
                conv.lxf.applyExp(
                    NonSMTInterpretedFunctionSymbol.Hash.SkeyAdd,
                    args.map { conv(it, meta) }
                )
            }

            private fun readResolve(): Any = Addition
        }

        @KSerializable
        object ToSkey : Hash() {
            override fun hashCode() = hashObject(this)

            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.to_skey
            override val paramSorts: List<Tag>
                get() = listOf(Tag.Bit256)
            override val returnSort: Tag
                get() = skeySort

            /** A map variable that the fuzzer can use to store the state of the ToSkey function.
             * Doesn't really have anything to do with ghost. Once we have sorted out Tag.Map, this can be a normal map
             * sort. */
            val asMapVar: TACExpr.Sym.Var = TACSymbol.Var(eName.name, Tag.GhostMap(paramSorts, returnSort)).asSym()

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression = { args ->
                conv.lxf.applyExp(
                    NonSMTInterpretedFunctionSymbol.Hash.ToSkey,
                    args.map { conv(it, meta) }
                )
            }

            private fun readResolve(): Any = ToSkey
        }

        @KSerializable
        object FromSkey : Hash() {
            override fun hashCode() = hashObject(this)

            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.from_skey
            override val paramSorts: List<Tag>
                get() = listOf(skeySort)
            override val returnSort: Tag
                get() = Tag.Bit256

            /** A map variable that the fuzzer can use to store the state of the FromSkey function.
             * Doesn't really have anything to do with ghost. Once we have sorted out Tag.Map, this can be a normal map
             * sort. */
            val asMapVar: TACExpr.Sym.Var =
                TACSymbol.Var(eName.name, Tag.GhostMap(paramSorts, returnSort)).asSym()

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression = { args ->
                conv.lxf.applyExp(
                    NonSMTInterpretedFunctionSymbol.Hash.FromSkey,
                    args.map { conv(it, meta) }
                )
            }

            private fun readResolve(): Any = FromSkey
        }
    }

    /**
     * Translate a uint directly into int without any operations: i.e., do not adjust for signedness etc.
     * Compiled out when going to LExpressions
     */
    @KSerializable
    data class SafeMathPromotion(val param: Tag) : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.safe_math_promotion
        override val paramSorts: List<Tag>
            get() = listOf(param)
        override val returnSort: Tag
            get() = Tag.Int

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression =
            { args -> conv(args.single(), meta) }

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let { params.single() }
    }

    /**
     * An "experts only" promise that a math int definitely falls within the uint256 range, and can be safely
     * reinterpreted as such without conversions or modulo application. Nothing happens if this check is violated,
     * this function only exists to make the type checking work and is an internal function in every sense of the term
     */
    @KSerializable
    data class SafeMathNarrow(override val returnSort: Tag.Bits) : TACBuiltInFunction() {

        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.safe_math_narrow
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Int)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression =
            { args ->
                val arg = conv(args.single(), meta)
                conv.lxf {
                    when (val tag = arg.tag) {
                        Tag.Int -> applyExp(NonSMTInterpretedFunctionSymbol.Unary.SafeMathNarrow(returnSort), arg)
                        is Tag.Bits -> when {
                            tag.bitwidth > returnSort.bitwidth -> applyExp(
                                NonSMTInterpretedFunctionSymbol.Unary.SafeUnsignedNarrow(
                                    tag,
                                    returnSort
                                ), arg
                            )

                            tag.bitwidth < returnSort.bitwidth -> applyExp(
                                NonSMTInterpretedFunctionSymbol.Unary.UnsignedPromote(
                                    tag,
                                    returnSort
                                ), arg
                            )

                            else -> arg
                        }
                        else -> error("expected $arg to be a subtype of ${paramSorts[0]}, but got $tag")
                    }
                }
            }

        override fun eval(params: List<BigInteger>): BigInteger? =
            super.eval(params).let { params.single().takeIf(::isInUnsignedBounds) }

    }

    /**
     * Extends an operand of [Tag.Bits] to [returnSort]. Retains the sign of the value (in 2s complement).
     */
    @KSerializable
    data class SignedPromotion(val param: Tag.Bits, override val returnSort: Tag.Bits): TACBuiltInFunction() {
        init {
            check(returnSort.bitwidth > param.bitwidth) { "Resulting bitwidth needs to be larger than the arguments bitwidth, can not promote from $param to $returnSort" }
        }
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.signed_promotion
        override val paramSorts: List<Tag>
            get() = listOf(param)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression = { args ->
            conv.lxf.applyExp(
                NonSMTInterpretedFunctionSymbol.Unary.SignedPromote(param, returnSort),
                conv(args.single(), meta)
            )
        }

        override fun eval(params: List<BigInteger>): BigInteger =
            params.single().signExtend(param.bitwidth, returnSort.bitwidth)
    }

    /**
     * Extends an operand of [Tag.Bits] to [returnSort]. Prepends zeros, resulting in a positive value regardless of the
     * arguments sign (in 2s complement)
     */
    @KSerializable
    data class UnsignedPromotion(val param: Tag.Bits, override val returnSort: Tag.Bits): TACBuiltInFunction() {
        init {
            check(returnSort.bitwidth > param.bitwidth) { "Resulting bitwidth needs to be larger than the arguments bitwidth, can not promote from $param to $returnSort" }
        }
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.unsigned_promotion
        override val paramSorts: List<Tag>
            get() = listOf(param)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression = { args ->
            conv.lxf.applyExp(
                NonSMTInterpretedFunctionSymbol.Unary.UnsignedPromote(param, returnSort),
                conv(args.single(), meta)
            )
        }

        override fun eval(params: List<BigInteger>): BigInteger = params.single()
    }

    /**
     * Narrows an operand of [Tag.Bits] to [returnSort]. Assumes that the argument, interpreted as signed value in 2s
     * complement, is in range of the resulting tag. The result of this operation are always the lower bits of the
     * operand.
     */
    @KSerializable
    data class SafeSignedNarrow(val param: Tag.Bits, override val returnSort: Tag.Bits): TACBuiltInFunction() {
        init {
            check(returnSort.bitwidth < param.bitwidth) { "Resulting bitwidth needs to be smaller than the arguments bitwidth, can not narrow from $param to $returnSort" }
        }
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.signed_narrow
        override val paramSorts: List<Tag>
            get() = listOf(param)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression = { args ->
            conv.lxf.applyExp(
                NonSMTInterpretedFunctionSymbol.Unary.SafeSignedNarrow(param, returnSort),
                conv(args.single(), meta)
            )
        }

        override fun eval(params: List<BigInteger>): BigInteger =
            params.single()
                .from2sComplement(param.bitwidth)
                .also { check(isInSignedBounds(it, returnSort.bitwidth)) { "signed value is out of range: $it in $returnSort" } }
                .to2sComplement(returnSort.bitwidth)
    }

    /**
     * Narrows an operand of [Tag.Bits] to [returnSort]. Assumes that the argument, interpreted as unsigned value, is in
     * range of the resulting tag. The result of this operation are always the lower bits of the operand.
     */
    @KSerializable
    data class SafeUnsignedNarrow(val param: Tag.Bits, override val returnSort: Tag.Bits): TACBuiltInFunction() {
        init {
            check(returnSort.bitwidth < param.bitwidth) { "Resulting bitwidth needs to be smaller than the arguments bitwidth, can not narrow from $param to $returnSort" }
        }
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.unsigned_narrow
        override val paramSorts: List<Tag>
            get() = listOf(param)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression = { args ->
            conv.lxf.applyExp(
                NonSMTInterpretedFunctionSymbol.Unary.SafeUnsignedNarrow(param, returnSort),
                conv(args.single(), meta)
            )
        }

        override fun eval(params: List<BigInteger>): BigInteger =
            params.single()
                .also { check(isInUnsignedBounds(it, returnSort.bitwidth)) { "unsigned value is out of range: $it in $returnSort" } }
    }

    sealed interface TransientMemoryBif {
        val transientId: TransientCallId
        val partitionId: Int
    }

    /**
     * Consult the documentation for [TransientCallId]
     */
    @KSerializable
    data class PartitionInitialize(override val transientId: TransientCallId, override val partitionId: Int) : TACBuiltInFunction(), TransientMemoryBif {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.partition_init
        override val paramSorts: List<Tag>
            get() = listOf()
        override val returnSort: Tag
            get() = Tag.ByteMap

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            throw UnsupportedOperationException("$this is not expected to appear at vc gen time")
        }
    }

    /**
     * Consult the documentation for [TransientCallId]
     */
    @KSerializable
    data class ReadTransientPartition(override val transientId: TransientCallId, override val partitionId: Int) : TACBuiltInFunction(), TransientMemoryBif {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.transient_read
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            throw UnsupportedOperationException("$this is not expected to appear at vc gen time")
        }

    }

    data class BuiltinFunctionVar(val eName: BuiltInFuncName,
                                  val paramSorts: List<Tag>,
                                  val returnSort: Tag,){
        fun getVar(): TACExpr.Sym.Var = TACSymbol.Var(eName.name, Tag.GhostMap(paramSorts, returnSort)).asSym()
    }
}
