/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

@file:kotlinx.serialization.UseSerializers(BigIntegerSerializer::class)
package vc.data

import analysis.pta.abi.TransientCallId
import com.certora.collect.*
import datastructures.stdcollections.*
import smt.solverscript.LExpressionFactory
import smt.solverscript.functionsymbols.FunctionSymbol
import smt.solverscript.functionsymbols.NonSMTInterpretedFunctionSymbol
import tac.MetaMap
import tac.Tag
import utils.*
import utils.ModZm.Companion.asBigInteger
import utils.ModZm.Companion.from2s
import utils.ModZm.Companion.inBounds
import utils.ModZm.Companion.inBoundsCheck
import utils.ModZm.Companion.inSignedBounds
import utils.ModZm.Companion.signExtend
import utils.ModZm.Companion.to2s
import java.io.Serializable
import java.math.BigInteger


/**
 * [TACBuiltInFunction]:
 * TACBuiltInFunctions, or Bifs are operators that are built into TAC, but not as heavily as the standard operators (like Add, IntAdd, BwAnd, LAnd, etc).
 * They're used by constructing a TACExpr.Apply(<bif>, <operands>)
 * basically we have them so it's relatively easy for us to add new operators in TAC.
 * (for comparison, adding a standard operator to TACExpr, would have us change every single when that goes over TACExpr s -- bifs are a bit easier usually)
 *
 * To add a new kind of [TACBuiltInFunction], just add a new subclass here.
 * Most requirements should be enforced by Kotlin (i.e. being serializable, stable hash, giving a name and signature).
 *
 * The only thing that is only checked on runtime is uniqueness of the names:
 * No two different [TACBuiltInFunction] objects may have the same name.
 * (will throw in `TACSerializationTools.writeSymbolTable`)
 *
 * Note that in case of a `object`, the name is just the `eName`; in case of a `class`, the name is generated by combining `eName` and `printInstanceId`.
 *
 */
@KSerializable
@Treapable
sealed class TACBuiltInFunction : AmbiSerializable {

    abstract val eName: BuiltInFuncName
    abstract val paramSorts: List<Tag>
    abstract val returnSort: Tag

    val name: String
        get() = "$eName${printInstanceId()}"

    /** returns null if params can't be evaluated for some reason */
    open fun eval(params : List<BigInteger>) : BigInteger? {
        require(params.size == paramSorts.size) {
            "calling $name with $params, but it takes only ${paramSorts.size} parameters"
        }
        return null
    }

    /**
     *  Prints a unique name alias.
     *  When you add a new type you should update here:
     *  If this is a class rather than an object,
     *   one should add a branch here that each instantiation is unique and matches [TACSymbolConstants.IdentifierRegex].
     *  o.w. just add the name in the end of this list (as all the other bif objects)
     */
    fun printInstanceId() : String = when(this) {
        is Hash.SimpleHashApplication -> "_${arity}_$hashFamily"
        is OpaqueIdentity -> "_$tag"
        is PartitionInitialize -> "${this.transientId.transientId}_${this.partitionId}"
        is ReadTransientPartition -> "${this.transientId.transientId}_${this.partitionId}"

        is SignedPromotion -> "_${paramSort.bitwidth}_${returnSort.bitwidth}"
        is UnsignedPromotion -> "_${paramSort.bitwidth}_${returnSort.bitwidth}"
        is SafeSignedNarrow -> "_${paramSort.bitwidth}_${returnSort.bitwidth}"
        is SafeUnsignedNarrow -> "_${paramSort.bitwidth}_${returnSort.bitwidth}"
        is SafeMathNarrow -> "_${returnSort}"
        is SafeMathPromotion -> "_${paramSort}"

        is NoSMulOverAndUnderflowCheck -> "_${tag.bitwidth}"
        is NoSAddOverAndUnderflowCheck -> "_${tag.bitwidth}"
        is NoSSubOverAndUnderflowCheck -> "_${tag.bitwidth}"
        is NoAddOverflowCheck -> "_${tag.bitwidth}"
        is NoMulOverflowCheck -> "_${tag.bitwidth}"
        is TwosComplement.Unwrap -> "_${tag.bitwidth}"
        is TwosComplement.Wrap -> "_${tag.bitwidth}"

        //the rest are objects and don't have params:
        DisjointSighashes,
        Hash.Addition,
        Hash.Basic,
        Hash.FromSkey,
        Hash.ToSkey,
        LinkContractAddress,
        PrecompiledECRecover,
        ToStorageKey -> ""
    }

    /*
       DisjointSighashes(addr) returns a non-deterministic value that is definitely NOT
       equal to a sighash of the contract addr.

       This can (and should) be simplified away as part of rule-preprocessing.
     */
    @KSerializable
    object DisjointSighashes : TACBuiltInFunction() {
        override fun hashCode() = hashObject(this)
        fun readResolve(): Any = DisjointSighashes
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.disjoint_sighashes
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            return { _ ->
                throw UnsupportedOperationException("DisjointSighashes should have been instrumented away before VC generation")
            }
        }

    }

    @KSerializable
    object LinkContractAddress : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.link_library
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            throw UnsupportedOperationException("This should have been replaced a long time ago")
        }

        override fun hashCode(): Int = hashObject(this)

        fun readResolve() : Any {
            return LinkContractAddress
        }

    }

    /** Please do not use this in `when`-constructs in order to find out which TACBuiltinFunction you're seeing -- just
     * switch over the TACBuiltInFunction itself and use its class hierarchy directly. */
    enum class BuiltInFuncName {
        smul_no_ofl_udfl,  // true iff signed op1*op2 does not overflow and does not underflow
        sadd_no_ofl_udfl, // true iff signed op1+op2 does not overflow and does not underflow
        ssub_no_ofl_udfl, // true iff signed op1-op2 does not overflow and does not underflow
        add_noofl,  // true iff op1+op2 does not overflow
        mul_noofl,    // true iff op1*op2 has no overflow
        opaque_identity,  // the identity function
        ecrecover,
        wrap_twos_complement,
        unwrap_twos_complement,
        skey_basic,
        skey_add,
        hash,
        to_skey,
        from_skey,
        safe_math_promotion,
        safe_math_narrow,
        signed_promotion,
        unsigned_promotion,
        signed_narrow,
        unsigned_narrow,
        disjoint_sighashes,
        link_library,
        to_storage_key,
        partition_init,
        transient_read,
        ;
    }

    fun toTACFunctionSym(): TACExpr.TACFunctionSym.BuiltIn = TACExpr.TACFunctionSym.BuiltIn(this)

    fun toInScopeBuiltinFunc(): FunctionInScope.Builtin = FunctionInScope.Builtin(this)

    open val ufAttribute: UFAttribute = UFAttribute.None

    fun getLExpressionBuilder(
        lxf: LExpressionFactory,
        symbolTable: TACSymbolTable,
        meta: MetaMap?,
    ): (List<TACExpr>) -> LExpression = getLExpressionBuilder(ToLExpression.Conv(lxf, symbolTable), meta)

    abstract fun getLExpressionBuilder(
        conv: ToLExpression.Conv,
        meta: MetaMap?,
    ): (List<TACExpr>) -> LExpression

    @KSerializable
    sealed class WithSMTFunctionSymbol(
        override val eName: BuiltInFuncName,
        override val paramSorts: List<Tag>,
        override val returnSort: Tag
    ) : TACBuiltInFunction(), Serializable {

        abstract val smtFuncSym: FunctionSymbol

        override fun getLExpressionBuilder(
            conv: ToLExpression.Conv,
            meta: MetaMap?,
        ): (List<TACExpr>) -> LExpression =
            { args ->
                check(args.size == this.paramSorts.size)
                conv.lxf.applyExp(
                    this.smtFuncSym,
                    args.map { conv(it, meta) }
                )
            }
    }

    @KSerializable
    data class NoSMulOverAndUnderflowCheck(val tag: Tag.Bits) : WithSMTFunctionSymbol(
        BuiltInFuncName.smul_no_ofl_udfl,
        listOf(tag, tag),
        Tag.Bool
    ) {
        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoSMulOverUnderflow(tag)

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                (params[0].from2s(tag) * params[1].from2s(tag)).inSignedBounds()
            }.asBigInteger
    }

    @KSerializable
    data class NoSAddOverAndUnderflowCheck(val tag: Tag.Bits) : WithSMTFunctionSymbol(
        BuiltInFuncName.sadd_no_ofl_udfl,
        listOf(tag, tag),
        Tag.Bool
    ) {
        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoSAddOverUnderflow(tag)

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                (params[0].from2s(tag) + params[1].from2s(tag)).inSignedBounds()
            }.asBigInteger
    }


    @KSerializable
    data class NoSSubOverAndUnderflowCheck(val tag: Tag.Bits) : WithSMTFunctionSymbol(
        BuiltInFuncName.ssub_no_ofl_udfl,
        listOf(tag, tag),
        Tag.Bool
    ) {
        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoSSubOverUnderflow(tag)

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                (params[0].from2s(tag) - params[1].from2s(tag)).inSignedBounds()
            }.asBigInteger
    }




    // Add
    @KSerializable
    data class NoAddOverflowCheck(val tag: Tag.Bits) : WithSMTFunctionSymbol(
        BuiltInFuncName.add_noofl,
        listOf(tag, tag),
        Tag.Bool
    ) {
        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoAddOverflow(tag)

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                (params[0] + params[1]).inBounds(tag)
            }.asBigInteger
    }

    // Mul
    @KSerializable
    data class NoMulOverflowCheck(val tag : Tag.Bits) : WithSMTFunctionSymbol(
        BuiltInFuncName.mul_noofl,
        listOf(tag, tag),
        Tag.Bool
    ) {
        override val smtFuncSym: FunctionSymbol
            get() = NonSMTInterpretedFunctionSymbol.Binary.NoMulOverflow(tag)

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let {
                (params[0] * params[1]).inBounds(tag)
            }.asBigInteger
    }

    @KSerializable
    data class OpaqueIdentity(val tag: Tag) : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.opaque_identity

        override val paramSorts: List<Tag>
            get() = listOf(tag)

        override val returnSort: Tag
            get() = tag

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression =
            { args ->
                check(args.size == 1)
                conv(args.first(), meta)
            }
    }

    @KSerializable
    object PrecompiledECRecover : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.ecrecover
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256, Tag.Int, Tag.Bit256, Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256

        override fun hashCode() = hashObject(this)
        fun readResolve(): Any = PrecompiledECRecover

        // Note - we implement this as a multiselect instead of an UF application so that grounding will "see" it as
        // a use site for quantified variables.
        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression =
            { args ->
                check(args.size == this.paramSorts.size)
                val tag = Tag.GhostMap(paramSorts, returnSort)
                conv.lxf {
                    multiSelect(const(name, tag), args.map { conv(it, meta) }, tag)
                }
            }
    }

    /**
     * NB the bifs herein assume type correctness guaranteed by VM Converters
     */
    @KSerializable
    sealed class TwosComplement: TACBuiltInFunction() {
        abstract val paramSort: Tag
        override val paramSorts: List<Tag>
            get() = listOf(paramSort)

        /**
         * Takes a parameter encoded as an arbitrary precision integer and converts it to a two's complement value
         * in the bitwidth of [tag].
         *
         * Assumes input value will fit into a two's complement bitvector of [tag] (this is verified inside
         * the converter logic)
         */
        @KSerializable
        data class Wrap(val tag : Tag.Bits) : TwosComplement() {
            override val eName: BuiltInFuncName = BuiltInFuncName.wrap_twos_complement
            override val paramSort: Tag = Tag.Int
            override val returnSort: Tag.Bits = tag

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression {
                return { e ->
                    conv.lxf {
                        conv(e.single(), meta).let { lExp ->
                            ite(lExp ge ZERO, lExp, lExp + litInt(tag.modulus)) safeMathNarrow returnSort
                        }
                    }
                }
            }

            override fun eval(params: List<BigInteger>): BigInteger? =
                super.eval(params).let {
                    params[0].to2s(tag)
                }
        }

        /**
         * Takes a parameter encoded as a two's complement value of the bitwidth of [tag] and converts it to an arbitrary
         * precision signed integer.
         */
        @KSerializable
        data class Unwrap(val tag : Tag.Bits) : TwosComplement() {
            override val eName: BuiltInFuncName = BuiltInFuncName.unwrap_twos_complement
            override val paramSort: Tag = tag
            override val returnSort: Tag = Tag.Int

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression {
                return { e ->
                    conv.lxf {
                        conv(e.single(), meta).let { lExp ->
                            ite(
                                lExp intLe litInt(tag.maxSigned),
                                lExp,
                                lExp - litInt(tag.modulus)
                            )
                        }
                    }
                }
            }

            override fun eval(params: List<BigInteger>): BigInteger =
                super.eval(params).let {
                    params[0].from2s(tag)
                }
        }

    }

    @KSerializable
    object ToStorageKey : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.to_storage_key
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256
        override val ufAttribute: UFAttribute
            get() = UFAttribute.None

        override fun hashCode(): Int = hashObject(this)

        fun readResolve(): Any = ToStorageKey

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            throw UnsupportedOperationException("Should have been replaced by SKey annotation")
        }
    }

    @KSerializable
    sealed class Hash : TACBuiltInFunction() {

        companion object {
            // TODO [CERT-1790]: have Tag.BuiltinSort or so instead? https://certora.atlassian.net/browse/CERT-1790
            val skeySort = Tag.UserDefined.UninterpretedSort(storageKeySortName)
        }

        @KSerializable
        object Basic : Hash() {
            override fun hashCode() = hashObject(this)

            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.skey_basic
            override val paramSorts: List<Tag>
                get() = listOf(Tag.Int)
            override val returnSort: Tag
                get() = skeySort

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression = { args ->
                conv.lxf.applyExp(
                    NonSMTInterpretedFunctionSymbol.Hash.Basic,
                    args.map { conv(it, meta) }
                )
            }

            private fun readResolve(): Any = Basic
        }

        @KSerializable
        data class SimpleHashApplication(val arity: Int, val hashFamily: HashFamily) : Hash() {
            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.hash
            override val paramSorts: List<Tag>
                get() =
                    if (hashFamily.requiresLargeGaps) {
                        List(arity) { skeySort }
                    } else {
                        List(arity) { Tag.Bit256 }
                    }
            override val returnSort: Tag
                get() =
                    if (hashFamily.requiresLargeGaps) {
                        skeySort
                    } else {
                        Tag.Bit256
                    }

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression =
                { args ->
                    conv.lxf.applyExp(
                        NonSMTInterpretedFunctionSymbol.Hash.SimpleHashN(arity, hashFamily),
                        args.map { conv(it, meta) }
                    )
                }
        }

        @KSerializable
        object Addition : Hash() {
            override fun hashCode() = hashObject(this)

            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.skey_add
            override val paramSorts: List<Tag>
                get() = listOf(skeySort, Tag.Int)
            override val returnSort: Tag
                get() = skeySort

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression = { args ->
                conv.lxf.applyExp(
                    NonSMTInterpretedFunctionSymbol.Hash.SkeyAdd,
                    args.map { conv(it, meta) }
                )
            }

            private fun readResolve(): Any = Addition
        }

        @KSerializable
        object ToSkey : Hash() {
            override fun hashCode() = hashObject(this)

            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.to_skey
            override val paramSorts: List<Tag>
                get() = listOf(Tag.Bit256)
            override val returnSort: Tag
                get() = skeySort

            /** A map variable that the fuzzer can use to store the state of the ToSkey function.
             * Doesn't really have anything to do with ghost. Once we have sorted out Tag.Map, this can be a normal map
             * sort. */
            val asMapVar: TACExpr.Sym.Var = TACSymbol.Var(eName.name, Tag.GhostMap(paramSorts, returnSort)).asSym()

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression = { args ->
                conv.lxf.applyExp(
                    NonSMTInterpretedFunctionSymbol.Hash.ToSkey,
                    args.map { conv(it, meta) }
                )
            }

            private fun readResolve(): Any = ToSkey
        }

        @KSerializable
        object FromSkey : Hash() {
            override fun hashCode() = hashObject(this)

            override val eName: BuiltInFuncName
                get() = BuiltInFuncName.from_skey
            override val paramSorts: List<Tag>
                get() = listOf(skeySort)
            override val returnSort: Tag
                get() = Tag.Bit256

            /** A map variable that the fuzzer can use to store the state of the FromSkey function.
             * Doesn't really have anything to do with ghost. Once we have sorted out Tag.Map, this can be a normal map
             * sort. */
            val asMapVar: TACExpr.Sym.Var =
                TACSymbol.Var(eName.name, Tag.GhostMap(paramSorts, returnSort)).asSym()

            override fun getLExpressionBuilder(
                conv: ToLExpression.Conv,
                meta: MetaMap?
            ): (List<TACExpr>) -> LExpression = { args ->
                conv.lxf.applyExp(
                    NonSMTInterpretedFunctionSymbol.Hash.FromSkey,
                    args.map { conv(it, meta) }
                )
            }

            private fun readResolve(): Any = FromSkey
        }
    }

    /**
     * Translate a uint directly into int without any operations: i.e., do not adjust for signedness etc.
     * Compiled out when going to LExpressions
     */
    @KSerializable
    data class SafeMathPromotion(val paramSort: Tag.Bits) : TACBuiltInFunction() {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.safe_math_promotion
        override val paramSorts: List<Tag.Bits>
            get() = listOf(paramSort)
        override val returnSort: Tag
            get() = Tag.Int

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression =
            { args -> conv(args.single(), meta) }

        override fun eval(params: List<BigInteger>): BigInteger =
            super.eval(params).let { params.single() }
    }

    /**
     * An "experts only" promise that a math int definitely falls within the uint256 range, and can be safely
     * reinterpreted as such without conversions or modulo application. Nothing happens if this check is violated,
     * this function only exists to make the type checking work and is an internal function in every sense of the term
     */
    @KSerializable
    data class SafeMathNarrow(override val returnSort: Tag.Bits) : TACBuiltInFunction() {

        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.safe_math_narrow
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Int)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression =
            { args ->
                val arg = conv(args.single(), meta)
                conv.lxf {
                    when (val tag = arg.tag) {
                        Tag.Int -> applyExp(NonSMTInterpretedFunctionSymbol.Unary.SafeMathNarrow(returnSort), arg)
                        is Tag.Bits -> when {
                            tag.bitwidth > returnSort.bitwidth -> applyExp(
                                NonSMTInterpretedFunctionSymbol.Unary.SafeUnsignedNarrow(tag, returnSort),
                                arg
                            )

                            tag.bitwidth < returnSort.bitwidth -> applyExp(
                                NonSMTInterpretedFunctionSymbol.Unary.UnsignedPromote(tag, returnSort),
                                arg
                            )

                            else -> arg
                        }
                        else -> error("expected $arg to be a subtype of ${paramSorts[0]}, but got $tag")
                    }
                }
            }

        override fun eval(params: List<BigInteger>): BigInteger? =
            super.eval(params).let {
                // We completely trust whoever used this safeMathNarrow. If the value is out of bounds then we assume
                // this is due to some vacuity regardless of this narrowing.
                params.single().takeIf { it.inBounds(returnSort) }
            }

    }

    /**
     * Extends an operand of [Tag.Bits] to [returnSort]. Retains the sign of the value (in 2s complement).
     */
    @KSerializable
    data class SignedPromotion(val paramSort: Tag.Bits, override val returnSort: Tag.Bits): TACBuiltInFunction() {
        init {
            check(returnSort.bitwidth > paramSort.bitwidth) {
                "Resulting bitwidth needs to be larger than the arguments bitwidth, can not promote from $paramSort to $returnSort"
            }
        }
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.signed_promotion
        override val paramSorts: List<Tag>
            get() = listOf(paramSort)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression = { args ->
            conv.lxf.applyExp(
                NonSMTInterpretedFunctionSymbol.Unary.SignedPromote(paramSort, returnSort),
                conv(args.single(), meta)
            )
        }

        override fun eval(params: List<BigInteger>): BigInteger =
            params.single().signExtend(paramSort.bitwidth, returnSort.bitwidth)
    }

    /**
     * Extends an operand of [Tag.Bits] to [returnSort]. Prepends zeros, resulting in a positive value regardless of the
     * arguments sign (in 2s complement)
     */
    @KSerializable
    data class UnsignedPromotion(val paramSort: Tag.Bits, override val returnSort: Tag.Bits): TACBuiltInFunction() {
        init {
            check(returnSort.bitwidth > paramSort.bitwidth) {
                "Resulting bitwidth needs to be larger than the arguments bitwidth, can not promote from $paramSort to $returnSort"
            }
        }
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.unsigned_promotion
        override val paramSorts: List<Tag>
            get() = listOf(paramSort)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression = { args ->
            conv.lxf.applyExp(
                NonSMTInterpretedFunctionSymbol.Unary.UnsignedPromote(paramSort, returnSort),
                conv(args.single(), meta)
            )
        }

        override fun eval(params: List<BigInteger>): BigInteger = params.single()
    }

    /**
     * Narrows an operand of [Tag.Bits] to [returnSort]. Assumes that the argument, interpreted as signed value in 2s
     * complement, is in range of the resulting tag. The result of this operation are always the lower bits of the
     * operand.
     */
    @KSerializable
    data class SafeSignedNarrow(val paramSort: Tag.Bits, override val returnSort: Tag.Bits): TACBuiltInFunction() {
        init {
            check(returnSort.bitwidth < paramSort.bitwidth) {
                "Resulting bitwidth needs to be smaller than the arguments bitwidth, can not narrow from $paramSort to $returnSort"
            }
        }
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.signed_narrow
        override val paramSorts: List<Tag>
            get() = listOf(paramSort)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression = { args ->
            conv.lxf.applyExp(
                NonSMTInterpretedFunctionSymbol.Unary.SafeSignedNarrow(paramSort, returnSort),
                conv(args.single(), meta)
            )
        }

        override fun eval(params: List<BigInteger>): BigInteger =
            params.single().from2s(paramSort).to2s(returnSort)
    }

    /**
     * Narrows an operand of [Tag.Bits] to [returnSort]. Assumes that the argument, interpreted as unsigned value, is in
     * range of the resulting tag. The result of this operation are always the lower bits of the operand.
     */
    @KSerializable
    data class SafeUnsignedNarrow(val paramSort: Tag.Bits, override val returnSort: Tag.Bits): TACBuiltInFunction() {
        init {
            check(returnSort.bitwidth < paramSort.bitwidth) { "Resulting bitwidth needs to be smaller than the arguments bitwidth, can not narrow from $paramSort to $returnSort" }
        }
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.unsigned_narrow
        override val paramSorts: List<Tag>
            get() = listOf(paramSort)

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression = { args ->
            conv.lxf.applyExp(
                NonSMTInterpretedFunctionSymbol.Unary.SafeUnsignedNarrow(paramSort, returnSort),
                conv(args.single(), meta)
            )
        }

        override fun eval(params: List<BigInteger>): BigInteger =
            params.single().inBoundsCheck(returnSort)

    }

    sealed interface TransientMemoryBif {
        val transientId: TransientCallId
        val partitionId: Int
    }

    /**
     * Consult the documentation for [TransientCallId]
     */
    @KSerializable
    data class PartitionInitialize(override val transientId: TransientCallId, override val partitionId: Int) : TACBuiltInFunction(), TransientMemoryBif {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.partition_init
        override val paramSorts: List<Tag>
            get() = listOf()
        override val returnSort: Tag
            get() = Tag.ByteMap

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            throw UnsupportedOperationException("$this is not expected to appear at vc gen time")
        }
    }

    /**
     * Consult the documentation for [TransientCallId]
     */
    @KSerializable
    data class ReadTransientPartition(override val transientId: TransientCallId, override val partitionId: Int) : TACBuiltInFunction(), TransientMemoryBif {
        override val eName: BuiltInFuncName
            get() = BuiltInFuncName.transient_read
        override val paramSorts: List<Tag>
            get() = listOf(Tag.Bit256)
        override val returnSort: Tag
            get() = Tag.Bit256

        override fun getLExpressionBuilder(conv: ToLExpression.Conv, meta: MetaMap?): (List<TACExpr>) -> LExpression {
            throw UnsupportedOperationException("$this is not expected to appear at vc gen time")
        }

    }

    data class BuiltinFunctionVar(val eName: BuiltInFuncName,
                                  val paramSorts: List<Tag>,
                                  val returnSort: Tag,){
        fun getVar(): TACExpr.Sym.Var = TACSymbol.Var(eName.name, Tag.GhostMap(paramSorts, returnSort)).asSym()
    }
}
