/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package vc

import algorithms.topologicalOrder
import analysis.CmdPointer
import com.certora.collect.*
import kotlinx.coroutines.*
import log.*
import report.DummyLiveStatsReporter
import scene.IScene
import scene.ISceneIdentifiers
import scene.SceneFactory
import scene.source.DegenerateContractSource
import solver.SolverResult
import spec.rules.IRule.Companion.createDummyRule
import tac.NBId
import utils.*
import vc.data.*
import verifier.TACVerifier
import java.io.File
import java.io.FileInputStream
import kotlin.system.exitProcess

private val logger = Logger(LoggerTypes.COMMON)

/**
 * This class takes a [CoreTACProgram] (along with the associated [IScene]) that fails the sanity check and finds the
 * assume command that makes it unsat (i.e. that removing it makes the sanity succeed).
 * (This may not always succeed.)
 * The behavior on TACs that do pass the sanity check is undefined.
 */
class ReachabilityFailureSourceFinder(private val p: CoreTACProgram, private val scene: ISceneIdentifiers) {
    // the program, its graph, its dominates and its topological sorting
    private val graph = p.analysisCache.graph
    private val dom by lazy { p.analysisCache.domination }
    private val sort = topologicalOrder(p.blockgraph).reversed()

    init {
        logger.trace { "Topological order of blocks: $sort" }
    }

    // utility functions that do not depend on current ranges
    // the index of a pointer in the topological sort of blocks
    private fun getIndexInSort(ptr: CmdPointer) = sort.indexOf(ptr.block)

    // compare two command pointers [a] and [b]
    private fun lePtr(a: CmdPointer, b: CmdPointer) =
        getIndexInSort(a).let { ia ->
            getIndexInSort(b).let { ib ->
                ia <= ib &&
                        (ia < ib || a.pos <= b.pos)
            }
        }

    // runs the reachability failure source finder given a particular leaf.
    inner class LeafReachabilityChecker(leaf: CmdPointer) {
        // [rangeStart] and [rangeEnd] are the current points that we want to find the middle point of in our search.
        // Initialized to graph root, sink respectively, that are assumed to be single in our TAC:
        // The root is single by virtue of our TAC construction, and the sink by design of this check that
        // iterates on leaves
        private var rangeStart = graph.roots.singleOrNull()?.ptr ?: throw IllegalStateException("TAC reachability failure source finder only works on TACs with a single starting block (like TACs generated by rules)")
        private var rangeEnd = leaf

        // the [originalSink] is used to compute if other nodes are sinks or not
        private val originalSink = leaf


        // [finalRangeStart] and [finalRangeEnd] are two adjacent _sink_ nodes.
        // Sink nodes are nodes in the TAC that dominate the original sink and are useful in the first stage of the binary search
        private lateinit var finalRangeStart: CmdPointer
        private lateinit var finalRangeEnd: CmdPointer

        // true if we already found two adjacent sinks to search in between
        private var finalizedRanges: Boolean = false

        // which middle points we already checked in the binary search?
        private val usedMidRanges = mutableMapOf<CmdPointer, SolverResult>()

        // a sink node is any node that dominates the leaf (i.e. we must always go through it)
        private fun isNodeSink(b: NBId): Boolean =
            dom.dominates(b, originalSink.block)

        // check if the range does not contain any more sink nodes
        private fun noMoreSinkNodes(): Boolean =
            sort.filterIndexed { idx, elem ->
                idx > getIndexInSort(rangeStart) && idx < getIndexInSort(rangeEnd) && isNodeSink(
                    elem
                )
            }.isEmpty()


        // Computed the next point where we try to put an assert. Should be the middle point between [rangeStart] and [rangeEnd]
        private fun getMidRange(): ReachabilityIndicator {
            // if no sink nodes in between, we should fix startRange and endRange so that we can fallback to those
            if (finalizedRanges) {
                // if we finalized, we try to get the middle using the current start and end, but otherwise we reset back to the final sink node range
                return getMidRangeBetweenAdjacentSinkNodes(rangeStart, rangeEnd)
            } else if (noMoreSinkNodes()) {
                finalRangeStart = rangeStart
                finalRangeEnd = rangeEnd
                finalizedRanges = true
                logger.trace { "Finalized big range $rangeStart, $rangeEnd" }
                return getMidRangeBetweenAdjacentSinkNodes(rangeStart, rangeEnd)
            } else {
                // choose sink node in the middle (guaranteed to exist)
                val sinkNodesSort = sort.filter { isNodeSink(it) }
                val startIdx = sinkNodesSort.indexOf(rangeStart.block)
                val endIdx = sinkNodesSort.indexOf(rangeEnd.block)
                val relevantChoices = sinkNodesSort.filterIndexed { idx, e ->
                    CmdPointer(
                        e,
                        0
                    ) !in usedMidRanges && startIdx < idx && idx < endIdx
                }
                check(relevantChoices.isNotEmpty()) { "No more relevant choices in range $startIdx, $endIdx out of $sinkNodesSort, used mids are $usedMidRanges" }
                return CmdPointer(relevantChoices[relevantChoices.size / 2], 0).lift()
            }
        }

        private fun getMidRangeBetweenAdjacentSinkNodes(start: CmdPointer, end: CmdPointer): ReachabilityIndicator {
            // same block search
            if (start.block == end.block) {
                if (end.pos <= start.pos) {
                    logger.trace { "popping back got wrong ranges $start, $end" }
                    return ReachabilityIndicator.NoUnreachability
                }
                return CmdPointer(start.block, (end.pos + start.pos) / 2).let {
                    if (it in usedMidRanges) {
                        it.copy(pos = it.pos + 1)
                    } else {
                        it
                    }
                }.lift()
            }

            // check ranges
            val startIdx = getIndexInSort(start)
            val endIdx = getIndexInSort(end)
            if (startIdx >= endIdx) {
                logger.trace { "got wrong ranges $start,$end" }
                return ReachabilityIndicator.NoUnreachability
            }

            // get by averaging the indices and picking an unused node that is not necessarily a sink
            val midIdxCandidate = Math.min((endIdx + startIdx) / 2 + 1, endIdx)
            val midCandidate = sort[midIdxCandidate]

            return CmdPointer(midCandidate, 0).let {
                if (it in usedMidRanges) {
                    graph.pred(it).first()
                } else {
                    it
                }
            }.lift()
        }

        // create a TAC program with a new assert false in [assertLoc]
        // removes all successor nodes to the node in the `assert false` to optimize
        // future work: could also remove the commands in the block, but this matters less
        private fun buildFromRange(assertLoc: CmdPointer): CoreTACProgram {
            val mutatedCode = p.code.toMutableMap()
            val mutatedGraph = MutableBlockGraph(p.blockgraph)
            val block = mutatedCode[assertLoc.block]!!
            val mutatedBlock = mutableListOf<TACCmd.Simple>()
            for ((i, c) in block.withIndex()) {
                if (i < block.indices.last || (c !is TACCmd.Simple.JumpiCmd && c !is TACCmd.Simple.JumpCmd)) {
                    mutatedBlock.add(c)
                }
                if (i == assertLoc.pos) {
                    mutatedBlock.add(TACCmd.Simple.AssertCmd(TACSymbol.False, "sanity"))
                }
            }
            mutatedCode[assertLoc.block] = mutatedBlock
            val nearestSink = assertLoc.block
            val succs = dom.dominatedOf(nearestSink)
            for (succ in succs) {
                if (succ != assertLoc.block) {
                    mutatedCode.remove(succ)
                    mutatedGraph.remove(succ)
                }
            }
            mutatedGraph[assertLoc.block] = treapSetOf()
            return p.copy(code = mutatedCode, blockgraph = mutatedGraph)
        }

        suspend fun runSanityCheckForLeaf(justTopLevel : Boolean = false): ReachabilityIndicator {
            var round = 0
            var mid: CmdPointer
            while (lePtr(rangeStart, rangeEnd)) {
                ++round
                logger.trace {
                    "Running round $round, range is $rangeStart ${if (isNodeSink(rangeStart.block)) "Sink" else ""}, " +
                            "$rangeEnd ${if (isNodeSink(rangeEnd.block)) "Sink" else ""}"
                }
                mid = when (val midRange = getMidRange()) {
                    ReachabilityIndicator.NoUnreachability -> {
                        // todo reachable?
                        logger.trace { "Stopped at $rangeStart,$rangeEnd: ${graph.elab(rangeStart)}" }
                        return ReachabilityIndicator.NoUnreachability
                    }
                    is ReachabilityIndicator.UnreachabilityPointer -> midRange.cmdPointer
                }
                if (mid in usedMidRanges) {
                    // we're done! converged to a choice
                    logger.trace { "Stopped in $mid" }
                    logger.trace { "Problematic command:" }
                    val cmd = graph.elab(mid)
                    logger.trace { "${cmd.cmd} at offset ${cmd.ptr.pos} of block ${cmd.ptr.block}:" }
                    logger.trace { graph.elab(mid.block).commands.joinToString("\n") { "${it.ptr.pos}: ${it.cmd}" } }
                    return if (usedMidRanges[mid] == SolverResult.SAT) {
                        ReachabilityIndicator.NoUnreachability
                    } else {
                        mid.lift()
                    }
                }

                logger.trace { "Putting assert false in $mid" }
                val p2 = buildFromRange(mid)
                val vRes = TACVerifier.verify(
                    scene,
                    p2,
                    liveStatsReporter = DummyLiveStatsReporter,
                    rule = createDummyRule(p2.name),
                )
                val finalResult = vRes.finalResult
                logger.trace { "Got result $finalResult" }
                when (finalResult) {
                    SolverResult.SAT -> {
                        // got sat: need to search after the point picked
                        rangeStart = mid
                    }
                    SolverResult.UNSAT -> {
                        // got unsat: need to search before the point picked
                        rangeEnd = mid
                    }
                    else -> {
                        return ReachabilityIndicator.NoUnreachability // could not detect an unreachability due to SMT failure
                    }
                }
                usedMidRanges[mid] = finalResult
                if (justTopLevel) break
            }

            // TODO: how could we reach here?
            logger.trace { "Stopped at $rangeStart,$rangeEnd: ${graph.elab(rangeStart)}" }
            return ReachabilityIndicator.NoUnreachability
        }
    }

    // runs the reachability failure source finder per leaf.
    // if there are multiple reachability failures, we only return the first one found.
    suspend fun runReachabilityFailureSourceFinder(justTopLevel: Boolean = false): FullProgramReachabilityResult {
        val reachResults = mutableListOf<UnReachabilityResult>()
        val leaves = graph.sinks.map { it.ptr }
        for (leaf in leaves) {
            logger.trace { "Working on leaf $leaf" }
            val res = LeafReachabilityChecker(leaf).runSanityCheckForLeaf(justTopLevel)
            if (res is ReachabilityIndicator.UnreachabilityPointer) {
                reachResults.add(UnReachabilityResult(leaf, res.cmdPointer))
            }
        }

        return if (reachResults.isEmpty()) {
            logger.trace { "No simple reachability failure found for any leaf of the input program" }
            FullProgramReachabilityResult.NoUnreachableLeaves
        } else {
            FullProgramReachabilityResult.ReachabilityProblems(reachResults)
        }
    }
}

sealed class ReachabilityIndicator {
    object NoUnreachability: ReachabilityIndicator()
    data class UnreachabilityPointer(val cmdPointer: CmdPointer): ReachabilityIndicator()
}

data class UnReachabilityResult(val leaf: CmdPointer, val unreachPtr: CmdPointer): java.io.Serializable
sealed interface FullProgramReachabilityResult: java.io.Serializable {
    fun details(tacProgram: CoreTACProgram): String

    object NoUnreachableLeaves : FullProgramReachabilityResult, java.io.Serializable {
        override fun details(tacProgram: CoreTACProgram) = ""
        private fun readResolve(): Any = NoUnreachableLeaves
    }

    data class ReachabilityProblems(val problems: List<UnReachabilityResult>) :
        FullProgramReachabilityResult, java.io.Serializable {
        override fun details(tacProgram: CoreTACProgram) =
            problems.asSequence().map { (leaf, unsatCmd) ->
                val (block, pos) = unsatCmd
                logger.info { "Reachability-breaking command block $block, pos $pos" }

                val sourceCode = tacProgram.code[block]?.get(pos)
                    ?.let { cmd -> cmd.metaSrcInfo?.getSourceCode()?.let { cmd to it } }
                    ?.let { (cmd, offendingSourceCode) -> ": '$cmd' Source: $offendingSourceCode" }
                    ?: ""

                val leafIndication = if (problems.size == 1) {
                    ""
                } else {
                    " for leaf $leaf"
                }

                "First reachability-breaking command$leafIndication$sourceCode"
            }.joinToString(separator = " ")
    }
}
fun CmdPointer.lift() = ReachabilityIndicator.UnreachabilityPointer(this)

fun main(args: Array<String>) {
    @Suppress("ForbiddenMethodCall") // ok to call this from main thread
    runBlocking {
        check(args.size == 1) { "Provide .tac or .tacbin file" }
        val tacFile = args.get(0)
        val fileExtension = File(tacFile).extension

        val coreTacProg = if (fileExtension == "tac") {
            CoreTACProgram.fromStream(FileInputStream(tacFile), "tac")
        } else {
            check(fileExtension == "tacbin") { "This tool supports only .tac and .tacbin formats" }
            CoreTACProgram.readBinary(tacFile)
        }

        val scene = SceneFactory.getScene(DegenerateContractSource(tacFile))

        println("Running reachability finder on $tacFile")
        val res = try {
            val reachabilityFailureSourceFinder = ReachabilityFailureSourceFinder(coreTacProg, scene)
            reachabilityFailureSourceFinder.runReachabilityFailureSourceFinder()
        } catch (e: Exception) {
            System.err.println("Reachability Failure Finder Failed! $e")
            null
        }

        if (res is FullProgramReachabilityResult.ReachabilityProblems) {
            println("Found reachability problems:")
            res.problems.forEach { (leaf, ptr) ->
                println("failure for leaf $leaf")
                println("failing cmd pointer: $ptr:")
                val cmd = coreTacProg.code[ptr.block]?.get(ptr.pos)
                val src = cmd?.metaSrcInfo?.getSourceCode()
                if (src != null) {
                    println("Failing command: $src")
                } else {
                    println("Failing command: $cmd")
                }
            }

            exitProcess(1)
        } else {
            println("No reachability failures found")
            exitProcess(0)
        }
    }
}
