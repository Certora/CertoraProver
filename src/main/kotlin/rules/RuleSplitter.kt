/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package rules

import allocator.Allocator
import analysis.*
import config.Config
import datastructures.stdcollections.*
import report.StatusReporter
import report.TreeViewReporter
import report.calltrace.toRuleIdentifier
import utils.Range
import spec.rules.SingleRuleGenerationMeta
import spec.cvlast.SpecType
import tac.MetaMap
import tac.NBId
import utils.takeUntil
import vc.data.*

object RuleSplitter {
    /**
     * An [TACCmd.Simple.AssertCmd] command with meta information
     * that is used for per-assert sub-rules generation.
     */
    internal sealed class AssertCmdWithMeta {

        companion object {

            /**
             * If [assertLTACCmd] is a user-defined assert command, allocates a fresh id that would be found
             * in the new [UserDefined] instance returned.
             */
            operator fun invoke(assertLTACCmd: LTACCmd): AssertCmdWithMeta {
                val assertCmd = assertLTACCmd.cmd
                require(assertCmd is TACCmd.Simple.AssertCmd) { "Expected $assertLTACCmd to be an assert command" }

                val rangeOfAssert =
                    assertCmd.meta.find(TACMeta.CVL_RANGE) ?: Range.Empty()

                return if (TACMeta.CVL_USER_DEFINED_ASSERT in assertCmd.meta) {
                    UserDefined(assertLTACCmd, assertCmd.description, Allocator.getFreshId(Allocator.Id.ASSERTS), rangeOfAssert)
                } else {
                    AutoGenerated(assertLTACCmd, assertCmd.description)
                }
            }
        }

        abstract val assertLTACCmd: LTACCmd
        abstract val assertMsg: String?

        val cmd: TACCmd.Simple
            get() = assertLTACCmd.cmd

        val ptr: CmdPointer
            get() = assertLTACCmd.ptr

        /**
         * Represent an [TACCmd.Simple.AssertCmd] command
         * that is auto-generated by the tool.
         */
        internal data class AutoGenerated(override val assertLTACCmd: LTACCmd, override val assertMsg: String?) :
            AssertCmdWithMeta()

        /**
         * Represents an [TACCmd.Simple.AssertCmd] command
         * that is user-defined, i.e., an assert command that originates from an assert statement written in a spec file.
         *
         * @param assertLTACCmd the user-defined assert command
         * @param assertId the unique id allocated for [assertLTACCmd]
         * @param assertLoc the location of the user-defined assert statement in the spec file
         */
        internal data class UserDefined(
            override val assertLTACCmd: LTACCmd,
            override val assertMsg: String,
            val assertId: Int,
            val assertLoc: Range
        ) :
            AssertCmdWithMeta()
    }

    /**
     * Returns a topologically sorted list of all [TACCmd.Simple.AssertCmd]
     * commands in [compiledRuleTacProg]. Each of these commands is encapsulated in an [AssertCmdWithMeta] instance.
     * Each [AssertCmdWithMeta.UserDefined] instance holds a new, fresh id ([AssertCmdWithMeta.UserDefined.assertId])
     * allocated for the underlying used-defined assert ([AssertCmdWithMeta.UserDefined.assertLTACCmd]).
     */
    internal fun getTopoSortedAssertsWithMeta(
        compiledRuleTacProg: CoreTACProgram
    ): List<AssertCmdWithMeta> {
        val topoSortedAssertsWithMeta = mutableListOf<AssertCmdWithMeta>()

        compiledRuleTacProg.topoSortFw.forEach { nbId: NBId ->
            compiledRuleTacProg.analysisCache.graph.elab(nbId).commands.forEach {
                if (it.cmd is TACCmd.Simple.AssertCmd) {
                    topoSortedAssertsWithMeta.add(AssertCmdWithMeta(it))
                }
            }
        }
        return topoSortedAssertsWithMeta
    }

    /**
     * Transforms all the [TACCmd.Simple.AssertCmd]
     * commands in [prog] that satisfy the predicate [transIntoAssume] and precede the assert command [assertToCheck]
     * (w.r.t. topological ordering given by [topoSortedAssertsWithMeta]), into [TACCmd.Simple.AssumeCmd] commands.
     *
     * All [TACCmd.Simple.AssertCmd] commands that come after [assertToCheck]
     * (w.r.t. topological ordering given by [topoSortedAssertsWithMeta]), are transformed into NOP commands (thus effectively removed from [prog]).
     *
     * For normal asserts all satisfy commands (`assert false`, and `assume cond`) will be disabled.
     * In case this is for generating a satisfy assert, all previous satisfy assume commands are not disabled.
     *
     * @return The patched [prog] ([CoreTACProgram])
     */
    private fun generateTacForCheckingAssert(
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        assertToCheck: AssertCmdWithMeta,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        transIntoAssume: (AssertCmdWithMeta) -> Boolean
    ): CoreTACProgram {
        val patchingProg = optPatchingProgram ?: prog.toPatchingProgram()
        val removedAssertConds = mutableListOf<TACSymbol>()
        var assertToCheckOrd = 0
        for (assertCmdWithMeta in topoSortedAssertsWithMeta) {
            assertToCheckOrd++
            if (assertCmdWithMeta.assertLTACCmd == assertToCheck.assertLTACCmd) {
                break
            } else {
                // Replace prior asserts that satisfy [transIntoAssume], with assumes or nops
                if (transIntoAssume(assertCmdWithMeta)) {
                    // rules such as deepSanity need to check each "user defined" assert in isolation
                    // we check whether the meta contains "ISOLATED_ASSERT" to convert it to nop instead of assume
                    val replacement =
                        when (val cmd = assertCmdWithMeta.cmd) {
                            is TACCmd.Simple.AssertCmd -> {
                                removedAssertConds.add(cmd.o)
                                if (cmd.meta.containsKey(TACMeta.ISOLATED_ASSERT)) {
                                    TACCmd.Simple.NopCmd
                                } else {
                                    TACCmd.Simple.AssumeCmd(cmd.o)
                                }
                            }

                            else -> {
                                throw IllegalStateException(
                                    "Expected ${
                                        assertCmdWithMeta.assertLTACCmd
                                    } to be TACCmd.Simple.AssertCmd"
                                )
                            }
                        }

                    patchingProg.replaceCommand(
                        assertCmdWithMeta.ptr,
                        listOf(
                            replacement
                        )
                    )
                }
            }
        }
        for (idx in assertToCheckOrd until topoSortedAssertsWithMeta.size) {
            val lcmd = topoSortedAssertsWithMeta[idx]
            removedAssertConds.add((lcmd.cmd as TACCmd.Simple.AssertCmd).o)
            patchingProg.update(
                lcmd.ptr
            ) { TACCmd.Simple.NopCmd }
        }

        fixupAssertSnippetAnnotations(prog, patchingProg, removedAssertConds)

        return patchingProg.toCode(prog)
    }

    private fun relaxHashingBoundAsserts(
        prog: CoreTACProgram,
        patchingProg: SimplePatchingProgram,
        topoSortedHashingBoundAssertsWithMeta: List<AssertCmdWithMeta>
    ): CoreTACProgram {
        val removedAssertConds = mutableListOf<TACSymbol>()
        val txf = TACExprFactUntyped
        for (assertCmdWithMeta in topoSortedHashingBoundAssertsWithMeta) {
            val length = assertCmdWithMeta.cmd.meta.get(TACMeta.HASHING_BOUND_ASSERT)!!
            val maxBound = 1048576 // 2^20, guessed, hopefully large enough bound to enable the assume
            val relaxedAssume = TACCmd.Simple.AssumeExpCmd(
                txf {TACExpr.Sym.Var(length) le maxBound.asTACExpr},
                MetaMap(TACMeta.HASHING_BOUND_ASSUME to length)
            )

            removedAssertConds.add((assertCmdWithMeta.cmd as TACCmd.Simple.AssertCmd).o)
            patchingProg.replaceCommand(assertCmdWithMeta.ptr, listOf(relaxedAssume))
        }
        fixupAssertSnippetAnnotations(prog, patchingProg, removedAssertConds)
        return patchingProg.toCode(prog)
    }

    fun fixupAssertSnippetAnnotations(
        prog: CoreTACProgram,
        patchingProg: SimplePatchingProgram,
        removedAssertConds: List<TACSymbol>
    ) {
        /*
         * The [AssertSnippet]'s scoping enforcement is not correct anymore - some asserts were replaced with assumes or
         * nops. For all of these, we need to check if they were wrapped with [AssertSnippet] annotations and if so
         * remove those as well.
         */
        val graph = TACCommandGraph(prog)
        prog.parallelLtacStream()
            .filter {
                (it.maybeNarrow<TACCmd.Simple.AnnotationCmd>()?.cmd?.maybeAnnotation(TACMeta.SNIPPET) as? AssertSnippet<*>)?.assertCond in removedAssertConds
            }
            .map { it.narrow<TACCmd.Simple.AnnotationCmd>().ptr }
            .sequential()
            .forEach { startScopePtr ->
                val endScopePtr = graph.iterateBlock(startScopePtr).takeUntil {
                    it.maybeAnnotation(TACMeta.SCOPE_SNIPPET_END)
                }?.last()?.ptr ?: error("there should have been a scope-end annotation for the scope start at $startScopePtr")
                patchingProg.update(startScopePtr) { TACCmd.Simple.NopCmd }
                patchingProg.update(endScopePtr) { TACCmd.Simple.NopCmd }
            }
    }

    /**
     * Transforms all the user-defined [TACCmd.Simple.AssertCmd]
     * commands in [prog] that precede the last auto-generated assert command [lastAutoGenAssertWithMeta]
     * (w.r.t. topological ordering given by [topoSortedAssertsWithMeta]), into [TACCmd.Simple.AssumeCmd] commands.
     *
     * All (user-defined) [TACCmd.Simple.AssertCmd] commands that come after [lastAutoGenAssertWithMeta]
     * are transformed into NOP commands.
     *
     * @return The patched [prog]] ([CoreTACProgram])
     */
    private fun generateTacForCheckingAllAutoGenAsserts(
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        lastAutoGenAssertWithMeta: AssertCmdWithMeta,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
    ): CoreTACProgram = generateTacForCheckingAssert(
        prog,
        optPatchingProgram,
        lastAutoGenAssertWithMeta,
        topoSortedAssertsWithMeta,
    ) { assertWithMeta: AssertCmdWithMeta ->
        // Replace prior user-defined asserts with assumes; keep all auto-generated asserts in place
        assertWithMeta is AssertCmdWithMeta.UserDefined
    }

    /**
     * Transforms all [TACCmd.Simple.AssertCmd] commands in [prog],
     * that precede the user-defined assert command [userDefinedAssertToCheck]
     * (w.r.t. topological ordering given by [topoSortedAssertsWithMeta]), into [TACCmd.Simple.AssumeCmd] commands.
     *
     * All [TACCmd.Simple.AssertCmd] commands that come after [userDefinedAssertToCheck]
     * are transformed into NOP commands.
     *
     * @return The patched [prog]] ([CoreTACProgram])
     */
    internal fun generateTacForCheckingUserDefinedAssert(
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        userDefinedAssertToCheck: AssertCmdWithMeta,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
    ): CoreTACProgram =
        generateTacForCheckingAssert(
            prog,
            optPatchingProgram,
            userDefinedAssertToCheck,
            topoSortedAssertsWithMeta,
        ) { true }

    internal fun newMultiAssertSubRuleOf(
        origSubRule: CompiledRule,
        progWithTransformedAsserts: CoreTACProgram,
        multiAssertSubRuleDeclId: String,
        newRuleType: SpecType.Single,
        expectedSAT: Boolean,
        treeViewReporter: TreeViewReporter,
        range: Range
    ): CompiledRule {

        val newSingleRule = origSubRule.rule.copy(
            ruleType = newRuleType,
            ruleGenerationMeta = SingleRuleGenerationMeta.Empty,
            isSatisfyRule = expectedSAT,
            range = range,
            ruleIdentifier = origSubRule.rule.ruleIdentifier.freshDerivedIdentifier(multiAssertSubRuleDeclId)
        )

        StatusReporter.registerSubrule(newSingleRule)
        treeViewReporter.registerSubruleOf(newSingleRule, origSubRule.rule)


        return CompiledRule.create(
            newSingleRule,
            progWithTransformedAsserts.copy(
                name = newSingleRule.ruleIdentifier.toString()
            ),
            treeViewReporter.liveStatsReporter
        )
    }

    /**
     * Generates a [CompiledRule] subrule from [prog] to check all auto-generated asserts;
     * all user-defined asserts that precede the last auto-generated assert command ([lastAutoGenAssertWithMeta])
     * w.r.t. topological ordering given by [topoSortedAssertsWithMeta], become assume commands.
     * @param prog
     * @param topoSortedAssertsWithMeta a topologically sorted list of all [TACCmd.Simple.AssertCmd] commands in [prog]
     */
    internal fun generateSubRuleForLastAutoGeneratedAssert(
        origSubRule: CompiledRule,
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        lastAutoGenAssertWithMeta: AssertCmdWithMeta.AutoGenerated,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        treeViewReporter: TreeViewReporter
    ): CompiledRule {
        // Generate a new subrule that checks all auto-generated asserts
        val progWithTransformedAsserts = generateTacForCheckingAllAutoGenAsserts(
            prog,
            optPatchingProgram,
            lastAutoGenAssertWithMeta,
            topoSortedAssertsWithMeta,
        )

        return newMultiAssertSubRuleOf(
            origSubRule,
            progWithTransformedAsserts,
            "CheckAutoGeneratedAsserts",
            SpecType.Single.GeneratedFromBasicRule.MultiAssertSubRule.AutoGenerated(origSubRule.rule),
            false,
            treeViewReporter,
            Range.Empty()
        )
    }

    /**
     * Generates a [CompiledRule] from [prog] to check the given used-defined satsify command [satisfyToCheck].
     * All assert commands that precede [satisfyToCheck] w.r.t. topological ordering given by [topoSortedAssertsWithMeta], become assume commands.
     *
     * @param prog
     * @param topoSortedAssertsWithMeta a topologically sorted list of all [TACCmd.Simple.AssertCmd] commands in [prog]
     */
    internal fun generateSubRuleForSatisfy(
        origSubRule: CompiledRule,
        prog: CoreTACProgram,
        satisfyToCheck: AssertCmdWithMeta.UserDefined,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        satisfyCmds: Collection<CmdPointer>,
        treeViewReporter: TreeViewReporter
    ): CompiledRule {
        check(satisfyCmds.contains(satisfyToCheck.ptr)) {
            "Expecting subRule for satisfy to only be generated for satisfy commands" }
        // Get the satisfy commands unique identifier to identify the correct assume.
        val satisfyUUID = satisfyToCheck.cmd.meta[TACMeta.SATISFY_ID]
        check(satisfyUUID != null) {"Expecting each satisfy command to be marked by a unique " +
            "identifier at compilation"}
        val patchingProg = prog.toPatchingProgram()
        satisfyCmds
            .filterNot { it: CmdPointer ->
                val curCmd = prog.analysisCache.graph.elab(it).cmd
                // UUID catches both assert and assume
                curCmd.meta[TACMeta.SATISFY_ID] == satisfyUUID || ((!Config.IndependentSatisfies.get()) &&
                     curCmd is TACCmd.Simple.AssumeCmd &&
                        it.block in prog.analysisCache.reachability &&
                        prog.analysisCache.reachability[it.block]?.contains(satisfyToCheck.ptr.block) == true &&
                        (it.block != satisfyToCheck.ptr.block || it.pos < satisfyToCheck.ptr.pos))
            }
            .forEach { patchingProg.replaceCommand(it, listOf(TACCmd.Simple.NopCmd)) }

        return generateSubRuleForAssert(
            origSubRule,
            prog,
            patchingProg,
            satisfyToCheck,
            topoSortedAssertsWithMeta,
            msgPreamble = "Satisfy",
            isSatisfy = true,
            treeViewReporter = treeViewReporter,
        )
    }

    /**
     * Generates a [CompiledRule] from [prog] to check the given used-defined assert command [userDefinedAssertWithMeta].
     * All assert commands that precede [userDefinedAssertWithMeta] w.r.t. topological ordering given by [topoSortedAssertsWithMeta], become assume commands.
     *
     * @param prog
     * @param topoSortedAssertsWithMeta a topologically sorted list of all [TACCmd.Simple.AssertCmd] commands in [prog]
     */
    internal fun generateSubRuleForUserDefinedAssert(
        origSubRule: CompiledRule,
        prog: CoreTACProgram,
        patching: SimplePatchingProgram?,
        userDefinedAssertWithMeta: AssertCmdWithMeta.UserDefined,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        treeViewReporter: TreeViewReporter
    ): CompiledRule {
        return generateSubRuleForAssert(
            origSubRule,
            prog,
            patching,
            userDefinedAssertWithMeta,
            topoSortedAssertsWithMeta,
            msgPreamble = "Assert",
            isSatisfy = false,
            treeViewReporter,
        )
    }

    /**
     * Given a [hashingBoundAssert], this function generates a [CompiledRule] that contains only the [hashingBoundAssert].
     * All [otherHashingBoundAsserts] are turned into assumes with an increased hashing bound B (see below why),
     * and all the remaining regular [topoSortedAssertsWithMeta] are turned into assumes.
     *
     * The overall purpose of these subrules is to identify a suitable bound B for [Config.PreciseHashingLengthBound]
     * that would allow us to run the prover in the [Config.OptimisticUnboundedHashing] mode without being vacuous.
     * In particular, in the optimistic unbounded hashing mode, we assume that all arrays have a size lower than
     * the user-specified bound B, but if there are no such arrays possible, the rule gets vacuous. So, to get such B,
     * we first run the prover in the special [Config.HashingBoundDetectionMode] that uses the pessimistic hashing bounds,
     * i.e. generates asserts for each hashing bound, and we try to find a violation for each such assert, which
     * gives us a "real" array witness. We then take the maximum of these array sizes and suggest the user to use the
     * maximum as the bound B while setting the optimistic mode. While processing each individual hashing bound
     * assert A, we have to remove the hashing bound asserts that precede it (so that we do not get stuck on violating them).
     * However, if we would simply remove the asserts, we could get hashing collisions (due to our SMT modelling) that might
     * generate spurious traces. We also cannot simply turn the other hashing bound asserts to assumes because if the assumes
     * would be too restrictive (i.e. using too low bounds), the assert A would become unreachable. Hence, we
     * turn the other hashing bound asserts into assumes AND increase their hashing bounds to a large number
     * (and hope that these assumes will be feasiable and allow us to reach and violate the assert A).
     *
     * Note that we also try to minimize the sizes of the individual asserts in the CEXs within the model
     * prettification phase.
     *
     * Also, note that we generate the subrules (i.e. call [generateSubRuleForHashingBoundAssert] only for
     * the "last" hashing bound asserts, where a hashing assert HA is last iff there exist a path from HA to a user-defined
     * assert in [prog]. This is a performance improvement, because by "enabling" the arrays that correspond
     * to the last HAs, we enable also those arrays that precede the HAs.
     */
    internal fun generateSubRuleForHashingBoundAssert(
        origSubRule: CompiledRule,
        prog: CoreTACProgram,
        patching: SimplePatchingProgram,
        hashingBoundAssert: AssertCmdWithMeta,
        nonHashingBoundAsserts: List<AssertCmdWithMeta>,
        otherHashingBoundAsserts: List<AssertCmdWithMeta>,
        treeViewReporter: TreeViewReporter
    ): CompiledRule {
        val progWithTransformedAsserts = generateTacForCheckingUserDefinedAssert(
            prog,
            patching,
            hashingBoundAssert,
            nonHashingBoundAsserts
        ).let { p ->
            relaxHashingBoundAsserts(p, patching, otherHashingBoundAsserts)
        }

        val assertID = Allocator.getFreshId(Allocator.Id.ASSERTS)
        val newRuleDeclarationId = "hashing_bound_assert_$assertID"
        val range = Range.Empty()

        val newRuleType = SpecType.Single.GeneratedFromBasicRule.MultiAssertSubRule.HashingBoundCheck(
            originalRule = origSubRule.rule,
            assertId = assertID,
            assertMessage = hashingBoundAssert.assertMsg ?: "hashing bound assert $assertID"
        )

        return newMultiAssertSubRuleOf(
            origSubRule,
            progWithTransformedAsserts,
            newRuleDeclarationId,
            newRuleType,
            expectedSAT = false,
            treeViewReporter,
            range
        )
    }

    /**
     * Generates a [CompiledRule] from [prog] to check the given used-defined assert command [userDefinedAssertWithMeta].
     * All assert commands that precede [userDefinedAssertWithMeta] w.r.t. topological ordering given by [topoSortedAssertsWithMeta], become assume commands.
     *
     * @param prog
     * @param topoSortedAssertsWithMeta a topologically sorted list of all [TACCmd.Simple.AssertCmd] commands in [prog]
     */
    private fun generateSubRuleForAssert(
        origSubRule: CompiledRule,
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        userDefinedAssertWithMeta: AssertCmdWithMeta.UserDefined,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        msgPreamble: String,
        isSatisfy: Boolean,
        treeViewReporter: TreeViewReporter
    ): CompiledRule {
        // generate a new sub rule for current user-defined assert
        val progWithTransformedAsserts = generateTacForCheckingUserDefinedAssert(
            prog,
            optPatchingProgram,
            userDefinedAssertWithMeta,
            topoSortedAssertsWithMeta,
        )

        val newRuleDeclarationId = "${msgPreamble}_" +
            if (userDefinedAssertWithMeta.assertMsg.isNotEmpty()) {
                "${userDefinedAssertWithMeta.assertMsg.toRuleIdentifier()}_"
            } else {
                ""
            } +
            "(${userDefinedAssertWithMeta.assertLoc.toString().toRuleIdentifier()})"

        // set ruleType to [SpecType.Single.MultiAssertSubRule] for assert rules
        // so as to identify them when merging results
        val newRuleType = if (isSatisfy) {
            SpecType.Single.GeneratedFromBasicRule.MultiAssertSubRule.SatisfySpecFile(
                originalRule = origSubRule.rule,
                assertId = userDefinedAssertWithMeta.assertId,
                assertMessage = userDefinedAssertWithMeta.assertMsg,
                cvlCmdLoc = userDefinedAssertWithMeta.assertLoc
            )
        } else {
            SpecType.Single.GeneratedFromBasicRule.MultiAssertSubRule.AssertSpecFile(
                originalRule = origSubRule.rule,
                assertId = userDefinedAssertWithMeta.assertId,
                assertMessage = userDefinedAssertWithMeta.assertMsg,
                cvlCmdLoc = userDefinedAssertWithMeta.assertLoc
            )
        }

        return newMultiAssertSubRuleOf(
            origSubRule,
            progWithTransformedAsserts,
            newRuleDeclarationId,
            newRuleType,
            isSatisfy,
            treeViewReporter,
            userDefinedAssertWithMeta.assertLoc
        )
    }
}
