/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package rules

import allocator.Allocator
import analysis.*
import config.Config
import datastructures.stdcollections.*
import report.StatusReporter
import report.TreeViewReporter
import report.calltrace.toRuleIdentifier
import spec.cvlast.CVLRange
import spec.cvlast.SingleRuleGenerationMeta
import spec.cvlast.SpecType
import tac.NBId
import utils.takeUntil
import vc.data.*

object RuleSplitter {
    /**
     * An [TACCmd.Simple.AssertCmd] command with meta information
     * that is used for per-assert sub-rules generation.
     */
    internal sealed class AssertCmdWithMeta {

        companion object {

            /**
             * If [assertLTACCmd] is a user-defined assert command, allocates a fresh id that would be found
             * in the new [UserDefined] instance returned.
             */
            operator fun invoke(assertLTACCmd: LTACCmd): AssertCmdWithMeta {
                val assertCmd = assertLTACCmd.cmd
                require(assertCmd is TACCmd.Simple.AssertCmd) { "Expected $assertLTACCmd to be an assert command" }

                val rangeOfAssert =
                    assertCmd.meta.find(TACMeta.CVL_RANGE) ?: CVLRange.Empty()

                return if (TACMeta.CVL_USER_DEFINED_ASSERT in assertCmd.meta) {
                    UserDefined(assertLTACCmd, assertCmd.description, Allocator.getFreshId(Allocator.Id.ASSERTS), rangeOfAssert)
                } else {
                    AutoGenerated(assertLTACCmd, assertCmd.description)
                }
            }
        }

        abstract val assertLTACCmd: LTACCmd
        abstract val assertMsg: String?

        val cmd: TACCmd.Simple
            get() = assertLTACCmd.cmd

        val ptr: CmdPointer
            get() = assertLTACCmd.ptr

        /**
         * Represent an [TACCmd.Simple.AssertCmd] command
         * that is auto-generated by the tool.
         */
        internal data class AutoGenerated(override val assertLTACCmd: LTACCmd, override val assertMsg: String?) :
            AssertCmdWithMeta()

        /**
         * Represents an [TACCmd.Simple.AssertCmd] command
         * that is user-defined, i.e., an assert command that originates from an assert statement written in a spec file.
         *
         * @param assertLTACCmd the user-defined assert command
         * @param assertId the unique id allocated for [assertLTACCmd]
         * @param assertLoc the location of the user-defined assert statement in the spec file
         */
        internal data class UserDefined(
            override val assertLTACCmd: LTACCmd,
            override val assertMsg: String,
            val assertId: Int,
            val assertLoc: CVLRange
        ) :
            AssertCmdWithMeta()
    }

    /**
     * Returns a topologically sorted list of all [TACCmd.Simple.AssertCmd]
     * commands in [compiledRuleTacProg]. Each of these commands is encapsulated in an [AssertCmdWithMeta] instance.
     * Each [AssertCmdWithMeta.UserDefined] instance holds a new, fresh id ([AssertCmdWithMeta.UserDefined.assertId])
     * allocated for the underlying used-defined assert ([AssertCmdWithMeta.UserDefined.assertLTACCmd]).
     */
    internal fun getTopoSortedAssertsWithMeta(
        compiledRuleTacProg: CoreTACProgram
    ): List<AssertCmdWithMeta> {
        val topoSortedAssertsWithMeta = mutableListOf<AssertCmdWithMeta>()

        compiledRuleTacProg.topoSortFw.forEach { nbId: NBId ->
            compiledRuleTacProg.analysisCache.graph.elab(nbId).commands.forEach {
                if (it.cmd is TACCmd.Simple.AssertCmd) {
                    topoSortedAssertsWithMeta.add(AssertCmdWithMeta(it))
                }
            }
        }
        return topoSortedAssertsWithMeta
    }

    /**
     * Transforms all the [TACCmd.Simple.AssertCmd]
     * commands in [prog] that satisfy the predicate [transIntoAssume] and precede the assert command [assertToCheck]
     * (w.r.t. topological ordering given by [topoSortedAssertsWithMeta]), into [TACCmd.Simple.AssumeCmd] commands.
     *
     * All [TACCmd.Simple.AssertCmd] commands that come after [assertToCheck]
     * (w.r.t. topological ordering given by [topoSortedAssertsWithMeta]), are transformed into NOP commands (thus effectively removed from [prog]).
     *
     * For normal asserts all satisfy commands (`assert false`, and `assume cond`) will be disabled.
     * In case this is for generating a satisfy assert, all previous satisfy assume commands are not disabled.
     *
     * @return The patched [prog] ([CoreTACProgram])
     */
    private fun generateTacForCheckingAssert(
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        assertToCheck: AssertCmdWithMeta,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        transIntoAssume: (AssertCmdWithMeta) -> Boolean
    ): CoreTACProgram {
        val patchingProg = optPatchingProgram ?: prog.toPatchingProgram()
        val removedAssertConds = mutableListOf<TACSymbol>()
        var assertToCheckOrd = 0
        for (assertCmdWithMeta in topoSortedAssertsWithMeta) {
            assertToCheckOrd++
            if (assertCmdWithMeta.assertLTACCmd == assertToCheck.assertLTACCmd) {
                break
            } else {
                // Replace prior asserts that satisfy [transIntoAssume], with assumes or nops
                if (transIntoAssume(assertCmdWithMeta)) {
                    // rules such as deepSanity need to check each "user defined" assert in isolation
                    // we check whether the meta contains "ISOLATED_ASSERT" to convert it to nop instead of assume
                    val replacement =
                        when (val cmd = assertCmdWithMeta.cmd) {
                            is TACCmd.Simple.AssertCmd -> {
                                removedAssertConds.add(cmd.o)
                                if (cmd.meta.containsKey(TACMeta.ISOLATED_ASSERT)) {
                                    TACCmd.Simple.NopCmd
                                } else {
                                    TACCmd.Simple.AssumeCmd(cmd.o)
                                }
                            }

                            else -> {
                                throw IllegalStateException(
                                    "Expected ${
                                        assertCmdWithMeta.assertLTACCmd
                                    } to be TACCmd.Simple.AssertCmd"
                                )
                            }
                        }

                    patchingProg.replaceCommand(
                        assertCmdWithMeta.ptr,
                        listOf(
                            replacement
                        )
                    )
                }
            }
        }
        for (idx in assertToCheckOrd until topoSortedAssertsWithMeta.size) {
            val lcmd = topoSortedAssertsWithMeta[idx]
            removedAssertConds.add((lcmd.cmd as TACCmd.Simple.AssertCmd).o)
            patchingProg.update(
                lcmd.ptr
            ) { TACCmd.Simple.NopCmd }
        }

        fixupAssertSnippetAnnotations(prog, patchingProg, removedAssertConds)

        return patchingProg.toCode(prog)
    }

    fun fixupAssertSnippetAnnotations(
        prog: CoreTACProgram,
        patchingProg: SimplePatchingProgram,
        removedAssertConds: List<TACSymbol>
    ) {
        /*
         * The [AssertSnippet]'s scoping enforcement is not correct anymore - some asserts were replaced with assumes or
         * nops. For all of these, we need to check if they were wrapped with [AssertSnippet] annotations and if so
         * remove those as well.
         */
        val graph = TACCommandGraph(prog)
        prog.parallelLtacStream()
            .filter {
                (it.maybeNarrow<TACCmd.Simple.AnnotationCmd>()?.cmd?.maybeAnnotation(TACMeta.SNIPPET) as? AssertSnippet<*>)?.assertCond in removedAssertConds
            }
            .map { it.narrow<TACCmd.Simple.AnnotationCmd>().ptr }
            .sequential()
            .forEach { startScopePtr ->
                val endScopePtr = graph.iterateBlock(startScopePtr).takeUntil {
                    it.maybeAnnotation(TACMeta.SCOPE_SNIPPET_END)
                }?.last()?.ptr ?: error("there should have been a scope-end annotation for the scope start at $startScopePtr")
                patchingProg.update(startScopePtr) { TACCmd.Simple.NopCmd }
                patchingProg.update(endScopePtr) { TACCmd.Simple.NopCmd }
            }
    }

    /**
     * Transforms all the user-defined [TACCmd.Simple.AssertCmd]
     * commands in [prog] that precede the last auto-generated assert command [lastAutoGenAssertWithMeta]
     * (w.r.t. topological ordering given by [topoSortedAssertsWithMeta]), into [TACCmd.Simple.AssumeCmd] commands.
     *
     * All (user-defined) [TACCmd.Simple.AssertCmd] commands that come after [lastAutoGenAssertWithMeta]
     * are transformed into NOP commands.
     *
     * @return The patched [prog]] ([CoreTACProgram])
     */
    private fun generateTacForCheckingAllAutoGenAsserts(
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        lastAutoGenAssertWithMeta: AssertCmdWithMeta.AutoGenerated,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
    ): CoreTACProgram = generateTacForCheckingAssert(
        prog,
        optPatchingProgram,
        lastAutoGenAssertWithMeta,
        topoSortedAssertsWithMeta,
    ) { assertWithMeta: AssertCmdWithMeta ->
        // Replace prior user-defined asserts with assumes; keep all auto-generated asserts in place
        assertWithMeta is AssertCmdWithMeta.UserDefined
    }

    /**
     * Transforms all [TACCmd.Simple.AssertCmd] commands in [prog],
     * that precede the user-defined assert command [userDefinedAssertToCheck]
     * (w.r.t. topological ordering given by [topoSortedAssertsWithMeta]), into [TACCmd.Simple.AssumeCmd] commands.
     *
     * All [TACCmd.Simple.AssertCmd] commands that come after [userDefinedAssertToCheck]
     * are transformed into NOP commands.
     *
     * @return The patched [prog]] ([CoreTACProgram])
     */
    internal fun generateTacForCheckingUserDefinedAssert(
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        userDefinedAssertToCheck: AssertCmdWithMeta.UserDefined,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
    ): CoreTACProgram =
        generateTacForCheckingAssert(
            prog,
            optPatchingProgram,
            userDefinedAssertToCheck,
            topoSortedAssertsWithMeta,
        ) { true }

    internal fun newMultiAssertSubRuleOf(
        origSubRule: CompiledRule,
        progWithTransformedAsserts: CoreTACProgram,
        multiAssertSubRuleDeclId: String,
        newRuleType: SpecType.Single,
        expectedSAT: Boolean,
        treeViewReporter: TreeViewReporter,
        cvlRange: CVLRange
    ): CompiledRule {

        val newSingleRule = origSubRule.rule.copy(
            ruleType = newRuleType,
            ruleGenerationMeta = SingleRuleGenerationMeta.Empty,
            isSatisfyRule = expectedSAT,
            cvlRange = cvlRange,
            ruleIdentifier = origSubRule.rule.ruleIdentifier.freshDerivedIdentifier(multiAssertSubRuleDeclId)
        )

        StatusReporter.registerSubrule(newSingleRule)
        treeViewReporter.registerSubruleOf(newSingleRule, origSubRule.rule)


        return CompiledRule.create(
            newSingleRule,
            progWithTransformedAsserts.copy(
                name = newSingleRule.ruleIdentifier.toString()
            ),
            treeViewReporter.liveStatsReporter
        )
    }

    /**
     * Generates a [CompiledRule] subrule from [prog] to check all auto-generated asserts;
     * all user-defined asserts that precede the last auto-generated assert command ([lastAutoGenAssertWithMeta])
     * w.r.t. topological ordering given by [topoSortedAssertsWithMeta], become assume commands.
     * @param prog
     * @param topoSortedAssertsWithMeta a topologically sorted list of all [TACCmd.Simple.AssertCmd] commands in [prog]
     */
    internal fun generateSubRuleForLastAutoGeneratedAssert(
        origSubRule: CompiledRule,
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        lastAutoGenAssertWithMeta: AssertCmdWithMeta.AutoGenerated,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        treeViewReporter: TreeViewReporter
    ): CompiledRule {
        // Generate a new subrule that checks all auto-generated asserts
        val progWithTransformedAsserts = generateTacForCheckingAllAutoGenAsserts(
            prog,
            optPatchingProgram,
            lastAutoGenAssertWithMeta,
            topoSortedAssertsWithMeta,
        )

        return newMultiAssertSubRuleOf(
            origSubRule,
            progWithTransformedAsserts,
            "CheckAutoGeneratedAsserts",
            SpecType.Single.MultiAssertSubRule.AutoGenerated,
            false,
            treeViewReporter,
            CVLRange.Empty()
        )
    }

    /**
     * Generates a [CompiledRule] from [prog] to check the given used-defined satsify command [satisfyToCheck].
     * All assert commands that precede [satisfyToCheck] w.r.t. topological ordering given by [topoSortedAssertsWithMeta], become assume commands.
     *
     * @param prog
     * @param topoSortedAssertsWithMeta a topologically sorted list of all [TACCmd.Simple.AssertCmd] commands in [prog]
     */
    internal fun generateSubRuleForSatisfy(
        origSubRule: CompiledRule,
        prog: CoreTACProgram,
        satisfyToCheck: AssertCmdWithMeta.UserDefined,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        satisfyCmds: Collection<CmdPointer>,
        treeViewReporter: TreeViewReporter
    ): CompiledRule {
        check(satisfyCmds.contains(satisfyToCheck.ptr)) {
            "Expecting subRule for satisfy to only be generated for satisfy commands" }
        // Get the satisfy commands unique identifier to identify the correct assume.
        val satisfyUUID = satisfyToCheck.cmd.meta[TACMeta.SATISFY_ID]
        check(satisfyUUID != null) {"Expecting each satisfy command to be marked by a unique " +
            "identifier at compilation"}
        val patchingProg = prog.toPatchingProgram()
        satisfyCmds
            .filterNot { it: CmdPointer ->
                val curCmd = prog.analysisCache.graph.elab(it).cmd
                // UUID catches both assert and assume
                curCmd.meta[TACMeta.SATISFY_ID] == satisfyUUID || ((!Config.IndependentSatisfies.get()) &&
                     curCmd is TACCmd.Simple.AssumeCmd &&
                        it.block in prog.analysisCache.reachability &&
                        prog.analysisCache.reachability[it.block]?.contains(satisfyToCheck.ptr.block) == true &&
                        (it.block != satisfyToCheck.ptr.block || it.pos < satisfyToCheck.ptr.pos))
            }
            .forEach { patchingProg.replaceCommand(it, listOf(TACCmd.Simple.NopCmd)) }

        return generateSubRuleForAssert(
            origSubRule,
            prog,
            patchingProg,
            satisfyToCheck,
            topoSortedAssertsWithMeta,
            msgPreamble = "Satisfy",
            isSatisfy = true,
            treeViewReporter = treeViewReporter,
        )
    }

    /**
     * Generates a [CompiledRule] from [prog] to check the given used-defined assert command [userDefinedAssertWithMeta].
     * All assert commands that precede [userDefinedAssertWithMeta] w.r.t. topological ordering given by [topoSortedAssertsWithMeta], become assume commands.
     *
     * @param prog
     * @param topoSortedAssertsWithMeta a topologically sorted list of all [TACCmd.Simple.AssertCmd] commands in [prog]
     */
    internal fun generateSubRuleForUserDefinedAssert(
        origSubRule: CompiledRule,
        prog: CoreTACProgram,
        patching: SimplePatchingProgram?,
        userDefinedAssertWithMeta: AssertCmdWithMeta.UserDefined,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        treeViewReporter: TreeViewReporter
    ): CompiledRule {
        return generateSubRuleForAssert(
            origSubRule,
            prog,
            patching,
            userDefinedAssertWithMeta,
            topoSortedAssertsWithMeta,
            msgPreamble = "Assert",
            isSatisfy = false,
            treeViewReporter,
        )
    }

    /**
     * Generates a [CompiledRule] from [prog] to check the given used-defined assert command [userDefinedAssertWithMeta].
     * All assert commands that precede [userDefinedAssertWithMeta] w.r.t. topological ordering given by [topoSortedAssertsWithMeta], become assume commands.
     *
     * @param prog
     * @param topoSortedAssertsWithMeta a topologically sorted list of all [TACCmd.Simple.AssertCmd] commands in [prog]
     */
    private fun generateSubRuleForAssert(
        origSubRule: CompiledRule,
        prog: CoreTACProgram,
        optPatchingProgram: SimplePatchingProgram?,
        userDefinedAssertWithMeta: AssertCmdWithMeta.UserDefined,
        topoSortedAssertsWithMeta: List<AssertCmdWithMeta>,
        msgPreamble: String,
        isSatisfy: Boolean,
        treeViewReporter: TreeViewReporter
    ): CompiledRule {
        // generate a new sub rule for current user-defined assert
        val progWithTransformedAsserts = generateTacForCheckingUserDefinedAssert(
            prog,
            optPatchingProgram,
            userDefinedAssertWithMeta,
            topoSortedAssertsWithMeta,
        )

        val newRuleDeclarationId = "${msgPreamble}_" +
            if (userDefinedAssertWithMeta.assertMsg.isNotEmpty()) {
                "${userDefinedAssertWithMeta.assertMsg.toRuleIdentifier()}_"
            } else {
                ""
            } +
            "(${userDefinedAssertWithMeta.assertLoc.toString().toRuleIdentifier()})"

        // set ruleType to [SpecType.Single.MultiAssertSubRule] for assert rules
        // so as to identify them when merging results
        val newRuleType = if (isSatisfy) {
            SpecType.Single.MultiAssertSubRule.SatisfySpecFile(
                assertId = userDefinedAssertWithMeta.assertId,
                assertMessage = userDefinedAssertWithMeta.assertMsg,
                cvlCmdLoc = userDefinedAssertWithMeta.assertLoc
            )
        } else {
            SpecType.Single.MultiAssertSubRule.AssertSpecFile(
                assertId = userDefinedAssertWithMeta.assertId,
                assertMessage = userDefinedAssertWithMeta.assertMsg,
                cvlCmdLoc = userDefinedAssertWithMeta.assertLoc
            )
        }

        return newMultiAssertSubRuleOf(
            origSubRule,
            progWithTransformedAsserts,
            newRuleDeclarationId,
            newRuleType,
            isSatisfy,
            treeViewReporter,
            userDefinedAssertWithMeta.assertLoc
        )
    }
}
