/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package rules

import allocator.Allocator
import analysis.LTACCmd
import analysis.controlflow.InfeasiblePaths
import analysis.icfg.SummaryStack
import analysis.maybeAnnotation
import analysis.opt.*
import analysis.opt.inliner.GlobalInliner
import analysis.opt.intervals.IntervalsRewriter
import analysis.opt.overflow.OverflowPatternRewriter
import analysis.split.BoolOptimizer
import cache.CacheManager
import cache.VerifyingCacheManager
import cli.SanityValues
import config.Config
import config.OUTPUT_NAME_DELIMITER
import config.ReportTypes
import datastructures.NonEmptyList
import datastructures.stdcollections.*
import datastructures.toNonEmptyList
import diagnostics.inCode
import instrumentation.transformers.*
import kotlinx.coroutines.CancellationException
import kotlinx.serialization.SerializationException
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonObject
import log.*
import log.RuleTestArtifactKey.TestArtifactKind
import normalizer.NonCanonicalTranslationTable
import normalizer.canonicalDump
import optimizer.Pruner
import report.*
import report.callresolution.CallResolutionTable
import report.callresolution.CallResolutionTableBase
import report.calltrace.CallTrace
import rules.IsFromCache.*
import rules.RuleCheckResult.Single.RuleCheckInfo
import rules.RuleCheckResult.Single.RuleCheckInfo.WithExamplesData
import rules.sanity.generatedRulesForSpecChecks
import scene.IScene
import scene.ISceneIdentifiers
import scene.SceneIdentifiers
import scene.source.StandardCache
import smt.CoverageInfoEnum
import solver.SolverResult
import spec.CVL
import spec.CVLCompiler
import spec.cvlast.CVLSingleRule
import spec.cvlast.IRule
import spec.cvlast.SingleRuleGenerationMeta
import spec.cvlast.SpecType
import statistics.SDCollector
import statistics.SDCollectorFactory
import tac.DumpTime
import testing.TacPipelineDebuggers.oneStateInvariant
import utils.*
import vc.data.*
import vc.data.ParametricMethodInstantiatedCode.toCheckableTACs
import vc.data.SimplePatchingProgram.Companion.patchForEach
import vc.data.parser.serializeTAC
import vc.data.tacexprutil.QuantDefaultTACExprTransformer
import verifier.*
import java.io.IOException
import java.util.*
import java.util.stream.Collectors


private val logger = Logger(LoggerTypes.COMMON)

val json = Json { allowStructuredMapKeys = true; prettyPrint = true; serializersModule = CVLSerializerModules.modules}


/**
 * A [tac] object generated by the CVLCompiler, with extra metadata information:
 * - [methodParameterInstantiation] - mapping from method parameters to their instantiations in the TAC
 * - [sanity] sanity check status
 * - [subRule] - a modified rule describing what is being checked
 */
sealed interface ICheckableTAC {
    val tac: CoreTACProgram
    val methodParameterInstantiation: MethodParameterInstantiation
    val sanity: SingleRuleGenerationMeta.Sanity
    val subRule: CVLSingleRule

    operator fun component1() = tac
    operator fun component2() = methodParameterInstantiation
    operator fun component3() = sanity
    operator fun component4() = subRule
}

data class CheckableTAC(
    override val tac: CoreTACProgram,
    override val methodParameterInstantiation: MethodParameterInstantiation,
    override val sanity: SingleRuleGenerationMeta.Sanity,
    override val subRule: CVLSingleRule
) : ICheckableTAC

/**
 * [sanityChecks] a non-empty list of [CheckableTAC] of sanity rules.
 */
data class CheckableTACWithSanity(
    override val tac: CoreTACProgram,
    override val methodParameterInstantiation: MethodParameterInstantiation,
    override val sanity: SingleRuleGenerationMeta.Sanity,
    override val subRule: CVLSingleRule,
    val sanityChecks: NonEmptyList<CheckableTAC>
) : ICheckableTAC

fun ICheckableTAC.withSanity(sanityChecks: NonEmptyList<CheckableTAC>): CheckableTACWithSanity =
    CheckableTACWithSanity(
        this.tac,
        this.methodParameterInstantiation,
        this.sanity,
        this.subRule,
        sanityChecks
    )



/**
 * A single [CVLSingleRule] with its [CheckableTAC] ready to be checked by [AbstractTACChecker.runVerifier]
 **/
open class CompiledRule protected constructor(val rule: CVLSingleRule, val tac: CoreTACProgram, val liveStatsReporter: LiveStatsReporter) {

    data class CompileRuleCheckResult(
        val result: Result<ResultAndTime<Verifier.JoinedResult>>,
        val isOptimizedRuleFromCache: IsFromCache,
        val isSolverResultFromCache: IsFromCache,
        val stats: SDCollector = SDCollectorFactory.collector()
    ) {
        suspend fun toCheckResult(
            scene: ISceneIdentifiers,
            compiledRule: CompiledRule
        ): Result<RuleCheckResult.Single> = result.mapCatching { (res, time) ->
            // output HTML files
            res.reportOutput(compiledRule.rule)
            val isSolverResultFromCacheAlert = isSolverResultFromCache.toRuleAlertReportOrNull()
            val isEmptyCodeAlert = if (res.simpleSimpleSSATAC.isEmptyCode()) {
                // there may be other criteria which are more precise, e.g. no assert commands
                val recommendation = if (Config.DoSanityChecksForRules.get() == SanityValues.NONE) {
                    " It is recommended to run with `--rule_sanity basic`"
                } else {
                    ""
                }
                RuleAlertReport.Info(msg = "Rule was successfully verified without running SMT solver. (All asserts were optimized away by static analysis.)$recommendation")
            } else {
                null
            }
            val alerts = RuleAlertReport(listOfNotNull(isSolverResultFromCacheAlert, isEmptyCodeAlert))
            if (!Config.CoinbaseFeaturesMode.get()) {
                generateSingleResult(scene, compiledRule.rule, res, time, isOptimizedRuleFromCache, isSolverResultFromCache, alerts)
            } else {
                val details = (res as? Verifier.JoinedResult.Success)?.details().orEmpty()
                val dumpGraphLink = RuleCheckInfo.basicDumpGraphLinkOf(compiledRule.rule)
                RuleCheckResult.Single.Basic(
                    rule = compiledRule.rule,
                    ruleCheckInfo = RuleCheckInfo.BasicInfo(
                        details = Result.success(details),
                        dumpGraphLink = dumpGraphLink,
                        isOptimizedRuleFromCache = this.isOptimizedRuleFromCache,
                        isSolverResultFromCache = this.isSolverResultFromCache,
                    ),
                    result = res.finalResult,
                    verifyTime = time,
                    ruleAlerts = alerts,
                    callResolutionTable = CallResolutionTableBase.Empty
                )
            }
        }

        companion object {
            /**
             * Lifts this [IsFromCache] to a [RuleAlertReport.Info] instance whose message ([RuleAlertReport.Info.msg])
             * reports whether there was a cache-hit. Returns null if there is nothing to report.
             */
            private fun IsFromCache.toRuleAlertReportOrNull(): RuleAlertReport.Info? = when (this) {
                HIT -> {
                    RuleAlertReport.Info(msg = "Rule verification result fetched from cache.")
                }

                else -> {
                    null
                }
            }
        }
    }

    protected fun dumpPreOptimize() {
        // output to a file
        oneStateInvariant(tac, ReportTypes.PREOPTIMIZED_RULE)
        ArtifactManagerFactory().dumpMandatoryCodeArtifacts(
            tac,
            ReportTypes.PREOPTIMIZED_RULE,
            StaticArtifactLocation.Outputs,
            DumpTime.AGNOSTIC
        )
        if (Config.VerifyTACDumps.get()) {
            synchronized(ArtifactManagerFactory) {
                ArtifactManagerFactory().dumpBinary(
                    tac,
                    StaticArtifactLocation.Outputs,
                    "preoptimized"
                )
            }
        }
    }

    protected fun dumpPostOptimized(tacToCheck: CoreTACProgram) {
        /**
         *  Two threads may concurrently dump `tacToCheck`s that share the same name,
         *  (while effectively being distinct [CoreTACProgram]s); as a result, without the lock below,
         *  they may write and/or read to/from the same file concurrently.
         */
        synchronized(ArtifactManagerFactory) {
            if (Config.VerifyTACDumps.get()) {
                val tacBinFile = ArtifactManagerFactory().dumpBinary(
                    tacToCheck,
                    StaticArtifactLocation.Outputs,
                    ""
                )
                if (tacBinFile == null && Config.AvoidAnyOutput.get()) {
                    throw IllegalStateException(
                        "Cannot run with ${Config.AvoidAnyOutput.option.opt} " +
                            "and ${Config.VerifyTACDumps.option.opt} together"
                    )
                }
                CoreTACProgram.readBinary(tacBinFile?.parseableFile ?: error("Failed to get binary dump"))
            }
        }
    }

    @Suppress("SuspendFunSwallowedCancellation") // mapCheckResult deals with CancellationException
    open suspend fun check(scene: SceneIdentifiers): CompileRuleCheckResult = runCatching {
        logger.info { "Checking compiled rule ${rule.declarationId}" }
        /**
         * NOTE: At this point, we assume that summaries and ghost hooks have already been handled.
         * */
        dumpPreOptimize()
        val tacToCheck = optimize(scene, tac).also(::dumpPostOptimized)

        /**
         * It is easier to read the TAC Coverage Info visualisation if we do not canonicalize the (spec) variable names.
         * Also, note that the canonicalization is used mainly to make the computation more stable during repeated runs,
         * and to allow to take the rule results from the cache if available. However, with advanced coverage info,
         * we disable many TAC optimisations and hence get another TAC anyway.
         */
        val canonicalTacToCheck = if (Config.CanonicalizeTAC.get() && Config.CoverageInfoMode.get() != CoverageInfoEnum.ADVANCED) {
            tacToCheck.toCanonical()
        } else {
            tacToCheck
        }

        val startTime = System.currentTimeMillis()
        val joinedResult = verify(scene, canonicalTacToCheck)
        val endTime = System.currentTimeMillis()
        val res = ResultAndTime(joinedResult, VerifyTime.WithInterval(startTime, endTime))
        res
    }.mapCheckResult(
        isOptimizedRuleFromCache =
        if (!Config.getIsUseCache()) {
            DISABLED
        } else {
            MISS
        },
        isSolverResultFromCache = if (!Config.getIsUseCache()) {
            DISABLED
        } else {
            MISS

        }
    )

    protected fun Result<ResultAndTime<Verifier.JoinedResult>>.
        mapCheckResult(isOptimizedRuleFromCache: IsFromCache, isSolverResultFromCache: IsFromCache): CompileRuleCheckResult =
        fold(onSuccess = { result ->
            CompileRuleCheckResult(
                Result.success(result),
                isOptimizedRuleFromCache = isOptimizedRuleFromCache,
                isSolverResultFromCache = isSolverResultFromCache
            )
        }) {
            if (it is CancellationException) {
                throw it
            }
            val ruleName = listOfNotNull(
                rule.parentIdentifier,
                rule.declarationId
            ).joinToString(separator = OUTPUT_NAME_DELIMITER)
            logger.error(it) { "Had an exception while getting object to verify for rule $ruleName, $it" }
            val named = CertoraException.fromExceptionWithRuleName(it, ruleName)
            CompileRuleCheckResult(Result.failure(named), isOptimizedRuleFromCache = isOptimizedRuleFromCache, isSolverResultFromCache = isSolverResultFromCache)
        }

    protected open suspend fun verify(
        scene: SceneIdentifiers,
        tacToCheck: CoreTACProgram
    ) = Verifier.JoinedResult(TACVerifier.verify(scene, tacToCheck, liveStatsReporter, rule))


    protected open suspend fun optimize(scene: SceneIdentifiers, tacToCheck: CoreTACProgram) =
        CompiledRule.optimize(scene, tacToCheck)


    companion object {
        /**
         * should not be called directly from the outside, but rather from a class method like here or [CachingCompiledRule].
         */
        fun optimize(scene: SceneIdentifiers, tacToCheck: CoreTACProgram) = inCode(tacToCheck) {
            CoreTACProgram.Linear(tacToCheck)
            .mapIfAllowed(CoreToCoreTransformer(ReportTypes.SNIPPET_REMOVAL) { c ->
                SnippetRemover.rewrite(c)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.PROPAGATOR_SIMPLIFIER) {
                ConstantPropagatorAndSimplifier(it).rewrite()
                    .let(BlockMerger::mergeBlocks)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.OPTIMIZE_DIAMONDS) {
                // we don't fold diamonds with assumes in them, because it creates assumes with disjunctions, and
                // `IntervalsCalculator` can't work well with those.
                simplifyDiamonds(it, iterative = false, allowAssumes = false)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.OPTIMIZE_BOOL_VARIABLES) {
                // this should actually happen much earlier in the pipeline (there is some mismatch between the tag
                // from cvl and the new bool tag?
                BoolOptimizer(it).go()
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.ASSUME_STRICT_MONOTONIC_FP) { c ->
                FPMonotonicityInstrumenter.assumeStrictlyMonotonicFP(c)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.MATERIALIZE_DISJOINT_HASHES) { c ->
                DisjointHashesMaterializer.materializeDisjointHashes(scene, c)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.OPTIMIZE_PROPAGATE_CONSTANTS1) { code ->
                ConstantPropagator.propagateConstants(code, emptySet()).let {
                    BlockMerger.mergeBlocks(it)
                }
            })
            .mapIfAllowed(
                CoreToCoreTransformer(
                    ReportTypes.REMOVE_CALL_ANNOTATIONS
                ) { it ->
                    if (it.destructiveOptimizations) {
                        it.parallelLtacStream().filter {
                            it.maybeAnnotation(SummaryStack.END_EXTERNAL_SUMMARY) != null ||
                                it.maybeAnnotation(SummaryStack.START_EXTERNAL_SUMMARY) != null ||
                                it.maybeAnnotation(SummaryStack.START_INTERNAL_SUMMARY) != null ||
                                it.maybeAnnotation(SummaryStack.END_INTERNAL_SUMMARY) != null

                        }.patchForEach(it) {
                            replaceCommand(it.ptr, listOf(TACCmd.Simple.NopCmd))
                        }
                    } else {
                        it
                    }
                }
            )
            .mapIfAllowed(
                CoreToCoreTransformer(
                    ReportTypes.REMOVE_UNUSED_WRITES,
                    SimpleMemoryOptimizer::removeUnusedWrites
                )
            )
            .mapIfAllowed(
                CoreToCoreTransformer(
                    ReportTypes.REWRITE_COPY_LOOP,
                    SimpleMemoryOptimizer::rewriteCopyLoops
                )
            )
            .mapIfAllowed(
                CoreToCoreTransformer(
                    ReportTypes.REMOVE_UNUSED_PARTITIONS,
                    SimpleMemoryOptimizer::removeDeadPartitions
                )
            )
            .mapIfAllowed(CoreToCoreTransformer(ReportTypes.UNUSED_ASSIGNMENTS) { c ->
                optimizeAssignments(c, FilteringFunctions.default(c, keepRevertManagment = true))
                    .let(BlockMerger::mergeBlocks)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.PATH_OPTIMIZE1) { c ->
                Pruner(c).prune()
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.OPTIMIZE_INFEASIBLE_PATHS) { c ->
                InfeasiblePaths.doInfeasibleBranchAnalysisAndPruning(c)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.SIMPLE_SUMMARIES1) {
                it.simpleSummaries()
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.PROPAGATOR_SIMPLIFIER) {
                ConstantPropagatorAndSimplifier(it).rewrite()
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.NEGATION_NORMALIZER) {
                NegationNormalizer(it).rewrite()
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.PATTERN_REWRITER) { c ->
                PatternRewriter.rewrite(c, PatternRewriter::earlyPatternsList)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.NEGATION_NORMALIZER) {
                    NegationNormalizer(it).rewrite()
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.GLOBAL_INLINER) {
                GlobalInliner.inlineAll(it)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.PROPAGATOR_SIMPLIFIER) {
                ConstantPropagatorAndSimplifier(it).rewrite().let(BlockMerger::mergeBlocks)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.UNUSED_ASSIGNMENTS) {
                optimizeAssignments(it, FilteringFunctions.default(it, keepRevertManagment = true))
                    .let(BlockMerger::mergeBlocks)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.OPTIMIZE_OVERFLOW) {
                OverflowPatternRewriter(it).go()
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.PATTERN_REWRITER) { c ->
                PatternRewriter.rewrite(c, PatternRewriter::basicPatternsList)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.GLOBAL_INLINER) {
                GlobalInliner.inlineAll(it)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.TERNARY_OPTIMIZE) {
                TernarySimplifier.simplify(it, afterSummarization = true, forbiddenVars = emptySet())
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.INTERVALS_OPTIMIZE) {
                IntervalsRewriter.rewrite(it, handleLeinoVars = false)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.OPTIMIZE_DIAMONDS) {
                simplifyDiamonds(it, iterative = false)
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.OPTIMIZE_PROPAGATE_CONSTANTS2) { code ->
                // after pruning infeasible paths, there are more constants to propagate
                ConstantPropagator.propagateConstants(code, emptySet())
            }).mapIfAllowed(CoreToCoreTransformer(ReportTypes.PATH_OPTIMIZE2) { code ->
                Pruner(code).prune()
            }).mapIfAllowed(
                CoreToCoreTransformer(
                    ReportTypes.OPTIMIZE_MERGE_BLOCKS,
                    BlockMerger::mergeBlocks
                )
            ).mapIfAllowed(CoreToCoreTransformer(ReportTypes.QUANTIFIER_POLARITY) { code ->
                QuantifierAnnotator(code).annotate()
            }).ref
        }

        /**
         * Create a new CompiledRule object
         */
        fun create(rule: CVLSingleRule, codeToCheck: CoreTACProgram, liveStatsReporter: LiveStatsReporter): CompiledRule {
            return if (Config.getIsUseCache() && Config.UsePerRuleCache.get()) {
                val baseCache = Base64.getUrlEncoder().withoutPadding()
                    .encodeToString(StandardCache.baseCacheKeyForRuleLevelCache)
                val (tac, backTranslation) = NonCanonicalTranslationTable(codeToCheck, logger)
                val manager = CacheManager(Config.CacheDirName.get())
                CachingCompiledRule(rule, tac, baseCache, backTranslation, manager, liveStatsReporter)
            } else if (Config.VerifyCache.get()) {
                val baseCache = Base64.getUrlEncoder().withoutPadding()
                    .encodeToString(StandardCache.baseCacheKeyForRuleLevelCache)
                val (tac, backTranslation) = NonCanonicalTranslationTable(codeToCheck, logger)
                CachingCompiledRule(rule, tac, baseCache, backTranslation, VerifyingCacheManager, liveStatsReporter)
            } else {
                CompiledRule(rule, codeToCheck, liveStatsReporter)
            }
        }

        /**
         * Adds [TACMeta.ASSERT_ID] meta to all [TACCmd.Simple.AssertCmd] commands in [ compiledRuleTacProg].
         *
         * @param compiledRuleTacProg
         * @return The modified [CoreTACProgram]
         */
        fun addAssertIDMetaToAsserts(
            compiledRuleTacProg: CoreTACProgram,
            rule: IRule
        ): CoreTACProgram {
            val assertCmds: Set<LTACCmd> =
                compiledRuleTacProg.parallelLtacStream().filter { it.cmd is TACCmd.Simple.AssertCmd }
                    .collect(Collectors.toSet())

            val patchingProg = compiledRuleTacProg.toPatchingProgram()
            when (val ruleType = rule.ruleType) {
                is SpecType.Single.MultiAssertSubRule.SpecFile -> {
                    // We have a multi-assert subrule that was generated for a single user-defined assert command.
                    // It may be that this only assert command has been removed at a later stage by some transformation,
                    // so we expected to find at most one assert command in the compiled rule.
                    if (assertCmds.size > 1) {
                        throw IllegalStateException(
                            "Expected the multi-assert, compiled subrule ${
                                rule.declarationId
                            } to have at most one user-defined assert command, but found the asserts $assertCmds"
                        )
                    }
                    assertCmds.firstOrNull()?.let { userDefAssertLtac: LTACCmd ->
                        // Take the assertId that was allocated for this assert command when the rule was generated
                        patchingProg.update(userDefAssertLtac.ptr) {
                            userDefAssertLtac.cmd.plusMeta(TACMeta.ASSERT_ID, ruleType.assertId)
                        }
                    }
                }

                else -> {
                    // We have either a multi-assert subrule generated for (possibly multiple) auto-generated assert commands,
                    // or a rule for which multi-assert splitting was not performed, e.g., a rule-sanity check rule.
                    if (ruleType == SpecType.Single.MultiAssertSubRule.AutoGenerated) {
                        // Check that all asserts are indeed auto-generated (i.e., not originating from a spec file)
                        val userDefinedAsserts = assertCmds.filter { TACMeta.CVL_USER_DEFINED_ASSERT in it.cmd.meta }
                        if (userDefinedAsserts.isNotEmpty()) {
                            throw IllegalStateException(
                                "In the multi-assert, compiled subrule ${
                                    rule.declarationId
                                }, did not expect to find assert commands with CVL_USERDEFINED_ASSERT meta keys " +
                                    "(found $userDefinedAsserts)"
                            )
                        }
                    }
                    // Assign a fresh id for each assert and make it the value of the ASSERT_ID meta key
                    assertCmds.forEach { assertLtac: LTACCmd ->
                        patchingProg.update(assertLtac.ptr) {
                            assertLtac.cmd.plusMeta(TACMeta.ASSERT_ID, Allocator.getFreshId(Allocator.Id.ASSERTS))
                        }
                    }
                }
            }
            return patchingProg.toCode(compiledRuleTacProg)
        }

        fun staticRules(
            _scene: IScene,
            _cvl: CVL,
            _rule: CVLSingleRule,
        ): Result<List<ICheckableTAC>> = digestCheck {
            logger.info { "Compiling rule ${_rule.declarationId}" }
            val sanity = if (Config.DoSanityChecksForRules.get() != SanityValues.NONE) {
                SingleRuleGenerationMeta.Sanity.PRE_SANITY_CHECK
            } else {
                SingleRuleGenerationMeta.Sanity.DISABLED_SANITY_CHECK
            }
            val c = CVLCompiler(_scene, _cvl, _rule.declarationId)
            c.compileRule(
                _rule,
                c.CVLBasedFilter(_rule.ruleIdentifier)
            )
                .toCheckableTACs(_scene, sanity, _rule)
        }.transformError(_rule)

        /**
         * Generates the sanity-check sub-rules for the given [_rule].
         * Note that to avoid needless work, this function should only be called if we know [CVLCompiler.compileRule] to
         * return a non-empty [ParametricInstantiation] for [_rule].
         */
        private fun compileSanityCheckSubRules(
            _scene: IScene,
            _cvl: CVL,
            _rule: CVLSingleRule,
            baseRulesCheckableTACs: List<ICheckableTAC>
        ): Result<List<ICheckableTAC>> {
            val ruleTypeCheck = when (_rule.ruleType) {
                is SpecType.Single.InvariantCheck.GenericPreservedInductionStep, is SpecType.Single.InvariantCheck.ExplicitPreservedInductionStep -> true
                is SpecType.Single.InvariantCheck, is SpecType.Single.EnvFree -> false
                is SpecType.Single.BuiltIn -> false
                else -> true
            }

            // those are the only rules we want to sanity-check, given that the sanity mode is enabled
            // We also don't run sanity on satisfy-rules (i.e. ones where expected results is SAT)
            val sanityRules = if (ruleTypeCheck && !_rule.isSatisfyRule) {
                generatedRulesForSpecChecks(_rule)
            } else {
                emptyList()
            }
            val iCheckableTACs = if (sanityRules.isEmpty()) {
                // no sanity rules, simply return [baseRulesCheckableTACs]
                baseRulesCheckableTACs
            } else {
                baseRulesCheckableTACs.map { baseRuleCheckableTAC ->
                    val checkableTACsForSanity = sanityRules.flatMap { sanityRule ->
                        // we need to re-construct CVLCompiler because of some weird assertion about lastStorageVar already being in storageVarFamilies
                        val c = CVLCompiler(_scene, _cvl, _rule.declarationId)
                        c.compileRule(
                            sanityRule,
                            CVLCompiler.InstantiationBasedFilter(baseRuleCheckableTAC.methodParameterInstantiation)
                        )
                            .toCheckableTACs(
                                _scene,
                                SingleRuleGenerationMeta.Sanity.BASIC_SANITY,
                                sanityRule
                            )
                    }
                    baseRuleCheckableTAC.withSanity(
                        checkableTACsForSanity.toNonEmptyList() ?: return@compileSanityCheckSubRules Result.failure(
                            IllegalStateException("[checkableTACsForSanity] should not be empty")
                        )
                    )
                }
            }
            return digestCheck {
                iCheckableTACs
            }.transformError(_rule)
        }


        private fun digestCheck(compile: () -> List<ICheckableTAC>): Result<List<ICheckableTAC>> =
            runCatching(compile).onSuccess {
                fun <T : TACCmd.Spec, TAC> dump(tac: TAC, suffix: String)
                    where
                    TAC : TACProgram<T>,
                    TAC : InstrumentedTAC,
                    TAC : IProcedural {
                    tac.canonicalDump(suffix) { canonicalTac ->
                        ArtifactManagerFactory().dumpMandatoryCodeArtifacts(
                            canonicalTac,
                            ReportTypes.ERROR,
                            StaticArtifactLocation.Reports,
                            DumpTime.AGNOSTIC
                        )
                    }
                }
                fun hasMoreThan1QuantVars(tac: CoreTACProgram): Boolean {
                    val quantFinder = object : QuantDefaultTACExprTransformer() {
                        var hasQuantExprWithMoreThan1Var = false
                        override fun transformQuantifiedFormula(acc: QuantVars, exp: TACExpr.QuantifiedFormula): TACExpr {
                            super.transform(acc, exp.body)
                            return exp.also {
                                if (it.quantifiedVars.size > 1) {
                                    hasQuantExprWithMoreThan1Var = true
                                }
                            }
                        }
                    }
                    val mapper =  object : DefaultTACCmdSpecMapper() {
                        override val exprMapper: QuantDefaultTACExprTransformer = quantFinder
                    }
                    return tac.analysisCache.graph.commands.any {
                        mapper.map(it.cmd)
                        // short circuit if the transformer encountered a quantified expression with more than 1 bound variable
                        quantFinder.hasQuantExprWithMoreThan1Var
                    }
                }
                if (Config.CheckRuleDigest.get()) {
                    val bit = compile()
                    check(it.size == bit.size) {
                        "compiling the same rule twice resulted in two different size lists $it vs $bit"
                    }
                    for ((a, b) in it.zip(bit)) {
                        // if the program contains quantified expression with > 1 variable, let's skip the check
                        if (hasMoreThan1QuantVars(a.tac)) {
                            continue
                        }
                        val aDigest = a.tac.digest()
                        val bDigest = b.tac.digest()
                        if (aDigest != bDigest) {

                            // let's dump the TACs
                            dump(a.tac, "a")

                            dump(b.tac, "b")
                            error("rule ${a.tac.name} digest $aDigest != rule ${b.tac.name} digest $bDigest")
                        }
                    }
                }
            }

        fun subRules(
            _scene: IScene,
            _cvl: CVL,
            _rule: CVLSingleRule,
        ): Result<List<ICheckableTAC>> = staticRules(
            _scene,
            _cvl,
            _rule
        ).mapCatching { baseRulesCheckableTACs ->
            if (baseRulesCheckableTACs.isNotEmpty()) {
                compileSanityCheckSubRules(_scene, _cvl, _rule, baseRulesCheckableTACs).getOrThrow()
            } else {
                // No need to generate subrules if no rules were instantiated.
                emptyList()
            }
        }


        /**
         * Generates a single-result for the rule [rule] with the result [SolverResult], based on [vResult]
         * which took to verify in [verifyTime].
         */
        suspend fun generateSingleResult(
            scene: ISceneIdentifiers,
            rule: IRule,
            vResult: Verifier.JoinedResult,
            verifyTime: VerifyTime,
            isOptimizedRuleFromCache: IsFromCache,
            isSolverResultFromCache: IsFromCache,
            ruleAlerts: RuleAlertReport<RuleAlertReport.Info>?,
        ): RuleCheckResult.Single {
            val origProgWithAssertIdMeta = addAssertIDMetaToAsserts(vResult.simpleSimpleSSATAC, rule)
            val callResolutionTableFactory = CallResolutionTable.Factory(origProgWithAssertIdMeta, scene, rule)
            val unsatCoreDumpLinkAndStats = if (vResult.unsatCoreSplitsData?.isNotEmpty() == true) {
                RuleCheckInfo.BasicInfo.computeAndDumpUnsatCoreCodeMap(rule, vResult.unsatCoreSplitsData!!, vResult.simpleSimpleSSATAC)
            } else {
                null
            }

            return when (vResult) {
                is Verifier.JoinedResult.Failure -> {
                    try {
                        val ruleCheckInfo = WithExamplesData(
                            scene,
                            rule,
                            vResult,
                            origProgWithAssertIdMeta,
                            callResolutionTableFactory,
                            isOptimizedRuleFromCache = isOptimizedRuleFromCache,
                            isSolverResultFromCache = isSolverResultFromCache
                        )

                        if (Config.SaveVerifierResults.get()) {
                            // Save failure result and dump test artifacts
                            saveFailureResult(vResult, rule, ruleCheckInfo)
                        }
                        val callResolutionTable = callResolutionTableFactory.tableWithExampleMeta()

                        RuleCheckResult.Single.WithCounterExamples(
                            rule,
                            callResolutionTable = callResolutionTable,
                            ruleCheckInfo = ruleCheckInfo,
                            verifyTime = verifyTime,
                            result = vResult.finalResult,
                            ruleAlerts = ruleAlerts
                        )
                    } catch (e: CancellationException) {
                        // do not interfere with the coroutine cancellation mechanism
                        throw e
                    } catch (@Suppress("TooGenericExceptionCaught") e: Exception) {
                        logger.warn(e) {
                            "WithExamplesData generation ended prematurely due to unexpected exception " +
                                "(rule ${rule.ruleIdentifier.displayName})"
                        }
                        // nb, once we have the capability, this should go to Rule Notifications rather than Global;
                        // I'm not pushing this through `ruleAlerts` now because we're switching that infra out soon ..
                        CVTAlertReporter.reportAlert(
                            CVTAlertType.DIAGNOSABILITY,
                            CVTAlertSeverity.WARNING,
                            jumpToDefinition = null,
                            message = "Call trace generation failed for rule \"${rule.ruleIdentifier}\". " +
                                "Showing an empty Call Trace.",
                            hint = null
                        )
                        val ruleCheckInfo = RuleCheckInfo.BasicInfo(
                            rule,
                            vResult,
                            isOptimizedRuleFromCache = isOptimizedRuleFromCache,
                            isSolverResultFromCache = isSolverResultFromCache,
                            dumpGraphLink = unsatCoreDumpLinkAndStats?.htmlDumpPath
                        )
                        val callResolutionTable = callResolutionTableFactory.tableBase()
                        RuleCheckResult.Single.Basic(
                            rule,
                            callResolutionTable = callResolutionTable,
                            ruleCheckInfo = ruleCheckInfo,
                            verifyTime = verifyTime,
                            result = vResult.finalResult,
                            ruleAlerts = ruleAlerts
                        )
                    }

                }

                is Verifier.JoinedResult.Success,
                is Verifier.JoinedResult.SanityFail -> {
                    val ruleCheckInfo = RuleCheckInfo.BasicInfo(
                        rule,
                        vResult,
                        isOptimizedRuleFromCache = isOptimizedRuleFromCache,
                        isSolverResultFromCache = isSolverResultFromCache,
                        dumpGraphLink = unsatCoreDumpLinkAndStats?.htmlDumpPath
                    )
                    RuleCheckResult.Single.Basic(
                        rule = rule,
                        ruleCheckInfo = ruleCheckInfo,
                        callResolutionTable = callResolutionTableFactory.tableBase(),
                        verifyTime = verifyTime,
                        result = vResult.finalResult,
                        ruleAlerts = ruleAlerts,
                        unsatCoreStats = unsatCoreDumpLinkAndStats?.unsatCoreStats,
                    )
                }

                is Verifier.JoinedResult.Timeout,
                is Verifier.JoinedResult.Unknown -> {
                    val ruleCheckInfo =
                        if (vResult.unsolvedSplitsData == null) {
                            RuleCheckInfo.BasicInfo(rule, vResult, isOptimizedRuleFromCache = isOptimizedRuleFromCache, isSolverResultFromCache = isSolverResultFromCache)
                        } else {
                            RuleCheckInfo.BasicInfo.dumpUnsolvedSplits(rule, vResult, isOptimizedRuleFromCache = isOptimizedRuleFromCache, isSolverResultFromCache = isSolverResultFromCache)
                        }
                    RuleCheckResult.Single.Basic(
                        rule = rule,
                        ruleCheckInfo = ruleCheckInfo,
                        callResolutionTable = callResolutionTableFactory.tableBase(),
                        verifyTime = verifyTime,
                        result = vResult.finalResult,
                        ruleAlerts = ruleAlerts,
                        unsatCoreStats = unsatCoreDumpLinkAndStats?.unsatCoreStats
                    )
                }
            }
        }

        /**
         * Saves the failure result of a 'sat' rule by registering and utilizing artifacts
         * associated with the rule.
         *
         * @param failResult The failure result containing information about the 'sat' rule.
         * @param rule The rule that was tested.
         * @param examplesData The WithExamplesData containing counter-examples information.
         */
        private fun saveFailureResult(
            failResult: Verifier.JoinedResult.Failure,
            rule: IRule,
            examplesData: WithExamplesData
        ) {
            try {
                // save examplesInfo using json serializer
                val exampleInfoArtifact = RuleTestArtifactKey(rule, TestArtifactKind.EXAMPLES_INFO)
                json.dumpTestArtifact(exampleInfoArtifact, failResult.examplesInfo)

                // Define coreTACArtifact for the given rule.
                val coreTACArtifact = RuleTestArtifactKey(rule, TestArtifactKind.CORE_TAC_PROGRAM)

                // Register the coreTACArtifact with the ArtifactManagerFactory.
                ArtifactManagerFactory().registerRuleTestArtifact(coreTACArtifact)

                // Serialize and save the TAC information associated with the failure result.
                ArtifactManagerFactory().useArtifact(coreTACArtifact) { artifact ->
                    serializeTAC(failResult.simpleSimpleSSATAC, artifact)
                }

                json.dumpTestArtifact(RuleTestArtifactKey(rule, TestArtifactKind.SINGLE_RULE), rule)

                // Process each counter example
                examplesData.examples.forEach { counterExample ->
                    when (counterExample.callTrace) {
                        is CallTrace.ViolationFound -> {
                            // Dump artifacts for violated assert and expected tree view
                            json.dumpTestArtifact(
                                RuleTestArtifactKey(rule, TestArtifactKind.VIOLATED_ASSERT),
                                counterExample.callTrace.violatedAssert
                            )
                            json.dumpTestArtifact(
                                RuleTestArtifactKey(rule, TestArtifactKind.EXPECTED),
                                counterExample.callTrace.callHierarchyRoot.treeViewRepBuilder.build().jsonObject
                            )
                        }

                        else -> logger.error("Unexpected call trace type: $counterExample.callTrace")
                    }
                }

            } catch (e: SerializationException) {
                // Handle any errors that occur during serialization of TAC.
                logger.warn { "SerializationException occurred while saving 'sat' rule failure: ${e.message}" }
            } catch (e: IOException) {
                // Handle any errors that occur while writing the example info JSON file.
                logger.warn { "IOException occurred while saving 'sat' rule failure: ${e.message}" }
            }
        }
    }
}


/**
 *  A utility to transform error of rule compilation
 **/
private fun Result<List<ICheckableTAC>>.transformError(
    _rule: CVLSingleRule,
): Result<List<ICheckableTAC>> =
    fold(onSuccess = { Result.success(it) }) { e ->
        Logger.alwaysError(
            "Got exception ${e.message} when compiling rule ${_rule.declarationId}",
            e
        )
        Result.failure(CertoraException.fromExceptionWithRuleName(e, _rule.declarationId))
    }
