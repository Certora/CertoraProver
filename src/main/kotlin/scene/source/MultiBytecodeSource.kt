/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

@file:UseSerializers(utils.BigIntegerSerializer::class)

package scene.source

import bridge.*
import compiler.ABI
import compiler.calculateHashFromCanonicalName
import decompiler.Decompiler
import decompiler.Disassembler
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.UseSerializers
import kotlinx.serialization.builtins.ArraySerializer
import kotlinx.serialization.json.Json
import utils.*
import java.io.BufferedReader
import java.io.FileReader

/**
 * The data class is formulated based on a blockchain scrapper e.g. from Etherscan or others.
 * Specifically, this works with Bart's scraper.
 *
 * @param address - the address of the contract on chain
 * @param abiString - the ABI string as generated by solc or as saved by etherscan/other explorers
 * @param flattenedSourceCode - the source code of the contract, flattened
 * @param contractName - the name of the contract (used to identify within a flattened solidity file)
 * @param compilerVersionString - the version string of the compiler (usually includs build info, saved by solc's metadata generator)
 * @param optimizationConfigString - designation of optimization parameters used in solc
 * @param constructorArgumentsString - parameters passed to constructors - probably generated by deploy tools
 * @param runtimeBytecode - the runtime bytecode
 * @param constructorBytecode - constructor bytecode (or just "bytecode" in solc json output)
 */
@Serializable
data class AnnotatedBytecode(
    val address: String,
    @SerialName("ABI")
    val abiString: String,
    @SerialName("SourceCode")
    val flattenedSourceCode: String?,
    @SerialName("ContractName")
    val contractName: String,
    @SerialName("CompilerVersion")
    val compilerVersionString: String?,
    @SerialName("OptimizationUsed")
    val optimizationConfigString: String?,
    @SerialName("ConstructorArguments")
    val constructorArgumentsString: String?,
    @SerialName("DeployedCode")
    val runtimeBytecode: String,
    @SerialName("ContractCreationCode")
    val constructorBytecode: String
)

data class AnnotatedBytecodeWithMeta(
    val annotatedBytecode: AnnotatedBytecode,
    val filename: String,
    val index: Int
)

typealias Sighash = String

class MultiBytecodeSource(bytecodeContractFilenames: List<String>) : IContractSourceFull {
    private val jsonBuilder = Json {
        ignoreUnknownKeys = true
    }

    private fun loadAnnotatedBytecode(filename: String): AnnotatedBytecode {
        val outputBuilder = StringBuilder()
        BufferedReader(FileReader(filename)).use { reader ->
            var line : String?
            do {
                line = reader.readLine()
                if (line != null) {
                    outputBuilder.appendLine(line)
                }
            } while (line != null)
        }

        return jsonBuilder.decodeFromString(AnnotatedBytecode.serializer(), outputBuilder.toString())
    }

    private val annotatedBytecodes = bytecodeContractFilenames.mapIndexed { idx, filename ->
        idx to AnnotatedBytecodeWithMeta(
            loadAnnotatedBytecode(filename),
            filename,
            idx
        )
    }.toMap()

    val mainContract = annotatedBytecodes[0]?.annotatedBytecode?.contractName
        ?: throw IllegalStateException("Should only be able to call MultiBytecodeSource with at least one contract")

    @OptIn(ExperimentalSerializationApi::class)
    private val _instances = annotatedBytecodes.map { annotatedBytecodeEntry ->
        val annotatedBytecode = annotatedBytecodeEntry.value.annotatedBytecode
        val abi = jsonBuilder.decodeFromString(ArraySerializer(ABI.serializer()), annotatedBytecode.abiString.replace("\\\\\"", "\""))
        ContractInstanceInSDC(
            name = annotatedBytecode.contractName,
            file = annotatedBytecodeEntry.value.filename,
            address = annotatedBytecode.address.removePrefix("0x").toBigInteger(16),
            is_static_address = false,
            original_file = annotatedBytecodeEntry.value.filename,
            lang = SourceLanguage.Unknown,
            methods = abi.map {
                /**
                 * If we are loading bytecode from via https://github.com/Certora/BytecodeFetcher from Etherscan, the bytecode is dissambled and for function
                 * entries the selector field contains the sighash of the function (removing the first two characters (0x) to map it to our internal sighash representation)
                 *
                 * Otherwise, build the canonical name of the method and re-compute the sighash. (This assumes that the function name and parameter
                 * names are given)
                 */
                it.toMethod(it.selector?.removePrefix("0x") ?: @Suppress("DEPRECATION") calculateHashFromCanonicalName(it.toCanonicalSig())).copy(contractName = annotatedBytecode.contractName)
            },
            bytecode = annotatedBytecode.runtimeBytecode.removePrefix("0x"),
            constructorBytecode = annotatedBytecode.constructorBytecode.removePrefix("0x"),
            srcmap = "",
            varmap = "",
            storageLayout = StorageLayout(),
            transientStorageLayout = StorageLayout(),
            srclist = mapOf(),
            immutables = listOf(),
            solidityTypes = setOf()
        )
    }.let { instances ->
        instances.map { origInstance ->
            // Solidity source - we can just use the methods information from the compiler
            // Bytecode source - empty method list and instance.file is not a solidity file - run overapproximated analysis
            origInstance.letIf(!origInstance.hasCompilerData()) {
                val bytecode = Disassembler.disassembleRuntimeBytecode(origInstance)
                val methods = Decompiler.extractPotentialSighashes(bytecode).map { sighash ->
                    Method(
                        "unknown_method_${sighash}",
                        datastructures.stdcollections.emptyList(),
                        datastructures.stdcollections.emptyList(),
                        sighash,
                        isLibrary = false,
                        contractName = origInstance.name)
                }
                origInstance.copy(methods = methods)
            }
        }
    }

    override fun instances(): List<ContractInstanceInSDC> = _instances

    override fun fullInstances(): List<ContractInstanceInSDC> = instances()
}
