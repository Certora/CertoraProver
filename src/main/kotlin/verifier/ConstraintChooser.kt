/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package verifier

import smt.ConstraintChooserEnum
import smt.axiomgenerators.fullinstantiation.BitwiseAxiomGenerator
import smt.axiomgenerators.fullinstantiation.LinearMathAxiomGenerator
import smt.solverscript.functionsymbols.subs
import smtlibutils.cmdprocessor.SmtFormulaCheckerQuery
import smtlibutils.data.FactorySmtScript
import smtlibutils.data.Identifier
import smtlibutils.data.SmtExp
import smtlibutils.data.SmtIntpFunctionSymbol
import vc.data.LExpression
import vc.gen.LExpVC
import java.math.BigInteger

private fun String.sWith(vararg prefixes: String) =
    prefixes.any { this.startsWith(it) }

/**
 * Tells which of the variables to take as constraints.
 * Currently, this uses string-ops to identify which variables to take. Admittedly, this is very bad. However, this
 * is currently much simpler than any other option, and furthermore, is not unsound. At worst, it will not choose
 * wisely and will just not work well...
 */
enum class ConstraintChooser(
    val takeBool: SmtConstraintsGen.(String, Boolean) -> Boolean,
    val takeInt: SmtConstraintsGen.(String, BigInteger) -> Boolean
) {
    JustBools(
        takeBool = { _, _ -> true },
        takeInt = { _, _ -> false }
    ),
    TakeAll(
        takeBool = { _, _ -> true },
        takeInt = { _, _ -> true }
    ),
    BoolsAndManyMore(
        takeBool = { _, _ -> true },
        takeInt = { name, value ->
            name.sWith("e.", "I", "certora", "and") ||
                    (name.sWith("R", "tac") && value in originalConsts)
        }
    ),
    FewBoolsAndManyMore(
        takeBool = { name, _ -> name.sWith("OK") },
        takeInt = { name, value ->
            name.sWith("e.", "I", "certora", "and") ||
                    (name.sWith("R", "tac") && value in originalConsts)
        }
    ),
    BoolsAndSomeMore(
        takeBool = { _, _ -> true },
        takeInt = { name, value ->
            name.sWith("e.", "certora", "and") ||
                    (name.sWith("tac") && value in originalConsts)
        }
    );

    companion object {
        fun fromConstraintChooserEnum(cc: ConstraintChooserEnum): ConstraintChooser {
            return when (cc) {
                ConstraintChooserEnum.justBools -> JustBools
                ConstraintChooserEnum.takeAll -> TakeAll
                ConstraintChooserEnum.boolsAndManyMore -> BoolsAndManyMore
                ConstraintChooserEnum.fewBoolsAndManyMore -> FewBoolsAndManyMore
                ConstraintChooserEnum.boolsAndSomeMore -> BoolsAndSomeMore
            }
        }
    }
}

/**
 * Facilitates using a counter example and creating a set of constraints from it via [getConstraintsFrom].
 *
 * It is very important that [baseQuery] and the query that the counter example comes from are aligned. The only
 * case we know of where this is not aligned is the skolem constants generated by [LinearMathAxiomGenerator] in one
 * special case (division by a power of two). Since this is always called after [BitwiseAxiomGenerator] which is the only
 * one generating skolem variable (other than this case). Then we know all skolem variables are aligned except for these
 * last ones.
 *
 * The simple solution here is to not include assignments in the counter examples for variables we don't have in
 * [baseQuery]. However, if things change, and we generate more variables while axiomatizing, or we get some sort
 * of non-determinism in the process, then variables will get mis-aligned. This is all pretty brittle at the moment.
 *
 * Note that if the variables get misaligned the approach is still sound. That is because the constrained model gets
 * checked in NIA. If it gives SAT, the counter-example is real, and if UNSAT, we ignore the result as it is an under-approximation.
 */
class SmtConstraintsGen(val baseQuery: SmtFormulaCheckerQuery, val vc: LExpVC, val script: FactorySmtScript) {
    val originalVars = mutableSetOf<String>()
    val originalConsts = mutableSetOf<BigInteger>()

    init {
        vc.lExpressions.subs.forEach {
            when (it) {
                is LExpression.Identifier -> originalVars.add(it.id)
                is LExpression.Literal -> originalConsts.add(it.i)
                else -> Unit
            }
        }

        originalConsts += listOf(BigInteger.ZERO, BigInteger.ONE, BigInteger.TWO)
    }

    fun getConstraintsFrom(values: Map<SmtExp, SmtExp>, chooser: ConstraintChooser, onlyFromVc: Boolean = false) =
        values.asSequence()
            .filter { (v, value) ->
                v is SmtExp.QualIdentifier &&
                        v.id is Identifier.Simple &&
                        !(onlyFromVc && v.id.sym !in originalVars) &&
                        take(v, value, chooser)
            }.map { (v, value) ->
                script.apply(SmtIntpFunctionSymbol.Core.Eq(v.sort!!), v, value)
            }

    private fun take(v: SmtExp.QualIdentifier, value: SmtExp, taker: ConstraintChooser) =
        v.id in baseQuery.variables && when {
            value.isBooleanValueLit() -> (taker.takeBool)(v.id.sym, value.asBoolean())
            value.isIntLiteral() -> (taker.takeInt)(v.id.sym, value.asBigInt())
            else -> value.isDatatypeLiteral(baseQuery.symbolTable) // Everyone likes hash expressions
        }
}
