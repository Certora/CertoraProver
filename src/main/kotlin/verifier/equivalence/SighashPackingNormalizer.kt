/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY, without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR a PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package verifier.equivalence

import analysis.*
import evm.DEFAULT_SIGHASH_SIZE
import evm.MASK_SIZE
import tac.Tag
import utils.*
import vc.data.*
import vc.data.SimplePatchingProgram.Companion.patchForEach
import vc.data.TACProgramCombiners.andThen
import vc.data.tacexprutil.ExprUnfolder
import java.math.BigInteger

/**
 * Normalizes the indices at which the sighash packer generated by solidity
 * reads. By default, when constructing something with `abi.encodeWith(...)` or `abi.encodeCall`
 * the arguments are encoded starting at offset 4, and then the sighash is packed into the start of the
 * buffer by reading from offset 0 in the buffer. This works on the real EVM given the overlapping semantics,
 * but our bytemap model isn't strong enough to handle this (extremely) common case. Instead of constantly
 * falling back on bounded precision cells, we just special case it by changing the sighash packing
 * to explicitly read offset 4, shift down the value by 4 bytes, and then pack in the sighash.
 */
object SighashPackingNormalizer {
    private data class Payload(
        val sighashConst: BigInteger,
        val readFrom: TACSymbol.Var,
        val readLoc: CmdPointer
    )
    private val pattern = PatternDSL.build {
        (((Const and (MASK_SIZE(32).shiftLeft(224))()).commute.first `^` Const) or
            (MASK_SIZE(224)() and PatternMatcher.Pattern.AssigningPattern0(
                klass = TACCmd.Simple.AssigningCmd.ByteLoad::class.java,
                extract = { _, which ->
                    which.takeIf {
                        it.base == TACKeyword.MEMORY.toVar()
                    }?.loc?.let {
                        it as? TACSymbol.Var
                    }?.let { PatternMatcher.ConstLattice.Match(it) } ?: PatternMatcher.ConstLattice.NoMatch
                }
            ).asBuildable()).commute.locSecond
        ).commute.withAction { sigConst, (lc, v) ->
            Payload(sighashConst = sigConst, readFrom = v, readLoc = lc.ptr)
        }
    }

    fun doWork(c: CoreTACProgram) : CoreTACProgram {
        val matcher = PatternMatcher.compilePattern(c.analysisCache.graph, pattern)
        val gvn = c.analysisCache.gvn
        return c.parallelLtacStream().mapNotNull {
            it.maybeNarrow<TACCmd.Simple.AssigningCmd.ByteStore>()?.takeIf { lc ->
                lc.cmd.loc is TACSymbol.Var && lc.cmd.base == TACKeyword.MEMORY.toVar() && lc.cmd.value is TACSymbol.Var
            }
        }.mapNotNull { byteLc ->
            byteLc `to?` matcher.query(byteLc.cmd.value as TACSymbol.Var, byteLc.wrapped).toNullableResult()?.takeIf { matchPayload ->
                matchPayload.readFrom in gvn.findCopiesAt(matchPayload.readLoc, source = byteLc.ptr to (byteLc.cmd.loc as TACSymbol.Var)) &&
                    matchPayload.readLoc.block == byteLc.ptr.block &&
                    c.analysisCache.graph.iterateBlock(matchPayload.readLoc, end = byteLc.ptr.pos, excludeStart = true).none {
                        it.cmd is TACCmd.Simple.AssigningCmd.ByteStore || it.cmd is TACCmd.Simple.AssigningCmd.ByteStoreSingle ||
                            (it.cmd is TACCmd.Simple.LongAccesses && it.cmd.accesses.any {
                                it.isWrite && it.base == TACKeyword.MEMORY.toVar()
                            })
                    } && (matchPayload.sighashConst and MASK_SIZE(32).shiftLeft(224)) == matchPayload.sighashConst
            }
        }.patchForEach(c, check = true) { (byteLc, p) ->
            val atNext = TACKeyword.TMP(Tag.Bit256, "nextByte")
            val replacement = ExprUnfolder.unfoldPlusOneCmd("readNextByte", TACExprFactTypeCheckedOnlyPrimitives {
                p.readFrom add DEFAULT_SIGHASH_SIZE.asTACExpr
            }) {
                TACCmd.Simple.AssigningCmd.ByteLoad(
                    lhs = atNext,
                    loc = it.s,
                    base = TACKeyword.MEMORY.toVar()
                )
            }.merge(atNext) andThen ExprUnfolder.unfoldPlusOneCmd("packSighash", TACExprFactTypeCheckedOnlyPrimitives {
                ((atNext shiftRLog 32.asTACExpr) bwAnd MASK_SIZE(224).asTACExpr) add p.sighashConst.asTACExpr
            }) {
                TACCmd.Simple.AssigningCmd.ByteStore(
                    base = TACKeyword.MEMORY.toVar(),
                    loc = byteLc.cmd.loc,
                    value = it.s
                )
            }
            replaceCommand(byteLc.ptr, replacement)
        }
    }
}
