/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package verifier.equivalence

import verifier.equivalence.tracing.BufferTraceInstrumentation

/**
 * Class driving the equivalence loop in [FullEquivalence].
 * Each step of that loop queries this object via [nextConfig] for the next equivalence configuration to use;
 * this configuration says what VC to check, how to instrument the original programs, etc.
 *
 * On timeouts, the equivalence loop queries this class to see if there is a way to decompose the problem [onTimeout].
 * On success, the equivalence loop asks for the next step of checking via [onSuccess], which returns the next
 * [ExplorationManager] to use.
 *
 * [I] is the calling convention for the programs being compared.
 */
interface ExplorationManager<I> {
    /**
     * The full configuration describing how to instrument the source programs (via [getAConfig] and [getBConfig]),
     * and how to generate the verification condition for those programs with the [vcGenerator]. If the current query
     * supports minimization, that is provided by [minimizer].
     *
     */
    interface EquivalenceCheckConfiguration<I> {
        val vcGenerator: TraceEquivalenceChecker.VCGenerator<I>
        val minimizer: Minimizer?

        val traceTarget: BufferTraceInstrumentation.TraceTargets

        fun getAConfig(): BufferTraceInstrumentation.InstrumentationControl
        fun getBConfig(): BufferTraceInstrumentation.InstrumentationControl
    }

    /**
     * Gets the next configuration for the equivalence checker to check. [p] is the pairwise proof manager, and holds the
     * "state" of the equivalence loop; recording refinements that have been discovered in previous iterations and which *should*
     * be included in the instrumentation configurations generated by the returned [EquivalenceCheckConfiguration].
     */
    fun nextConfig(p: EquivalenceChecker.PairwiseProofManager): EquivalenceCheckConfiguration<I>

    /**
     * Called if the configuration returned by [nextConfig] successfully verified (the solver returned UNSAT).
     * Returning null indicates that no further queries are necessary, and the two programs should be pronounced
     * equivalence. A non-null return indicates there is more checking to be done to be controlled by the returned
     * managed.
     *
     * [check] encapsulates all of the results of the successful equivalence check process;
     * the instrumentation information, solver results, etc.
     */
    fun onSuccess(check: TraceEquivalenceChecker.CheckResult<I>) : ExplorationManager<I>?

    /**
     * Called if the configuration returned by [nextConfig] hit a solver timeout. If this function returns null
     * this means there is no decomposition or simplification possible, and the overall equivalence check aborts
     * with the timeout results. Otherwise, the equivalence check is retried using the strategy described by the returned
     * object.
     *
     * [check] holds all of the information about the timed-out equivalence check; the instrumentation information,
     * solver result (which will always be TIMEOUT, appropriately enough), etc.
     */
    fun onTimeout(check: TraceEquivalenceChecker.CheckResult<I>) : ExplorationManager<I>?
}
