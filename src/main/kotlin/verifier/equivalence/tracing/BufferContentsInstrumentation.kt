/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY, without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR a PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package verifier.equivalence.tracing

import analysis.CommandWithRequiredDecls
import datastructures.stdcollections.*
import verifier.equivalence.tracing.BufferTraceInstrumentation.Companion.`=`
import tac.Tag
import vc.data.*
import vc.data.TACProgramCombiners.andThen
import vc.data.TACProgramCombiners.wrap
import vc.data.tacexprutil.ExprUnfolder

/**
 * Records the writes/copies that define the contents of a long read.
 * This can be extracted from a CEX to build a more precise model of the buffer.
 *
 * See [BufferTraceInstrumentation.IBufferContentsInstrumentation]
 * for an explanation of the member variables
 */
internal data class BufferContentsInstrumentation(
    override val bufferWriteCountVar: TACSymbol.Var,
    override val bufferOffsetHolder: TACSymbol.Var,
    override val bufferValueHolder: TACSymbol.Var,
    override val bufferCopySource: TACSymbol.Var,
    override val preciseBuffer: TACSymbol.Var
) : InstrumentationMixin, BufferTraceInstrumentation.IBufferContentsInstrumentation {
    /**
     * Conditionally writes [newValue] to index [bufferWriteCountVar] in [buffer] if [overlapSym] is true,
     * otherwise generates a nop write.
     */
    private fun conditionalUpdateOf(
        overlapSym: TACSymbol.Var,
        buffer: TACSymbol.Var,
        newValue: ToTACExpr
    ) : CommandWithRequiredDecls<TACCmd.Simple> {
        return conditionalUpdateOf(overlapSym, buffer) { newValue }
    }

    /**
     * Like the above, but the value to be written into [buffer] is generated by [mk].
     */
    private fun conditionalUpdateOf(
        overlapSym: TACSymbol.Var,
        buffer: TACSymbol.Var,
        mk: TACExprFactoryExtensions.() -> ToTACExpr
    ) : CommandWithRequiredDecls<TACCmd.Simple> {
        return ExprUnfolder.unfoldPlusOneCmd("${buffer.namePrefix}!update", TXF {
            ite(overlapSym, mk(), buffer[bufferWriteCountVar])
        }) {
            TACCmd.Simple.AssigningCmd.ByteStore(
                loc = bufferWriteCountVar,
                value = it.s,
                base = buffer
            )
        }.merge(bufferWriteCountVar, buffer, overlapSym)
    }

    override fun atPrecedingUpdate(
        s: IBufferUpdate,
        overlapSym: TACSymbol.Var,
        writeEndPoint: TACSymbol.Var,
        baseInstrumentation: ILongReadInstrumentation
    ): CommandWithRequiredDecls<TACCmd.Simple> {
        /**
         * Compute which map we should be writing into (either [bufferCopySource] or [bufferValueHolder])
         * depending on the sort of the write, and the value (either the constant buffer id or the value)
         *
         * If the write is an unsupported type, record the imprecision, increment the write count, and continue
         */
        val (characteristicMap, writtenVal) = when (val src = s.updateSource) {
            is IWriteSource.ByteStore -> bufferValueHolder to src.writeSymbol
            is IWriteSource.LongMemCopy -> {
                bufferCopySource to src.sourceBuffer.id.asTACExpr
            }
            is IWriteSource.EnvCopy,
            is IWriteSource.Other -> {
                return (conditionalUpdateOf(overlapSym, preciseBuffer, TACSymbol.Zero) andThen TXF {
                    CommandWithRequiredDecls(
                        listOf(
                            TACCmd.Simple.AssigningCmd.AssignExpCmd(
                                lhs = bufferWriteCountVar,
                                rhs = ite(
                                    overlapSym,
                                    bufferWriteCountVar add 1,
                                    bufferWriteCountVar
                                )
                            )
                        )
                    )
                }).wrap("Havoc write for ${baseInstrumentation.id}")
            }
        }

        /**
         * (conditionally):
         * 1. update the relative offset holder
         * 2. update the copy source/write value map
         * 3. update the precise buffer flag to be 1
         * 4. increment write count
         */
        return (conditionalUpdateOf(overlapSym, bufferOffsetHolder) {
            s.updateLoc sub baseInstrumentation.baseProphecy
        }.merge(s.updateLoc, baseInstrumentation.baseProphecy) andThen conditionalUpdateOf(overlapSym, characteristicMap) {
            writtenVal
        } andThen conditionalUpdateOf(overlapSym, preciseBuffer, TACSymbol.One) andThen (bufferWriteCountVar `=` {
            ite(overlapSym, (bufferWriteCountVar add TACSymbol.One), bufferWriteCountVar)
        })).wrap("Precise update for ${baseInstrumentation.id}")
    }

    override fun atLongRead(s: ILongRead): CommandWithRequiredDecls<TACCmd.Simple> {
        return CommandWithRequiredDecls()
    }

    override val havocInitVars: List<TACSymbol.Var>
        get() = listOf()
    override val constantInitVars: List<Pair<TACSymbol.Var, ToTACExpr>>
        get() = listOf(
            bufferWriteCountVar to TACExpr.zeroExpr,
            bufferOffsetHolder to TACExpr.MapDefinition(
                listOf(idxVar.asSym()),
                TACExpr.zeroExpr, Tag.ByteMap
            ),
            bufferValueHolder to TACExpr.MapDefinition(
                listOf(idxVar.asSym()),
                TACExpr.zeroExpr, Tag.ByteMap
            ),
            bufferCopySource to TACExpr.MapDefinition(
                listOf(idxVar.asSym()),
                TACExpr.zeroExpr, Tag.ByteMap
            ),
            preciseBuffer to TACExpr.MapDefinition(
                listOf(idxVar.asSym()),
                TACExpr.zeroExpr, Tag.ByteMap
            )
        )

}
