/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package verifier.equivalence.cex

import analysis.*
import analysis.ip.INTERNAL_FUNC_EXIT
import analysis.ip.INTERNAL_FUNC_START
import datastructures.stdcollections.*
import evm.DEFAULT_SIGHASH_SIZE
import evm.EVM_BITWIDTH256
import evm.EVM_BYTES_IN_A_WORD
import evm.EVM_WORD_SIZE
import log.*
import report.calltrace.CallInputsAndOutputs
import report.calltrace.calldataMovement
import report.calltrace.formatter.CallTraceValue
import report.calltrace.formatter.CallTraceValueFormatter
import report.calltrace.formatter.FormatterType
import report.calltrace.formatter.LayoutDecoderStrategy
import report.calltrace.registerCalldataMovement
import solver.CounterexampleModel
import spec.cvlast.VMParam
import spec.cvlast.typedescriptors.EVMTypeDescriptor
import tac.NBId
import utils.*
import vc.data.TACCmd
import vc.data.TACSymbol
import verifier.equivalence.*
import verifier.equivalence.StaticBufferRefinement.fmtError
import verifier.equivalence.summarization.CommonPureInternalFunction
import verifier.equivalence.tracing.BufferTraceInstrumentation
import java.math.BigInteger
import verifier.equivalence.CEXUtils.toList
import verifier.equivalence.CEXUtils.withFailureString
import verifier.equivalence.data.*

private val logger = Logger(LoggerTypes.EQUIVALENCE)


/**
 * Called to explain counter examples generated during the process.
 *
 * [checkResult] is the report generated by [TraceEquivalenceChecker] with a SAT result.
 * [instLevels] describes the traces being explored, and [queryContext] provides data about the context of
 * the query.
 */
internal class CounterExampleExplainer(
    private val instLevels: BufferTraceInstrumentation.TraceTargets,
    private val checkResult: TraceEquivalenceChecker.CheckResult<*>,
    override val queryContext: EquivalenceQueryContext,
) : IWithQueryContext {

    private val theModel get() = checkResult.theModel
    private val vcProgram get() = checkResult.vcProgram

    private val callTraceValueFormatter = CallTraceValueFormatter(
        scene = scene,
        model = checkResult.theModel,
        addrToContract = mapOf()
    )

    /**
     * Really a specialized version of the [Either] type to make type signatures easier to read
     */
    private sealed interface MatchingEventData<out T> {
        data class Found<T>(val what: T) : MatchingEventData<T>
        data object Missing : MatchingEventData<Nothing>
    }
    private fun explainStorageDifference(
        failingAssert: LTACCmdView<TACCmd.Simple.AssertCmd>,
    ) : Either<MismatchExplanation.StorageExplanation, String> {
        fun Either<Nothing, String>.fail(): Either<Nothing, String> {
            return "Couldn't explain storage difference: ${this.right()}".toRight()
        }
        val data = failingAssert.cmd.meta[EquivalenceChecker.STORAGE_EQUIVALENCE_ASSERTION]!!

        val slot = data.skolemIndex.formatScalarAs(
            bytes32Type
        ).leftOr { return it.fail() }
        val contractAValue = data.contractAValue.formatScalarAs(bytes32Type).leftOr { return it.fail() }
        val contractBValue = data.contractBValue.formatScalarAs(bytes32Type).leftOr { return it.fail() }
        return MismatchExplanation.StorageExplanation(
            slot = slot,
            contractAValue = contractAValue,
            contractBValue = contractBValue,
        ).toLeft()
    }

    /**
     * From the [BufferTraceInstrumentation.CallEvent] object
     * found at [where] in [graph], extract the [ExternalCall] object
     * describing the call. Otherwise, it returns the extracted
     * ordinal and the [ExternalCall] object.
     */
    private fun extractEnvironment(
        graph: TACCommandGraph,
        where: LTACCmd,
        ce: BufferTraceInstrumentation.CallEvent,
    ) : ExternalCall {
        val model = theModel
        return callEventDataToInteraction(where, ce, model, graph).toValue({ it }, {
            ExternalCall.Incomplete(
                it
            )
        })
    }

    /**
     * Try to extract the [ExternalCall.Complete]
     * from the [BufferTraceInstrumentation.CallEvent] [ce]
     * found at [where] in [graph] using the values in [model].
     */
    private fun callEventDataToInteraction(
        where: LTACCmd,
        ce: BufferTraceInstrumentation.CallEvent,
        model: CounterexampleModel,
        graph: TACCommandGraph
    ): Either<ExternalCall.Complete, String> {
        fun <T> Either<T, CounterexampleModel.ResolvingFailure>.withFailureString(what: () -> String) =
            this.mapRight {
                "Failed resolving ${what()} @ $where with $ce: $it"
            }

        fun <T, U> Either<T, CounterexampleModel.ResolvingFailure>.formatErrorOrBind(
            what: String,
            f: (T) -> Either<U, String>
        ): Either<U, String> {
            return when (this) {
                is Either.Left -> f(this.d)
                is Either.Right -> "Failed resolving calldata at $where: couldn't get value for $what; ${this.d}".toRight()
            }
        }

        val callee = model.valueAsBigInteger(ce.callee).withFailureString { "callee address" }.leftOr { return it }
        val returnSize =
            model.valueAsBigInteger(ce.returnDataSize).withFailureString { "return address" }.leftOr { return it }
        val returnResult = model.valueAsBigInteger(ce.returnCode).withFailureString { "return code" }.leftOr { return it } != BigInteger.ZERO
        val calleeCodesize =
            model.valueAsBigInteger(ce.calleeCodeSize).withFailureString { "callee codesize" }.leftOr { return it }
        val value = model.valueAsBigInteger(ce.value).withFailureString { "sent value" }.leftOr { return it }
        val calldata = model.valueAsBigInteger(ce.bufferLength).formatErrorOrBind("input buffer length") { buffLength ->
            model.valueAsBigInteger(ce.bufferStart).formatErrorOrBind("input buffer offset") { buffStart ->
                PreciseBufferExtraction.extractBufferModel(
                    start = buffStart,
                    where = where.ptr,
                    graph = graph,
                    model = model,
                    buffer = ce.memoryCapture,
                    len = buffLength
                ).toList(buffLength)
            }
        }
        val returnData = mutableListOf<BigInteger>()
        var returnOffsIt = BigInteger.ZERO
        val symbols = ce.returnDataSample.iterator()
        while(returnOffsIt < returnSize && symbols.hasNext()) {
            if (returnOffsIt + EVM_WORD_SIZE > returnSize) {
                break
            }
            val sym = symbols.next()
            val elemValue = model.valueAsBigInteger(sym).withFailureString("Return offs: $returnOffsIt").leftOrNull() ?: break
            returnData.add(elemValue)
            returnOffsIt += EVM_WORD_SIZE
        }
        val dataRepr = when {
            returnOffsIt == returnSize -> ExternalCall.ReturnDataSample.Complete(returnData)
            returnData.isEmpty() -> ExternalCall.ReturnDataSample.None
            else -> ExternalCall.ReturnDataSample.Prefix(
                returnData, bytesMissing = returnSize - returnOffsIt
            )
        }
        return ExternalCall.Complete(
            returnSize = returnSize,
            callee = callee,
            callResult = returnResult,
            calleeCodesize = calleeCodesize,
            calldata = calldata,
            value = value,
            returnData = dataRepr
        ).toLeft()
    }

    /**
     * Extract the [CallTraceValue] representation of arguments
     * from the [CallInputsAndOutputs] that were found the body of [method].
     */
    private fun extractArguments(
        method: TraceEquivalenceChecker.Instrumentation<*, *>,
        cio: CallInputsAndOutputs,
    ) : Map<Int, CallTraceValue> {
        return cio.externalCall(method.inlinedCallId)?.let { aArgs ->
            val m = aArgs.calldataFamily.toValueMap(
                theModel, DEFAULT_SIGHASH_SIZE
            )
            LayoutDecoderStrategy(
                names = aArgs.extra.paramNames,
                paramTypes = aArgs.extra.paramTypes,
                byteOffsetToModelValue = m
            ).asMap()
        }.orEmpty()
    }

    /**
     * Get a "friendly" explanation of the input in the case of a CEX.
     *
     * This includes the calldata arguments, some environment information etc.
     */
    private fun getInputExplanation() : InputExplanation {
        val model = theModel
        val ruleProg = vcProgram
        val env = AbstractRuleGeneration.extractEnvironmentValues(
            model, ruleProg
        )
        val msgVal = env[EthereumVariables.callvalue]
        val caller = env[EthereumVariables.caller]
        val cio = CallInputsAndOutputs(
            blocks = ruleProg.topoSortFw.filter {
                it in model.reachableNBIds
            },
            model = model,
            scene = scene,
            analysisCache = ruleProg.analysisCache
        )
        val ctf = CallTraceValueFormatter(
            model = model,
            scene = scene,
            addrToContract = mapOf()
        )
        val methodACallId = checkResult.programA.inlinedCallId
        val methodBCallId = checkResult.programB.inlinedCallId
        ruleProg.parallelLtacStream().filter {
            it.ptr.block.calleeIdx == methodACallId || it.ptr.block.calleeIdx == methodBCallId
        }.mapNotNull {
            it.maybeNarrow<TACCmd.Simple.AssigningCmd.AssignExpCmd>()
        }.flatMap {
            val callIdx = it.ptr.block.calleeIdx
            it.cmd.calldataMovement(model, callIdx).stream().map {
                it to callIdx
            }
        }.sequential().forEach { (mov, id) ->
            cio.registerCalldataMovement(mov, id)
        }
        val methodAArgs = extractArguments(checkResult.programA, cio)
        val methodBArgs = extractArguments(checkResult.programB, cio)
        val argOrds = methodAArgs.keys + methodBArgs.keys
        val args = mutableListOf<Argument>()
        for(i in argOrds.sorted()) {
            val aArg = methodAArgs[i]
            val bArg = methodBArgs[i]
            val aStringRepr = aArg?.toSarif(ctf, tooltip = "")?.flatten()
            val bStringRepr = bArg?.toSarif(ctf, tooltip = "")?.flatten()
            val argFormat = aStringRepr?.let {
                if(bStringRepr != null && bStringRepr != it) {
                    logger.warn {
                        "Conflicting argument representations for $i ${aArg.paramName} ${bArg.paramName}: $aStringRepr vs $bStringRepr"
                    }
                    "$aStringRepr / $bStringRepr"
                } else {
                    it
                }
            } ?: bStringRepr ?: "<no value found>"
            val (argName, altName) = if(aArg?.paramName != null) {
                aArg.paramName to bArg?.paramName
            } else {
                bArg?.paramName to null
            }
            if(argName == null) {
                continue
            }
            args.add(
                Argument(
                    ordinal = i,
                    name = argName,
                    value = argFormat,
                    altName = altName
                )
            )
        }
        return InputExplanation(
            argumentFormatting = args,
            messageValue = msgVal,
            sender = caller
        )
    }

    private fun <T: MethodMarker> extractEventData(
        context: TraceEquivalenceChecker.Instrumentation<T, *>,
        annot: LTACAnnotation<BufferTraceInstrumentation.TraceIndexMarker>
    ) : MatchingEventData<TraceEvent<T>> {
        val orig = context.instrumentationResult.useSiteInfo.keysMatching { _, info ->
            info.id == annot.annotation.id
        }.singleOrNull() ?: return MatchingEventData.Missing
        return MatchingEventData.Found(
            TraceEvent(
                origProgramSite = orig,
                marker = annot.annotation,
                vcProgramSite = annot.ptr
            )
        )
    }

    /**
     * Called when we are sure there is a CEX and mismatch.
     */
    fun explainCounterExample(
        aTrace: TraceEvent<MethodMarker.METHODA>?,
        bTrace: TraceEvent<MethodMarker.METHODB>?
    ) : EquivalenceChecker.SatInterpretation {
        val aWithContext = aTrace?.let { TraceWithContext(it, checkResult.programA) }
        val bWithContext = bTrace?.let { TraceWithContext(it, checkResult.programB) }
        if(aWithContext == null || bWithContext == null) {
            return tryMissingInterpretation(
                methodAEvent = aWithContext,
                methodBEvent = bWithContext
            )
        }

        val aEvent = traceMarkerToEvent(aWithContext.event).leftOr {
            return EquivalenceChecker.SatInterpretation.GaveUp(
                "Failed extracting explanation from ${checkResult.programA.originalProgram.pp()}: ${it.right()}",
                checkResult.ruleResult
            )
        }
        val bEvent = traceMarkerToEvent(bWithContext.event).leftOr {
            return EquivalenceChecker.SatInterpretation.GaveUp(
                "Failed extracting explanation from ${checkResult.programB.originalProgram.pp()}: ${it.right()}",
                checkResult.ruleResult
            )
        }
        val priorCallsA = getPriorTrace(aWithContext.toSelector()) {
            it
        }
        val priorCallsB = getPriorTrace(bWithContext.toSelector()) {
            SyncEvent
        }

        return EquivalenceChecker.SatInterpretation.RealCounterExample(
            inputExplanation = getInputExplanation(),
            priorEventsA = priorCallsA.leftOrNull(),
            priorEventsB = priorCallsB.leftOrNull(),
            diffExplanation = MismatchExplanation.DifferentEvents(
                eventInA = aEvent,
                eventInB = bEvent
            ),
            ruleCheckResult = checkResult.ruleResult
        )
    }

    /**
     * Explain a counterexample found in storage indices
     */
    fun explainStorageCEX(
        failingAssert: LTACCmdView<TACCmd.Simple.AssertCmd>
    ) : EquivalenceChecker.SatInterpretation {
        return explainStorageDifference(failingAssert).mapLeft {
            val inputExplanation = getInputExplanation()

            val callEnvA = getPriorTrace(
                object : TraceSelector<MethodMarker.METHODA> {
                    override val method: TraceEquivalenceChecker.Instrumentation<MethodMarker.METHODA, *>
                        get() = checkResult.programA

                    override fun stop(where: LTACCmd): Boolean {
                        return where.ptr.block.calleeIdx == NBId.ROOT_CALL_ID
                    }

                    override fun filter(blk: NBId): Boolean {
                        return blk.calleeIdx == NBId.ROOT_CALL_ID || blk.calleeIdx == checkResult.programA.inlinedCallId
                    }

                }
            ) {
                it
            }.leftOrNull()

            val callEnvB = getPriorTrace(
                object : TraceSelector<MethodMarker.METHODB> {
                    override val method: TraceEquivalenceChecker.Instrumentation<MethodMarker.METHODB, *>
                        get() = checkResult.programB

                    override fun stop(where: LTACCmd): Boolean {
                        return where.ptr.block.calleeIdx == NBId.ROOT_CALL_ID
                    }

                    override fun filter(blk: NBId): Boolean {
                        return blk.calleeIdx == NBId.ROOT_CALL_ID || blk.calleeIdx == method.inlinedCallId
                    }

                }
            ) {
                SyncEvent
            }.leftOrNull()
            EquivalenceChecker.SatInterpretation.RealCounterExample(
                ruleCheckResult = checkResult.ruleResult,
                diffExplanation = it,
                inputExplanation = inputExplanation,
                priorEventsA = callEnvA,
                priorEventsB = callEnvB
            )
        }.toValue({ it }, { EquivalenceChecker.SatInterpretation.GaveUp(it, checkResult.ruleResult) })
    }

    private fun <T: MethodMarker> tryExtractBufferModel(
        event: TraceEvent<T>
    ) : Either<List<UByte>, String> {
        return theModel.valueAsBigInteger(event.marker.lengthVar).fmtError().bindLeft { len ->
            theModel.valueAsBigInteger(event.marker.bufferStart).fmtError().bindLeft { base ->
                PreciseBufferExtraction.extractBufferModel(
                    graph = vcProgram.analysisCache.graph,
                    model = theModel,
                    where = event.vcProgramSite,
                    len = len,
                    start = base,
                    buffer = event.marker.bufferBase
                ).toList(len)
            }
        }
    }

    /**
     * Kotlin doesn't have a Quarduple class, so I use this instead.
     * Used to indicate which method is [missing] the event [lt] that was found
     * in [found]. [explain] describes how to turn that event data into a [MismatchExplanation].
     */
    private data class MissingPayload(
        val missing: CallableProgram<*, *>,
        val found: CallableProgram<*, *>,
        val lt: TraceWithContext<*, *>,
        val explain: (EventWithData) -> MismatchExplanation,
    )

    private val bytes32Type = EVMTypeDescriptor.BytesK(EVM_BYTES_IN_A_WORD)

    private fun TACSymbol.formatScalarAs(
        ty: EVMTypeDescriptor.EVMValueType,
        tooltip: String = ""
    ) : Either<String, String> {

        val tv = theModel.valueAsTACValue(this) ?: return "No value found for $this in model".toRight()
        val valueType = FormatterType.Value.EVM(ty)
        return callTraceValueFormatter.valueToSarif(tv, valueType, tooltip).flatten().toLeft()
    }

    /**
     * From the [BufferTraceInstrumentation.TraceIndexMarker],
     * extract the [EventWithData] representation,
     * including sort information, parameter info, etc.
     */
    private fun traceMarkerToEvent(
        lTraceEventMarker: TraceEvent<*>
    ) : Either<EventWithData, String> {
        val event = BufferTraceInstrumentation.extractEvent(
            marker = lTraceEventMarker.marker
        ).leftOr { return it }
        val sort = event.sort
        val params = when(event) {
            is BufferTraceInstrumentation.RawEventParams.ExternalCallParams -> {
                listOf(
                    EventParam(
                        label = ContextLabel.ExternalCallLabel.CALLEE,
                        value = event.context.callee.formatScalarAs(EVMTypeDescriptor.address).leftOrNull()
                    ),
                    EventParam(
                        label = ContextLabel.ExternalCallLabel.CALL_VALUE,
                        value = event.context.value.formatScalarAs(EVMTypeDescriptor.UIntK(EVM_BITWIDTH256))
                            .leftOrNull()
                    )
                )
            }
            is BufferTraceInstrumentation.RawEventParams.InternalSummaryParams -> {
                if(event.context.args.size != event.context.signature.params.size) {
                    return "Arity mismatch: have ${event.context.args.size} args but expected only ${event.context.signature.params.size}".toRight()
                }
                val argFmt = event.context.signature.params.zip(event.context.args).withIndex().monadicMap {
                    it.format()
                } ?: return "nah".toRight()
                listOf(
                    EventParam(
                        label = ContextLabel.InternalCallLabel.Signature,
                        value = event.context.signature.prettyPrintFullyQualifiedName()
                    )
                ) + argFmt

            }
            is BufferTraceInstrumentation.RawEventParams.ExitParams -> listOf()
            is BufferTraceInstrumentation.RawEventParams.LogTopics -> {
                event.params.topics.mapIndexed { ind, either ->
                    val t = when(ind) {
                        0 -> ContextLabel.LogLabel.LOG_TOPIC1
                        1 -> ContextLabel.LogLabel.LOG_TOPIC2
                        2 -> ContextLabel.LogLabel.LOG_TOPIC3
                        3 -> ContextLabel.LogLabel.LOG_TOPIC4
                        else -> error("implausible number of topics")
                    }
                    EventParam(
                        label = t,
                        value = either.formatScalarAs(EVMTypeDescriptor.BytesK(EVM_BYTES_IN_A_WORD)).leftOrNull()
                    )
                }
            }

            is BufferTraceInstrumentation.RawEventParams.CodeResult -> {
                event.context.results.mapIndexed { ind, res ->
                    EventParam(
                        label = ContextLabel.ResultValue(ind),
                        value = res.formatScalarAs(EVMTypeDescriptor.UIntK(EVM_BITWIDTH256)).leftOrNull()
                    )
                }
            }
        }
        val buffer = tryExtractBufferModel(lTraceEventMarker).leftOrNull()
        return BasicEvent(
            params = params,
            sort = sort,
            bufferRepr = buffer,
        ).toLeft()
    }

    private fun IndexedValue<Pair<VMParam, TACSymbol>>.format(): EventParam? {
        val (param, sym) = this.value
        val ind = index
        val ty = param.vmType
        if(ty !is EVMTypeDescriptor.EVMValueType) {
            return null
        }
        val fmt = sym.formatScalarAs(ty).leftOrNull() ?: return null
        val name = when(param) {
            is VMParam.Named -> param.name
            is VMParam.Unnamed -> "Argument $ind"
        }
        return EventParam(
            label = ContextLabel.InternalCallLabel.Arg(
                name = name,
                tooltip = if (param is VMParam.Unnamed) {
                    "No name was found for this parameter"
                } else {
                    ""
                }
            ),
            value = fmt
        )
    }

    private interface TraceSelector<T: MethodMarker> {
        val method: TraceEquivalenceChecker.Instrumentation<T, *>
        fun stop(where: LTACCmd): Boolean
        fun filter(blk: NBId): Boolean
    }

    /**
     * Before event at [reprMethod], find all prior calls/logs.
     */
    private fun <T: MethodMarker> getPriorTrace(
        reprMethod: TraceSelector<T>,
        commonItemHandler: (IEvent) -> IEvent
    ) : Either<List<IEvent>, String> {
        val methodStartBlock = vcProgram.blockgraph.entries.singleOrNull { (blk,succ) ->
            blk.calleeIdx == NBId.ROOT_CALL_ID && succ.singleOrNull()?.calleeIdx == reprMethod.method.inlinedCallId
        }?.value?.single() ?: return "Couldn't deduce start of method ${reprMethod.method.originalProgram.pp()}".toRight()
        if(methodStartBlock !in theModel.reachableNBIds) {
            return "No trace for ${reprMethod.method.originalProgram.pp()}".toRight()
        }
        val graph = vcProgram.analysisCache.graph
        val toRet = mutableListOf<IEvent>()
        var blockIt = methodStartBlock
        var eventOrd = 0
        while(true) {
            val block = graph.elab(blockIt)
            for(lc in block.commands) {
                if(reprMethod.stop(lc)) {
                    return toRet.toLeft()
                }
                if(instLevels != BufferTraceInstrumentation.TraceTargets.Calls) {
                    val te = lc.annotationView(BufferTraceInstrumentation.TraceIndexMarker.META_KEY)
                    if (te != null) {
                        val toAdd = when (val ex = extractEventData(reprMethod.method, te)) {
                            is MatchingEventData.Found -> traceMarkerToEvent(ex.what).toValue(
                                { it },
                                { Missing("Failed to resolve event ordinal $eventOrd: $it") })

                            MatchingEventData.Missing -> Missing("Couldn't resolve event ordinal $eventOrd")
                        }
                        eventOrd++
                        toRet.add(commonItemHandler(toAdd))
                        continue
                    }
                }
                val ce = lc.maybeAnnotation(BufferTraceInstrumentation.CallEvent.META_KEY)
                if(ce != null) {
                    val res = extractEnvironment(
                        graph = graph,
                        ce = ce,
                        where = lc,
                    )
                    toRet.add(res.let(commonItemHandler))
                    continue
                }
                val ie = lc.maybeAnnotation(CommonPureInternalFunction.ANNOTATION_META)
                if(ie != null) {
                    val params = ie.qualifiedMethodSignature.params.zip(ie.argSymbols).withIndex().monadicMap {
                        it.format()
                    }.orEmpty()
                    val rets = ie.qualifiedMethodSignature.resType.zip(ie.rets).withIndex().monadicMap { (ind, pair) ->
                        val (ty, sym) = pair
                        val fmt = sym.formatScalarAs(ty as EVMTypeDescriptor.EVMValueType).leftOrNull() ?: return@monadicMap null
                        EventParam(
                            label = ContextLabel.InternalCallLabel.ReturnValue(
                                ord = ind
                            ),
                            value = fmt
                        )
                    }.orEmpty()
                    toRet.add(
                        BasicEvent(
                            sort = BufferTraceInstrumentation.TraceEventSort.INTERNAL_SUMMARY_CALL,
                            bufferRepr = null,
                            params = listOf(
                                EventParam(
                                    ContextLabel.InternalCallLabel.Signature,
                                    ie.qualifiedMethodSignature.prettyPrintFullyQualifiedName()
                                )
                            ) + params + rets
                        ).let(commonItemHandler))
                    continue
                }
                val functionStart = lc.annotationView(INTERNAL_FUNC_START)
                if(functionStart != null) {
                    toRet.add(
                        Elaboration(
                            what = "Entering internal function ${functionStart.annotation.methodSignature.prettyPrintFullyQualifiedName()}"
                        )
                    )
                }
                val functionEnd = lc.annotationView(INTERNAL_FUNC_EXIT)
                if(functionEnd != null) {
                    toRet.add(
                        Elaboration(
                            what = "Leaving internal function ${functionEnd.annotation.methodSignature.prettyPrintFullyQualifiedName()}"
                        )
                    )
                }
            }
            blockIt = graph.succ(blockIt).singleOrNull {
                reprMethod.filter(it) && it in theModel.reachableNBIds
            } ?: return "Couldn't reach mismatch in ${reprMethod.method.originalProgram.pp()}".toRight()
        }
    }

    private fun <T: MethodMarker> TraceWithContext<T, *>.toSelector() = object : TraceSelector<T> {
        override val method: TraceEquivalenceChecker.Instrumentation<T, *>
            get() = context

        override fun stop(where: LTACCmd): Boolean {
            return event.vcProgramSite == where.ptr
        }

        override fun filter(blk: NBId): Boolean {
            return blk.calleeIdx == context.inlinedCallId
        }


    }

    /**
     * Try to explain what's missing and from which function.
     */
    private fun tryMissingInterpretation(
        methodAEvent: TraceWithContext<MethodMarker.METHODA, *>?,
        methodBEvent: TraceWithContext<MethodMarker.METHODB, *>?,
    ): EquivalenceChecker.SatInterpretation {
        val inputExplanation = getInputExplanation()
        val (_, foundMethod, event, mk) = if(methodAEvent != null) {
                MissingPayload(
                    missing = checkResult.programB.originalProgram,
                    found = checkResult.programA.originalProgram,
                    explain = MismatchExplanation::MissingInB,
                    lt = methodAEvent
                )
        } else {
            check(methodBEvent != null)
            MissingPayload(
                missing = checkResult.programA.originalProgram,
                found = checkResult.programB.originalProgram,
                explain = MismatchExplanation::MissingInA,
                lt = methodBEvent
            )
        }

        /**
         * The event we found in foundMethod that was missing
         */
        val basicEvent = traceMarkerToEvent(event.event).leftOr {
            return EquivalenceChecker.SatInterpretation.GaveUp(
                "Couldn't extract event data from ${foundMethod.pp()}: ${it.right()}",
                checkResult.ruleResult
            )
        }

        val priorEventsPrime = getPriorTrace(event.toSelector()) {
            it
        }.leftOrNull()

        return EquivalenceChecker.SatInterpretation.RealCounterExample(
            ruleCheckResult = checkResult.ruleResult,
            diffExplanation = mk(basicEvent),
            priorEventsA = priorEventsPrime,
            priorEventsB = null,
            inputExplanation = inputExplanation
        )

    }
}
