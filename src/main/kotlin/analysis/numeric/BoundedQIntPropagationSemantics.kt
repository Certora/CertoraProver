/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package analysis.numeric

import analysis.LTACCmd
import vc.data.TACSymbol
import java.math.BigInteger

/**
 * The basic implementation for [IPathSemantics] that propagate qualifier information.
 *
 * These semantics only work for types [I] that support the [BoundedQualifiedInt.withBoundAndQualifiers],
 * which is used to propagate bound and qualifier information induced by path conditions. The type of qualifiers
 * are [Q]; [IntQualifier] instances generated by the path conditions are injected into [Q] via the [adapter] (if
 * [Q] is a super type of [IntQualifier] then the identity function will suffice).
 */
abstract class BoundedQIntPropagationSemantics<I: BoundedQualifiedInt<I, Q, *>, Q: Qualifier<Q>, S, W>(
    propagator: QualifierPropagationComputation<I, S, W, Q>
) : QualifiedIntPropagationSemantics<I, S, W, Q>(propagator) {
    override fun applyPathInformation(toPropagate: Map<TACSymbol.Var, List<PathInformation<Q>>>, s: S, w: W, l: LTACCmd): S? {
        var st = s
        for((k, v) in toPropagate) {
            val curr = propagator.extractValue(k, s, w, l) ?: continue
            val (lb, ub, quals) = PathApplication.computePathInfo(curr, v) { p, i, x ->
                this.handlePath(p, i, x)
            }
            st = this.applyPath(k, curr, lb, ub, quals, st, l)
        }
        return st
    }

    open protected fun applyPath(k: TACSymbol.Var, curr: I, lb: BigInteger?, ub: BigInteger?, quals: Iterable<Q>, st: S, l: LTACCmd) : S {
        val x : IntApprox<*> = curr.x
        val currLb = x.getLowerBound()
        val currUb = x.getUpperBound()
        val newLb = when {
            lb == null -> currLb
            currLb == null -> lb
            else -> maxOf(lb, currLb)
        }
        val newUb = when {
            ub == null -> currUb
            currUb == null -> ub
            else -> minOf(ub, currUb)
        }
        val toAssign = if(newLb == null || newUb == null) {
            curr.withQualifiers(
                curr.qual + quals
            )
        } else {
            curr.withBoundAndQualifiers(
                lb = newLb,
                ub = newUb,
                quals = curr.qual + quals
            )
        }
        return assignVar(
            st, k, toAssign, l
        )
    }


    /**
     * A hook to interpret path information [pi] propagated onto [av]. This can generate new qualifiers
     * added into [selfQuals]
     */
    protected open fun handlePath(pi: PathInformation<Q>, av: I, selfQuals: MutableList<Q>) {

    }

    /**
     * Assign a new abstract value [I] to variable [lhs] in state [toStep]
     */
    abstract fun assignVar(toStep: S, lhs: TACSymbol.Var, toWrite: I, where: LTACCmd) : S
}
