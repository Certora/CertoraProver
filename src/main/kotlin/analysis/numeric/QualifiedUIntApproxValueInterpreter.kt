/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package analysis.numeric

import com.certora.collect.*
import vc.data.TACSymbol
import java.math.BigInteger

/**
 * An implementation of [IValueSemantics] which elaborates a value semantics in [delegate]. [IntQualifier]
 * instances generated by these semantics ar embedded into the domain of qualifiers (type [Q])
 * via [adapter] (if [Q] is a supertype of [IntQualifier] the identity function will suffice).
 *
 * Like the [IValueSemantics], it is assumed that [I] contains an approximation (of type [T]) for numeric values.
 * Instances of [I] also have a set of qualifiers [Q].
 */
@Deprecated("Use explicit qualifier semantics")
open class QualifiedUIntApproxValueInterpreter<in S, in W, @Treapable Q: Qualifier<Q>, I: QualifiedInt<I, T, Q>, T: UIntApprox<T>>(
    protected val delegate: IValueSemantics<S, I, W>,
    private val adapter: (Iterable<IntQualifier>) -> Iterable<Q>
) : IValueSemantics<S, I, W> by object : PathConditionQualifierInterpreter<S, W, Q, I, T>(
    delegate = object : BasicMathCombinator<S, W, Q, I, T>(delegate) {
    override fun maskedOf(bitCount: Int, o2: TACSymbol.Var): Q? {
        return adapter(listOf(IntQualifier.MaskedOf(bitWidth = bitCount, op = o2))).singleOrNull()
    }

    override fun multipleOf(multOf: BigInteger): Q? {
        return adapter(listOf(IntQualifier.MultipleOf(multOf))).singleOrNull()
    }
}) {
    override fun condition(cond: ConditionQualifier.Condition, op1: TACSymbol, op2: TACSymbol): Q? {
        return adapter(listOf(
            IntQualifier.ConditionVar(
                condition = cond, op1 = op1, op2 = op2
            )
        )).singleOrNull()
    }

    override fun conjunction(
        connective: LogicalConnectiveQualifier.LBinOp,
        op1: TACSymbol.Var,
        op2: TACSymbol.Var
    ): Q? {
        return adapter(listOf(
            IntQualifier.LogicalConnective(
                connective = connective,
                op1 = op1,
                op2 = op2,
                applyNot = false
            )
        )).singleOrNull()
    }

    override fun flip(toFlip: Q): Q? {
        return (toFlip as? Flippable)?.flip()?.let(::listOf)?.let(adapter)?.singleOrNull()
    }

}
