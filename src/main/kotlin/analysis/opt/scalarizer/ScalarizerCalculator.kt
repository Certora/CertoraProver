/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY, without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR a PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package analysis.opt.scalarizer

import algorithms.UnionFind
import datastructures.stdcollections.*
import tac.Tag
import utils.*
import vc.data.*
import vc.data.tacexprutil.getFreeVars
import vc.data.tacexprutil.isConst

/**
 * Detects bytemaps that are accessed only at constant locations.
 */
class ScalarizerCalculator private constructor(code: CoreTACProgram) {

    private val g = code.analysisCache.graph

    /**
     * Equivalence classes of bytemap bases. Maps are equivalent if one is assigned to another, via a simple
     * assignment, a store, or a longstore.
     */
    private val uf = UnionFind<TACSymbol.Var>()

    /** bytemap bases that surely don't qualify */
    private val badBases = mutableSetOf<TACSymbol.Var>()

    private fun bad(vararg bases: Set<TACSymbol.Var>?) {
        bases.filterNotNull().forEach { badBases += it }
    }

    /**
     * Marks bases as bad if needed.
     * Returns the set of bytemap bases that [e] may be equivalent to, and null these are "bad".
     */
    private fun processExp(e: TACExpr): Set<TACSymbol.Var>? {
        val ops = e.getOperands().map(::processExp)
        return when (e) {
            is TACExpr.Sym.Var ->
                if (e.tag is Tag.ByteMap) {
                    setOf(e.s)
                } else {
                    emptySet()
                }

            is TACExpr.TernaryExp.Ite ->
                if (ops[1] == null || ops[2] == null) { // then & else
                    bad(ops[1], ops[2])
                    null
                } else {
                    ops[1]!! + ops[2]!!
                }

            is TACExpr.LongStore ->
                if (ops[0] == null || ops[2] == null ||
                    !e.length.isConst || !e.dstOffset.isConst || !e.srcOffset.isConst
                ) {
                    bad(ops[0], ops[2])
                    null
                } else {
                    ops[0]!! + ops[2]!!
                }

            is TACExpr.Select -> {
                if (e.base.tag is Tag.ByteMap && !e.loc.isConst) {
                    bad(ops[0])
                }
                setOf()
            }

            is TACExpr.Store ->
                if (e.base.tag is Tag.ByteMap) {
                    if (!e.loc.isConst) {
                        bad(ops[0])
                        null
                    } else {
                        ops[0]
                    }
                } else {
                    setOf()
                }

            is TACExpr.MapDefinition,
            is TACExpr.QuantifiedFormula -> {
                val scopedBases = e.getFreeVars().filter { it.tag is Tag.ByteMap }
                badBases += scopedBases
                if (e is TACExpr.MapDefinition && scopedBases.isNotEmpty()) {
                    null // in such a case the map generated by the mapDefinition can't be scalarized.
                } else {
                    setOf()
                }
            }

            else -> setOf()
        }
    }

    fun processCmd(cmd: TACCmd.Simple) {
        when (cmd) {
            is TACCmd.Simple.AssigningCmd.AssignExpCmd -> {
                val bases = processExp(cmd.rhs)
                if (cmd.lhs.tag is Tag.ByteMap) {
                    when {
                        bases == null -> bad(setOf(cmd.lhs))
                        bases.isNotEmpty() -> {
                            uf.union(bases)
                            uf.union(bases.first(), cmd.lhs)
                        }
                    }
                }
            }

            is TACCmd.Simple.AssumeExpCmd ->
                processExp(cmd.cond)

            is TACCmd.Simple.AssigningCmd.ByteStore -> {
                uf.union(cmd.lhs, cmd.base)
                if (cmd.loc !is TACSymbol.Const) {
                    badBases += cmd.lhs
                }
            }

            is TACCmd.Simple.AssigningCmd.ByteLoad -> {
                if (cmd.loc !is TACSymbol.Const) {
                    badBases += cmd.base
                }
            }

            is TACCmd.Simple.AssigningCmd.ByteStoreSingle -> {
                badBases += cmd.lhs
                badBases += cmd.base
            }

            is TACCmd.Simple.ByteLongCopy -> {
                uf.union(cmd.srcBase, cmd.dstBase)
                if (cmd.srcOffset !is TACSymbol.Const ||
                    cmd.dstOffset !is TACSymbol.Const ||
                    cmd.length !is TACSymbol.Const
                ) {
                    badBases += cmd.srcBase
                }
            }

            is TACCmd.Simple.AssigningCmd.AssignHavocCmd ->
                Unit

            else ->
                badBases += cmd.freeVars().filter { it.tag is Tag.ByteMap }
        }
    }

    private fun process(): MutableSet<TACSymbol.Var> {
        g.commands.forEach {
            processCmd(it.cmd)
        }
        val badReps = badBases.mapToSet { uf.find(it) }
        val goodReps = uf.getAllRepresentatives() - badReps
        return goodReps.flatMapToSet(uf::getEquivalenceClass)
    }

    companion object {
        fun goodBases(code: CoreTACProgram) =
            ScalarizerCalculator(code).process()
    }
}
