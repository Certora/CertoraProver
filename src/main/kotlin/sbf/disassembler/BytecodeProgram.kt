/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package sbf.disassembler

import sbf.callgraph.MAX_SYSCALL_FUNCTIONS
import sbf.sbfLogger
import datastructures.stdcollections.*

typealias FunctionId = Int

data class SbfFunction(val name:String, val entryPoint: ElfAddress?) {
    override fun toString(): String {
        return if (entryPoint !=null) {
            "$name at $entryPoint"
        } else {
            name
        }
    }
}

interface SbfFunctionManager {
    fun getFunction(id: FunctionId): SbfFunction?
    fun getFunction(entryPoint: ElfAddress): SbfFunction?
    fun warnDuplicateSymbols()
}

/***
 *  The manager contains all functions defined in the program.
 *  @params names is a dictionary that assigns a name to an address.
 *  This dictionary is generated by the disassembler.
 */
class MutableSbfFunctionManager(private val start: ElfAddress, private val names: Map<ElfAddress, String> = mapOf())
    : SbfFunctionManager {
    /**
     * Important: to avoid clashes with Solana syscalls, all function identifiers
     * start at MAX_SYSCALL_FUNCTIONS.
     */
    private val functionIndex: MutableMap<String, FunctionId> = mutableMapOf()
    private val functions: ArrayList<SbfFunction> = ArrayList()
    // To avoid duplicate warning messages
    private val duplicateSymbols: MutableMap<String, MutableSet<ElfAddress>> =  mutableMapOf()
    private fun getIndex(idx: FunctionId): FunctionId {
        return idx - MAX_SYSCALL_FUNCTIONS
    }

    /**
     * Creates a new SbfFunction object from the pair (name, entryPoint),
     * and return a unique identifier associated with the new function. If the pair (name, entryPoint)
     * has been already added then no insertion is done.
     *
     * @param name is the function name
     * @params entryPoint is the initial address of the function. It can be null if the code of the
     * function is not available.
     */
    fun addFunction(name:String, entryPoint: ElfAddress?): FunctionId {
        val idx = functionIndex[name]
        if (idx != null) {
            /**
             *  Check that there is not another function with same name but different
             *  entry point address.
             **/
            val function = functions[getIndex(idx)]
            val functionEntryPoint = function.entryPoint
            if (entryPoint != null && functionEntryPoint != entryPoint) {
                // Duplicate symbols: we choose the first definition and record it for printing a warning msg.
                duplicateSymbols[name]?.add(entryPoint)
            }
            return idx
        } else {
            val function = SbfFunction(name, entryPoint)
            val newIdx = functions.size + MAX_SYSCALL_FUNCTIONS
            functionIndex[name] = newIdx
            functions.add(function)
            if (entryPoint != null) {
                duplicateSymbols[name] = mutableSetOf(entryPoint)
            }
            return newIdx
        }
    }

    /**
     *  Create a new SbfFunction object from entryPoint, and return a unique identifier associated to
     *  the new function.
     *
     *  @params entryPoint is the initial address of the function.
     */
    fun addFunction(entryPoint: ElfAddress): FunctionId {
        val name = names[entryPoint] ?:
            throw DisassemblerError("cannot find a name for entry point $entryPoint")
        return addFunction(name, entryPoint)
    }

    override fun getFunction(id: FunctionId): SbfFunction? {
        val idxAdjusted = getIndex(id)
        if (idxAdjusted < 0 || idxAdjusted >= functions.size) {
            return null
        }
        return functions[idxAdjusted]
    }

    override fun getFunction(entryPoint: ElfAddress): SbfFunction? {
        val name = names[entryPoint] ?: return null
        val id = functionIndex[name] ?: return null
        return getFunction(id)
    }

    override fun warnDuplicateSymbols() {
        val dupSymbols = duplicateSymbols.filter {
            it.value.size > 1
        }.map {
            Pair(it.key, it.value.map { offset -> start + offset})
        }

        if (dupSymbols.size == 1) {
            val (symName, addresses) = dupSymbols.first()
            sbfLogger.warn {"Duplicate symbol $symName in .so file at addresses: $addresses"}
        } else if (dupSymbols.size > 1){
            val strBuilder = StringBuilder()
            strBuilder.append("Duplicate symbols in .so file:\n")
            for ((symName, addresses) in dupSymbols) {
                strBuilder.append("\t$symName at addresses ${addresses}\n")
            }
            sbfLogger.warn {strBuilder.toString()}
        }
    }
}

data class BytecodeProgram(val entriesMap: Map<String, ElfAddress>,
                           val functionMan: MutableSbfFunctionManager,
                           val program: List<SbfBytecode>,
                           val globalsMap: GlobalVariableMap,
                           // each element in relocatedCalls is an index in program
                           // Strictly, we don't really need this because for all resolved
                           // calls via relocation the value of the IMM field should be -1.
                           val relocatedCalls : Set<Int>)
