# Solana Front-end #

## Description ##

This directory contains all the code to translate SBF (Solana Binary Format) files to TAC  programs.

## SBF Files ##

Although Solana programs are written in Rust, this front-end processes
ELF (Executable and Linkable Format) binary files as input. The Clang
compiler translates Rust source code into SBF programs—a
Solana-specific variant of eBPF (extended Berkeley Packet
Filter)—which are encoded in ELF format.


Historical Context: When development began, Clang compiled to eBPF. In
late 2022, Solana began migrating to SBF (Solana Binary Format),
introducing multiple target architectures including `sbfv1` and `sbfv2`.


Architecture Support: While the `--arch flag` from `cargo-certora-sbf` accepts multiple architecture options,
this front-end currently supports only `sbfv1`/`sbf`:

```
--arch <ARCH>
      Specify SBF/SBPF architecture

      [default: sbf]

      Possible values:
      - sbf: sbfv1 from platform tools <= 1.41 [SUPPORTED]
      - v0:  SBPF v0 [NOT SUPPORTED]
      - v1:  SBPF v1 [NOT SUPPORTED]
      - v2:  SBPF v2 [NOT SUPPORTED]
      - v3:  SBPF v3 [NOT SUPPORTED]
```

## Directory Structure ##

The entry point of the Solana front-end is the file
`SolanaEntryPoint.kt`. This entry point takes as input a filename
containing the ELF file and outputs a singleton list of
`CoreTACProgram`.

The workflow is the following:

1. [`disassembler`] The class `ElfDisassembler` parses the ELF file and translates it
   into a `BytecodeProgram` (a sequence of bytecodes).  The disassembler
   also identifies the functions defined in the program, and which
   bytecodes belong to which functions.

   The function `bytecodeToSbfProgram` translates `BytecodeProgram`
   into `SbfProgram` (a list of `SbfInstruction`).

2. [`cfg`] The class `SbfCFG` represents a control-flow graph where
   nodes are `SbfBasicBlock` and edges denote that the control flow
   from one block to another. A basic block consists of a sequence of
   `SbfInstruction`.

3. [`callgraph`] The function `sbfProgramToSbfCFGs` first translates
   each function into a separate CFG (`SbfCFG`). A `SbfCFG` can have
   a call to another function modeled by another `SbfCFG`. Then, it
   translates the `SbfProgram` into a `SbfCallGraph` where nodes are
   CFGs (functions) and edges are calls between functions.

4. [`inliner`] The function `inline` takes a `SbfCallGraph` and
   returns another `SbfCallGraph`.  The difference between the input
   and the output is that `inline` will try to inline all function
   calls. Thus, the output call graph will be a singleton except in
   presence of recursive functions or **black-listed** functions. For
   these, the inliner adds empty stubs which is unsound in general unless
   some summary is added in the __summary environment file__.
   The maximum depth call in Solana is fixed to 64, so in principle,
   we can always inline recursive functions although the front-end
   does not do it at the moment. The list of black-listed functions is
   defined in the __inlining environment file__.

5. [`slicer`] The function `sliceAssertions` removes any code reachable from
   __entrypoint__ function (i.e., the rule under verification) that cannot affect the evaluation of any
   user-defined assertion. We run two different
   slicers: one purely syntactic (`ConeOfInfluenceAnalysis`) and a
   semantic one (`SemanticConeOfInfluenceAnalysis`). The semantic
   slicing performs a forward+backward analysis on the CFG using a
   simple scalar domain (`memory/ScalarDomain.kt`) for the forward
   pass and a specialized domain called `NPDomain` for the backward
   pass.

6. [`analysis`] `MemoryAnalysis.kt` analyzes __entrypoint__ function by running a forward abstract interpreter using
   `domains/memory/MemoryDomain` as an abstract domain. Recall that at this point all
   intra-contract calls should have been inlined.

7. [`domains/memory`] `MemoryDomain.kt` is a reduced product of two
   sub-domains: `PointerDomain.kt` and `ScalarDomain.kt`. Read
   documentation in `PointerDomain.kt` for more details. The goal of
   `MemoryDomain` is to ensure that memory is used in a way that does
   not break any analysis assumptions and statically partition all
   memory used by a program into disjoint memory sub-regions.

8. [`tac`] Translation to TAC. The function `sbfCFGsToTAC` translates
   an inlined/sliced `SbfCallGraph` (as generated by step 5) to a
   list of `CoreTACProgram`. Note that a `CoreTACProgram` does not
   support call instructions.  Therefore, it is important that the
   step 4 inlines all intra-contract calls. The input
   `SbfCallGraph` should contain only the __entrypoint__ function and
   empty stubs for functions that were not inlined. In this step, we
   assume that the empty stubs are side-effect-free functions which
   obviously might not be true, in general.

   Crucially, the TAC translation uses information from step 6 to
   encode memory instructions.

   All the work is done in `TACMemorySplitter.kt`
   The key is to use the information inferred by `MemoryDomain`.
   In principle, each point-to graph node (`PTANode`) is translated to
   a TAC `ByteMap`. However, it is important to use scalar variables
   whenever possible. Currently, the program stack is scalarized.

## (Some) Limitations ##

1. Limited support for CPIs (Cross Program Invocations).
2. The `MemoryDomain` throws runtime exceptions when it cannot well
  type a program and thus, it cannot ensure a sound translation to
  TAC. The most common causes for the analysis to fail are:
   - lost provenance of a pointer,
   - a memory read does not match (same number of bytes) the last written to the same location, and
   - memory write on stack without knowing statically the exact location.
