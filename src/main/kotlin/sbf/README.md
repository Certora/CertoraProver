# Solana Front-end #

## Description ##

This directory contains all the code to translate SBF (Solana Binary Format) files to TAC  programs.

## SBF Files ##

Although Solana programs are written in Rust, the input of
the front-end is an ELF file.  The Clang compiler is used to translate
the source code into SBF (Solana-specific variant of eBPF) programs which are written in ELF
format. When we started, Clang compiled to SBF. Since October
2022, Solana started migrating to SBF (Solana Binary Format). There
are currently two target architectures: `sbfv1` and `sbfv2`. **This front-end
supports only `sbfv1`**.

The major differences between `sbfv1` and `sbfv2` is that `sbfv2`
supports **signed division** and more importantly, **dynamic-size
stack frames** (https://github.com/solana-labs/solana/issues/23481).

## Directory Structure ##

The entry point of the Solana front-end is the file
`SolanaEntryPoint.kt`. This entry point takes as input a filename
containing the ELF file and outputs a singleton list of
`CoreTACProgram`.

The workflow is the following:

1. [`disassembler`] The class `ElfDisassembler` parses the Elf file and translates it
   into a `BytecodeProgram` (a sequence of bytecodes).  The disassembler
   also identifies the functions defined in the program, and which
   bytecodes belong to which functions.

   The function `bytecodeToSbfProgram` translates `BytecodeProgram`
   into `SbfProgram` (a list of `SbfInstruction`).

2. [`cfg`] The class `SbfCFG` represents a control-flow graph where
   nodes are `SbfBasicBlock` and edges denote that the control flow
   from one block to another. A basic block consists of a sequence of
   `SbfInstruction`.

3. [`callgraph`] The function `sbfProgramToSbfCFGs` first translates
   each function into a separate CFG (`SbfCFG`). A `SbfCFG` can have
   a call to another function modeled by another `SbfCFG`. Then, it
   translates the `SbfProgram` into a `SbfCallGraph` where nodes are
   CFGs (functions) and edges are calls between functions.

4. [`inliner`] The function `inline` takes a `SbfCallGraph` and
   returns another `SbfCallGraph`.  The difference between the input
   and the output is that `inline` will try to inline all function
   calls. Thus, the output call graph will be a singleton except in
   presence of recursive functions or **black-listed** functions. For
   these, the inliner adds empty stubs which is unsound in general unless
   some summary is added in the __summary environment file__.
   The maximum depth call in Solana is fixed to 64, so in principle,
   we can always inline recursive functions although the front-end
   does not do it at the moment. The list of black-listed functions is
   defined in the __inlining environment file__.

5. [`slicer`] The function `sliceAssertions` removes any code reachable from
   __entrypoint__ function (i.e., the rule under verification) that cannot affect the evaluation of any
   user-defined assertion (`CVT_assert`). We run two different
   slicers: one purely syntactic (`ConeOfInfluenceAnalysis`) and a
   semantic one (`SemanticConeOfInfluenceAnalysis`). The semantic
   slicing performs a forward+backward analysis on the CFG using a
   simple scalar domain (`memory/ScalarDomain.kt`) for the forward
   pass and a specialized domain called `NPDomain` for the backward
   pass.

6. [`analysis`] `MemoryAnalysis.kt` analyzes __entrypoint__ function by running a forward abstract interpreter using
   `domains/memory/MemoryDomain` as an abstract domain. Recall that at this point all
   intra-contract calls should have been inlined.

7. [`domains/memory`] `MemoryDomain.kt` is a reduced product of two
   sub-domains: `PointerDomain.kt` and `ScalarDomain.kt`. Read
   documentation in `PointerDomain.kt` for more details. The goal of
   `MemoryDomain` is to ensure that memory is used in a way that does not break any analysis assumptions
   (e.g., no memory overlaps) and statically partition all memory used by a
   program into disjoint memory sub-regions.

8. [`tac`] Translation to TAC. The function `sbfCFGsToTAC` translates
   an inlined/sliced `SbfCallGraph` (as generated by step 5) to a
   list of `CoreTACProgram`. Note that a `CoreTACProgram` does not
   support call instructions.  Therefore, it is important that the
   step 4 inlines all intra-contract calls. The input
   `SbfCallGraph` should contain only the __entrypoint__ function and
   empty stubs for functions that were not inlined. In this step, we
   assume that the empty stubs are __non-op__ functions which
   obviously might not be true, in general. Thus, as part of this
   translation we might want to include summarization of those
   functions but this is NOT done at the moment.

   Crucially, the TAC translation uses information from step 6 to
   encode memory instructions.

   All the work is done in `TACMemorySplitter.kt`
   The key is to use the information inferred by `MemoryDomain`.
   In principle, each point-to graph node (`PTANode`) is translated to
   a TAC `ByteMap`. However, it is important to use scalar variables
   whenever possible. Currently, the program stack is scalarized.

## (Some) Limitations ##

1. No support for dynamic-size stack frames.
2. No support for CPI (Cross Program Invocations).
3. The `MemoryDomain` throws runtime exceptions when it cannot well
  type a program and thus, it cannot ensure a sound translation to
  TAC. The most common causes for the analysis to fail are:
   - lost provenance of a pointer,
   - a memory read does not match (same number of bytes) the last written to the same location, and
   - memory write on stack without knowing statically the exact location.
