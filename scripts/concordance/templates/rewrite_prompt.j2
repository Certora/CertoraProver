<context>
The following contract "harnesses" a problematic internal function which causes a pointer analysis on EVM bytecode to fail.
This may be due to non-standard operations on memory that occcurs in memory blocks, or due to imprecision in the
pointer analysis.
</context>

<task>
Rewrite the *internal* function so that it is semantically equivalent but is more amenable to static analysis.
Common problems include:
  - Inline assembly with direct memory manipulation
  - Unchecked array/memory access
  - Pointer arithmetic that the analyzer cannot track
  - Non-standard memory layout assumptions
Your rewrite should satisfy the following constraints:
{%include "rewrite_constraints.j2" %}
 - It must be semantically equivalent to the original function.
 - Wherever possible, eschew the use of inline assembly in favor of more straightforward, standard Solidity
 - You may ignore the gas implications of any code you write: code that is accepted by the pointer analysis is
   preferable to gas efficient code. However, you should consider that the original code may by optimized for gas
   consumption, which should inform your understanding of its intent
"Semantic equivalence" means the following:
- Functions produce the same return value
- The functions have exactly the same observable effects. These external effects are:
  - Reverting (including the revert data)
  - EVM level returns (that is, the return opcode)
  - External calls
  - Changes to storage
  - emitted logs/events

In other words, if the original function reverts, the rewritten function must also revert with
the same buffer.
For the purposes of this rewrite, you can ignore the possibility of out-of-gas exceptions.
Similarly, the rewrite must emit the same log events (if any) and in the same order.
The rewrite must also make the same external calls, and make the same modifications to storage.
However, remember that if both functions revert, any other side effects (external calls, storage changes, etc.)
are mooted.
</task>

<VFS>
You will be operating on a VFS which provides a virtual file system on which you can
store your "rewrite harness". All of the tools which accept code during this task
read their inputs from the VFS. The "original harness" is already on the VFS,
you only need to put the code you generate onto the VFS.
</VFS>

<algorithm>
   <input>An "original harness" around a "problematic internal function"</input>
   <output>The rewritten "better function"</output>
   <steps>
   1. Analyze the "problematic internal function" in the "original harness" to understand its behavior.
      Pay close attention to its revert conditions and side effects
   2. Generate a rewrite of the internal function called the "better function", which uses straight-forward
      solidity while preserving equivalence to the "problematic internal function"
      a. Keep track of and remember any extra definitions required for this "better function" rewrite.
   3. Adapt the "original harness" into a "rewrite harness" by replacing the "problematic internal function" with the
      "better function" generated in step 2 and changing the name of the "original harness" contract.
      Incorporate any definitions generated by step 2.a
   4. Put the "rewrite harness" onto the VFS.
   5. Check that the "rewrite harness" is type correct and syntax correct using the VFS solidity compiler.
   6. (OPTIONAL) If appropriate, try to use the differential fuzz tester to find if the rewrite is not equivalent.
      a. If the rewrite is judged to be not equivalent on some concrete counterexample, analyze the counterexample,
         identify the defect in your implementation. Update the "rewrite harness" to reflect this change, and goto step 4.
      b. If the differential fuzz tester is not applicable, or it succeeds, go to step 7
      c. If the differential fuzz tester fails to run with an error, go to step 7
   7. Check that the "rewrite harness" and "original harness" are semantically equivalent using the equivalence checker.
   8. Interpret the results of the equivalence checker:
      a. If the result is 'Equivalent', then go to step 9
      b. Otherwise, examine the explanation provided by the equivalence checker for why the two functions are not
         equivalent. Incorporating this feedback, adjust the definition of "better function" within the
         "rewrite harness", and go to step 4.
   9. Invoke the qualitative feedback tool to check for adherence to the requirements in this prompt
   10. Interpret the results of the feedback:
      a. If the result is "ACCEPTED", go to step 11
      b. If the result is "ADVICE", consider the suggestions included in the feedback and determine if they should
         be followed. If so, update the "rewrite harness", and go to step 4
      c. If the result is "REJECTED", interpret the reasons for rejection along with suggested fixes.
         Incorporate this feedback into the "rewrite harness", being sure to not change equivalence, and go to step 4.
   10. Output the definition of the "better function" along with any of the extra definitions that are necessary.
   </steps>
</algorithm>

<guidance>
   <important>
     When invoking the equivalence checker, you *may not* change the external entry point of
     either the "original harness" or the "rewrite harness"
   </important>
   <important>
     The task is complete if, and only if, the equivalence checker returns the string 'Equivalent'.
   </important>
   <important>
     If the output is *NOT* 'Equivalent' and is a counterexample which appears to show identical behavior, your task is NOT complete.
     You MAY NOT assume that the implementations are actually equivalent. Instead this suggests a bug in the equivalence checker;
     consult the user for help.
   </important>
   <important>
      If the qualitative feedback tool suggests changes outside of the "problematic internal function" of the "rewrite harness",
      ignore that feedback.
   </important>
   <important>
      The qualitative feedback tool is stateless; if you try to take its suggestions and it does not work, ask the user
      for permission to disregard that feedback. On any future invocations of the qualitative feedback tool, you may
      ignore feedback that you have been instructed to disregard.
   </important>
   <advice>
     In the event a conflict between the qualitative feedback tool and the equivalence checker, immediately consult the user
     using the "human in the loop" tool.
   </advice>
   {% include 'code_requirements.j2' %}
   <reminder>
     When adapting the "original harness" to check equivalence, you **should** change the name of the harnessing
     contract.
   </reminder>
   <tool_advice>
      You **should** check that your rewrite harness is type and syntax correct using the solidity compiler.
   </tool_advice>
   <tool_advice>
      You are an automated tool, and should only use the the human_in_the_loop tool as a last resort to get "unstuck".
      Be sure to iterate on a particular issue a few times before asking the user for help.
    </tool_advice>
    <reminder>
      The "original harness" provided as input is already on the VFS. You only need to call `put_file` to update the
      "rewritten harness". The VFS is persistent, so you only need to put the file ONCE
      before calling the solidity compiler, the equivalence checker, and the qualitative feedback tools in the prescribed sequence.
    </reminder>
</guidance>
