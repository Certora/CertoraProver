The following task is to help adapt code for use in differential testing of Solidity code.
There exists a contract `{{ harness }}` with an external entry
point with the following ABI: `{{ sig }}`. This
external entry point will be invoked by a fuzzer, and the its (random) arguments are passed
 s-is to the following *internal* function:
{{code}}

You must produce an *internal* function called `buildBuffer` which has the *exact same* parameter types
as the above internal function. `buildBuffer` *must* return a `bytes memory` buffer which encodes a call to the
ABI signature `{{ sig }}`. In addition,
analyze the internal function implementation and identify any requirements on arguments that are UNLIKELY to be 
satisfied by random inputs generated by a fuzzer. For example, relational properties between arguments 
(e.g., one argument must be multiple of another argument, correlation between array lengths etc.) or structural properties of aggregate structures
(e.g., specific requirements on the lengths of arrays, bytes arrays being properly ABI encoded, etc.).
For an example of a requirement that is LIKELY to be satisfied by random inputs, something like require(sender != address(0)) is 
very likely to be satisfied, as most addresses are non-zero. In addition, identify any cases
where argument values might easily trigger an out-of-gas exception and bound this argument appropriately.
For example, if a `uint` argument to an internal function is used as the number of iterations on a for-loop,
extremely large values will lead to out-of-gas.

When building the buffer in `buildBuffer` be sure to *adapt* the provided arguments to fit these requirements.
You may NOT add any extra arguments to the function or rely on any piece of state, any adaptation must be done
with JUST the arguments provided.

To summarize:
You must write a `buildBuffer` function which accepts the same arguments as the provided internal function,
and adapts randomly chosen fuzzer arguments to fit the non-trivial requirements of the internal function,
if any. After any adapting, use `abi.encodeCall` to construct a bytes array which encodes calling
`{{ sig }}` with the adapted arguments.

IMPORTANT:
* The output of this task is *JUST* the internal function `buildBuffer`, do NOT include any surrounding contract
  code, or ANY extra definitions.
* The output of this task should be PURE Solidity
* Do NOT include any commentary
* Using markdown is STRICTLY PROHIBITED
