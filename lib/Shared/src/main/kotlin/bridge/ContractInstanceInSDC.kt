/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

@file:UseSerializers(BigIntegerSerializer::class)

package bridge

import algorithms.TopologicalOrderException
import algorithms.topologicalOrder
import bridge.types.SolidityTypeDescription
import com.certora.collect.*
import compiler.*
import datastructures.stdcollections.*
import kotlinx.serialization.Serializable
import kotlinx.serialization.UseSerializers
import log.*
import scene.CONSTRUCTOR
import scene.VYPER_CONSTRUCTOR
import utils.*
import java.math.BigInteger

private val logger = Logger(LoggerTypes.COMMON)

fun sortContractsByStateLinks(unsorted: List<ContractInstanceInSDC>): List<ContractInstanceInSDC> {
    fun contractToKey(c: ContractInstanceInSDC): BigInteger = c.getAddressAsInteger()
    fun keyToContract(k: BigInteger): ContractInstanceInSDC = unsorted.find { it.getAddressAsInteger() == k }!!
    fun keyToName(k: BigInteger): String = keyToContract(k).name

    val keys = unsorted.map { contractToKey(it) }
    logger.info { "Keys: ${keys.map { keyToName(it) }}" }

    // we start with the links to relation
    val links = mutableMapOf<BigInteger, Set<BigInteger>>()
    unsorted.forEach { c ->
        val linksFromC = c.state.values.filter { it in keys }
        links[contractToKey(c)] = linksFromC.toSet()
    }
    logger.info { "All links: ${links.mapKeys { keyToName(it.key) }.mapValues { it.value.map { v -> keyToName(v) } }}}" }

    return try {
        topologicalOrder(links.toMap())
            .map { keyToContract(it) }
    } catch (e: TopologicalOrderException) {
        Logger.alwaysWarn("Links have a cyclic dependency: ${e.message}")
        unsorted
    }
}

val defaultSourceLanguage = SourceLanguage.Solidity

@Serializable
data class ContractExtension(
    val extension: ContractInstanceInSDC,
    val exclusion: Set<String>
)

@Serializable
data class LocalAssignmentSourceHint(
    val sourceLoc: SourceIdentifier,
    val lhs: String
)

/**
 * NB: (alex:) don't change field names or types here unless you know what you're doing, apparently they're tied to
 * some external (as in: from solidity compiler or so) serialization convention.
 *
 * @param allMethods this includes ALL methods relevant to the compilation of the SDC for which this is the primary
 *                   contract (i.e. any internal or external function that could end up being in some nested call).
 *                   The methods field only contains external functions, internalFunctions may include duplicate
 *                   instances for different bytecode copies. The purpose of this field is is to reflect all methods
 *                   available from the source code (minus overrides) to determine possible ambiguities during type
 *                   checking. Specifically, there is one copy for each unique signature according to internal typing
 *                   rules.
 */
@Serializable
@Treapable
data class ContractInstanceInSDC(
    val name: String, // contract name
    val original_file: String, // original path of file
    val lang: SourceLanguage = defaultSourceLanguage, // high-level language, current options are "Solidity" or "Vyper" or "Unknown" (if raw bytecode) - See SourceLanguage. Default is solidity.
    val file: String, // fetched file (i.e. when copying to .certora_config, may get a new name ensuring uniqueness
    val address: BigInteger /*address*/,
    val is_static_address: Boolean = false, // if address field was set by user's configuration (so it's not an autogenerated instanceId)
    val methods: List<Method>,
    val bytecode: String,
    val constructorBytecode: String = "", // no constructor bytecode in solc4.25 for example
    val srcmap: String,
    val varmap: String = "",
    val constructorSrcmap: String = "",
    val storageLayout : StorageLayout?,
    val transientStorageLayout : StorageLayout? = null,
    // we make this a set in case the build script gives us multiple instances of the same type description
    // yes we could remove the duplicates on the python side but that would require overriding equality and hash of
    // our python objects which is messy
    val solidityTypes: Set<SolidityTypeDescription>,
    // map from slot to instanceId to link to
    val state: Map<BigInteger, BigInteger> = mapOf(),
    // biginteger is the instanceId
    val structLinkingInfo: Map<String, BigInteger> = mapOf(),
    // value is a biginteger representing the instanceId
    val legacyStructLinking: Map<BigInteger, BigInteger> = mapOf(),
    val srclist: Map<Int, String> = mapOf(),
    val linkCandidates: Map<String/*signature of function we want to help inline in*/,List<String>/*list of candidate signatures to inline*/> = mapOf(),
    val immutables: List<ImmutableReference> = listOf(),
    val allMethods: List<Method> = listOf(),
    val internalFunctions: Map<String, MethodInContract> = mapOf(),
    /**
     * If any `create()` call in the EVM bytecode has any element of [prototypeFor] as its prefix,
     * then treat that create call as creating an instance of this contract
     */
    val prototypeFor: List<String> = listOf(),
    /**
     * The source dir relative to which we resolve contract files' source maps.
     * Used to show the user precise snippets from autofinder instrumented files, but with original 'pristine' paths
     */
    val sourceDir: String = ".",
    /* new fields 27 Feb 2024 - some already populated by certoraRun */
    val compilerName: String = defaultSourceLanguage.baseCompilerExecutableName!!,
    val compilerVersion: String = "",
    val compilerParameters: CompilerParameters? = null,
    val sourceBytes: SourceBytes? = null,
    val extensionContracts: List<ContractExtension> = listOf(),
    /**
     * The source dir relative to which we resolve source maps for source hints.
     * The hints are computed based on the original files, so we need to keep it too
     */
    val origSourceDir: String = ".",
    val localAssignments: Map<String, LocalAssignmentSourceHint> = emptyMap(),
    val internalFunctionStarts: List<Int> = listOf()
): SerializableWithAdapter {

    override fun hashCode() = hash {
        it + name + original_file + lang + file + address + methods + bytecode + constructorBytecode + srcmap +
        varmap + constructorSrcmap + storageLayout + state + structLinkingInfo + legacyStructLinking +
            srclist + linkCandidates + immutables + allMethods + internalFunctions + is_static_address + sourceBytes + internalFunctionStarts
        // no need to include compiler name and flags, those all impact the bytecode and constructorBytecode
    }

    override fun toString(): String {
        return "contract $name"
    }

    private class Adapter(c: ContractInstanceInSDC? = null) : SerializationAdapter<ContractInstanceInSDC>(
        serializer(), c)

    override fun writeReplace(): Any = Adapter(this)

    fun getAddressAsInteger(): BigInteger {
        return address
    }

    private fun getConstructorNameFromLang() = when (lang) {
        SourceLanguage.Solidity -> CONSTRUCTOR
        SourceLanguage.Vyper -> VYPER_CONSTRUCTOR
        SourceLanguage.Yul -> CONSTRUCTOR // xxx hopefully
        SourceLanguage.Unknown -> CONSTRUCTOR // default to Solidity's default
    }

    // non user-defined constructor
    private val defaultConstructor = Method(
        getConstructorNameFromLang(),
        emptyList(),
        emptyList(),
        isLibrary = false,
        contractName = name
    )

    private fun getUserDefinedConstructor(): Method? =
        methods.find { it.name == getConstructorNameFromLang() }

    fun getOrdinaryMethods(): List<Method> {
        return methods.filter { it.name != getConstructorNameFromLang() }
    }

    fun getConstructor(): Method {
        return getUserDefinedConstructor() ?: defaultConstructor
    }

    fun getAllDeclaredMethods() = methods + extensionContracts.flatMap { ext ->
        ext.extension.getOrdinaryMethods().filter { m ->
            m.name !in ext.exclusion
        }.map {
            it.copy(contractName = name)
        }
    }

    fun getMethodsAndConstructor(): List<Method> {
        val declaredMethods = getAllDeclaredMethods()
        return if (getUserDefinedConstructor() == null) {
            declaredMethods + defaultConstructor
        } else {
            declaredMethods
        }
    }

    /** instantiate this contract with data of the parent SDC, since some of this preprocessing currently isn't done in the build script */
    fun withDataOfSDC(singleDeployedContract: SingleDeployedContract): ContractInstanceInSDC {
        return copy(
            state = singleDeployedContract.state,
            structLinkingInfo = singleDeployedContract.structLinkingInfo,
            legacyStructLinking = singleDeployedContract.legacyStructLinking,
            srclist = singleDeployedContract.parseSourceList(),
            prototypeFor = singleDeployedContract.prototypeFor,
            sourceDir = singleDeployedContract.sourceDir,
            origSourceDir = singleDeployedContract.origSourceDir
        )
    }

    val srcMappings by lazy { parseSrcMapping(srcmap) }
    val varMappings by lazy { parseVariableMapping(varmap) }
    val srcContext by lazy { SourceContext(srclist, sourceDir) }
    val origSrcContext by lazy { SourceContext(srclist, origSourceDir) }
    val constructorSrcMappings by lazy { parseSrcMapping(constructorSrcmap) }

    val isLibrary : Boolean get() = methods.any { it.isLibrary }

    fun sourceSegment(): SourceSegment? {
        val sourceBytes = this.sourceBytes ?: return null
        val relativeFile = this.original_file
        val sourceFile = CertoraFileCache.certoraSourcesDir().resolve(this.original_file)
        return SourceSegment(sourceFile, sourceBytes.begin, sourceBytes.size, relativeFile)
    }

    fun hasCompilerData(): Boolean = methods.isNotEmpty() || solidityTypes.isNotEmpty()
}

/**
 * If `C` is an extension of `A` and `B`, `getContractsExtendedBy(C)` returns `[A, B]`
 */
fun List<ContractInstanceInSDC>.getContractsExtendedBy(contract: ContractInstanceInSDC): List<ContractInstanceInSDC> {
    return this.filter { c ->
        contract.name in c.extensionContracts.map { it.extension.name }
    }
}

fun List<ContractInstanceInSDC>.isExtensionContract(contract: ContractInstanceInSDC): Boolean =
    this.getContractsExtendedBy(contract).isNotEmpty()

/**
 * the starting byte position and the size of the entire source code segment corresponding to this parsed element,
 * obtained from the source code's compiler.
 *
 * N.B.: this will always point to the data of the *original* source code, even for autofinders!
 */
@Serializable
@Treapable
data class SourceBytes(val begin: Int, val size: Int) : java.io.Serializable
