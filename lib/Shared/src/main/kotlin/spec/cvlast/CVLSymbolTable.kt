/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// CER-1384: Supressing warnings at file level to avoid churn during rewrite
@file:Suppress("UNUSED_VARIABLE")

// Note to reviewers: this file is changed to reuse the error classes for things like undefined variables.  Those error
// classes require some position information about the previous definition, so we also add some range fields to the
// [SymbolInfo], and set them at the appropriate places.
//
// Finally, I inlined some of the cases for [SymbolInfo.Companion.invoke] with the hopes of removing it entirely (it's
// awfully ugly), but I didn't finish removing it because doing the obvious thing introduced bugs that I didn't want to
// chase down.  But I left some of the inlining anyhow.

package spec.cvlast

import allocator.Allocator
import bridge.ContractInstanceInSDC
import bridge.EVMExternalMethodInfo
import datastructures.stdcollections.*
import log.Logger
import log.LoggerTypes
import spec.AutoGeneratedRuleException
import spec.CVLCastFunction
import spec.CVLKeywords
import spec.CVLReservedVariables
import spec.cvlast.CVLSymbolTable.SymbolInfo.CVLFunctionInfo
import spec.cvlast.CVLSymbolTable.SymbolInfo.NonValueSymbol
import spec.cvlast.CVLSymbolTable.SymbolTableNamespace.FUNCTION_LIKE
import spec.cvlast.CVLSymbolTable.SymbolTableNamespace.NON_FUNCTION_LIKE
import spec.cvlast.typechecker.CVLError
import spec.cvlast.typechecker.DeclaredKeyword
import spec.cvlast.typechecker.DuplicateDeclaration
import spec.cvlast.typedescriptors.FromVMContext
import spec.cvlast.typedescriptors.VMTypeDescriptor
import spec.isWildcard
import spec.rules.*
import utils.CollectingResult
import utils.CollectingResult.Companion.asError
import utils.CollectingResult.Companion.bind
import utils.CollectingResult.Companion.flatten
import utils.CollectingResult.Companion.flattenToVoid
import utils.CollectingResult.Companion.lift
import utils.CollectingResult.Companion.map
import utils.CollectingResult.Companion.ok
import utils.ErrorCollector.Companion.collectingErrors
import utils.HasRange
import utils.Range
import utils.VoidResult
import utils.`impossible!`

private val logger = Logger(LoggerTypes.CVL_TYPE_CHECKER)

class CVLSymbolTable(
    /** Maps scope and identifier to metadata (typically type information, but [SymbolInfo] can be enhanced when
     * needed... */
    private val backing: MutableMap<SymbolTableKey, SymbolInfo> = HashMap(),
    /** For every [ContractReference] a scope is created in which the contract's function are registered
     * Keep a mapping from [ContractReference] to the created [CVLScope].
     * This mapping is used when lookup a method where we first lookup the contract and then the method
     */
    private val contractsScope: MutableMap<String, CVLScope> = HashMap(),
    /** No register.. calls (or other changes) are allowed once this flag has been set */
    private var isFinalized: Boolean = false,
) {
    /**
     * Used to key into the [backing] of the symbol table and separate namespaces.
     * [FUNCTION_LIKE] keys anything that acts like a function in CVL
     *  - [CVLFunction]
     *  - [ContractFunction]
     *  - [CVLGhostFunction]
     *  - [CVLDefinition]
     *  - [CVLCastFunction]
     *
     *  [NON_FUNCTION_LIKE] keys all other symbols
     */
    enum class SymbolTableNamespace {
        FUNCTION_LIKE,
        NON_FUNCTION_LIKE,
        CONTRACT_IDENTIFIER_NAMESPACE
    }

    data class SymbolTableKey(val scope: CVLScope, val namespace: SymbolTableNamespace, val symbolName: String)

    /**
     * Maps each identifier of a from-user rule/invariant to the number of from-user rules/invariants that have this identifier.
     * The goal of this mapping is to detect ids' collisions that result from the cvl spec.
     * If no such collisions are detected, only then we look for collisions between ids of auto-generated rules.
     * The reason is that auto-generated rules may have ids' collisions that are induced by collisions of from-user rules' ids.
     * Once we rule out those, we report a collision between auto-generated rules as an [AutoGeneratedRuleException], rather
     * than a CVL syntax error.
     */
    private val fromUserInvariantsAndRulesIds: MutableMap<String, Int> = mutableMapOf()

    private fun reportFromUserInvOrRuleId(id: String) {
        fromUserInvariantsAndRulesIds[id] =
            fromUserInvariantsAndRulesIds.computeIfAbsent(id) { 0 } + 1
    }

    internal fun fromUserInvsRulesIdsCollide(): Boolean = fromUserInvariantsAndRulesIds.any { it.value > 1 }


    private val reserved = CVLReservedVariables.values().map { it.name }.toSet()

    private val freshNameGenerator = FreshNameGenerator()

    /**
     * Provides globally unique names during rule generation.
     */
    inner class FreshNameGenerator {
        private val generated = mutableSetOf<String>()
        private val lastUsedIndex = mutableMapOf<String, Int>()
        // allIds should not be modified once isFinalized is set, additionally, no concurrent updates to this should
        // happen while isFinalized is not set
        private var allIds: Set<String> = setOf() // initializes field
            set(value) = if (isFinalized) {
                throw IllegalStateException("Tried to modify a finalized symbol table")
            } else {
                field = value
            }
            get() = if (isFinalized) {
                field
            } else {
                computeAllIds()
            }
        fun finalize() {
            allIds = computeAllIds()
        }

        private fun inAnyScope(id: String) = allIds.contains(id)

        private fun computeAllIds() = backing.keys.map { key -> key.symbolName }.toSet()

        private fun taken(requested: String) = requested in generated || reserved.contains(requested)
                || inAnyScope(requested)

        /**
         * Many threads may concurrently ask for a unique ID, and multiple threads may be asking for a unique id for
         * the same rule. Thus, being thread local is not sufficient and this must be synchronized.
         */
        @Synchronized
        fun generate(requested: String): String {
            var result = requested
            var idx = 0
            if (taken(result)) {
                idx = lastUsedIndex[requested] ?: 0
                idx++
                result = "$requested$idx"

                while (taken(result)) {
                    idx++
                    result = "$requested$idx"
                }
            }

            generated.add(result)
            lastUsedIndex[result] = idx
            return result
        }
    }

    fun getAllStructTypes() = backing.entries.mapNotNull { (key, info) ->
        key.scope.enclosingContract()
            ?.let { contractsScope ->
                ((info.symbolValue as? ContractTypeDefinition)?.type as? CVLType.PureCVLType.Struct)?.let { structType ->
                    contractsScope.contract to structType
                }
            }
    }


    private fun checkName(name: CallableName, range: Range): VoidResult<CVLError> = checkName(name.methodId, range)

    private fun checkName(name: String, range: Range): VoidResult<CVLError> {
        val nameIsKeyword = CVLKeywords.find(name)
        if (CVLKeywords.values().any { kw -> kw != CVLKeywords.wildCardExp && name == kw.name }) {
            return DeclaredKeyword(name, range).asError()
        }

        val nameIsCVLType = CVLType.valueFromString(name)
        if (nameIsCVLType != null) {
            return CVLError.General(
                range,
                "Trying to declare an identifier with a type name: $name. Please use another name",
            ).asError()
        }

        val nameIsReserved =
            name in (reserved).minus(CVLReservedVariables.certorafallback_0.name) // allowed to use certorafallback_0 due to invoke_fallback. TODO improve
        if (nameIsReserved) {
            return DeclaredKeyword(name, range).asError()
        }

        val startingWithReservedPrefix = name.startsWith(CVLReservedVariables.prefix)
        if (startingWithReservedPrefix) {
            return CVLError.General(
                range,
                "Trying to declare an identifier with a reserved prefix: $name. Please use another name",
            ).asError()
        }
        return ok
    }

    fun lookUpFunctionLikeSymbol(id: String, typeEnv: CVLTypeEnvironment): SymbolInfo? =
        lookUp(id, FUNCTION_LIKE, typeEnv)

    fun lookUpNonFunctionLikeSymbol(id: String, typeEnv: CVLTypeEnvironment): SymbolInfo? =
        lookUp(id, NON_FUNCTION_LIKE, typeEnv)

    fun lookUpFunctionLikeSymbol(id: String, scope: CVLScope): SymbolInfo? =
        lookUp(id, FUNCTION_LIKE, scope)

    fun lookUpNonFunctionLikeSymbol(id: String, scope: CVLScope): SymbolInfo? =
        lookUp(id, NON_FUNCTION_LIKE, scope)

    fun lookUpContractIdentifierNamespaceSymbol(id: String, scope: CVLScope): SymbolInfo? =
        lookUp(id, SymbolTableNamespace.CONTRACT_IDENTIFIER_NAMESPACE, scope)

    fun lookUp(id: String, namespace: SymbolTableNamespace, typeEnv: CVLTypeEnvironment): SymbolInfo? {
        logger.info { "Looking up $id in typeenv $typeEnv" }
        /* first, look into type environment */
        val typeFromEnv = typeEnv.lookUp(id)
        if (typeFromEnv != null) {
            return typeFromEnv
        }
        return lookUp(id, namespace, typeEnv.scope)
    }


    fun lookUp(id: String, namespace: SymbolTableNamespace, scope: CVLScope): SymbolInfo? {
        var currentInnerScope: CVLScope? = scope
        while (currentInnerScope != null) {
            logger.info {
                "Looking for $id. All IDs in the scope $currentInnerScope: ${
                    backing.keys.filter { it.scope == currentInnerScope }
                        .map { it.symbolName }
                }"
            }
//            logger.info("Symbol with id $id may appear in other scopes: ${backing.keys.filter { it.second == id }.map { it.first } }")
            val symbolInfo = backing[SymbolTableKey(currentInnerScope, namespace, id)]
            if (symbolInfo != null) {
                return symbolInfo
            }
            currentInnerScope = currentInnerScope.innerScope
        }
        return null
    }

    @Suppress("unused")
    fun freshVar(requested: CVLExp.VariableExp) =
        if (requested.isWildCard()) {
            requested
        } else {
            requested.copy(id = freshNameGenerator.generate(requested.id))
        }

    fun freshParam(requested: CVLParam) =
        if (requested.id.isWildcard()) {
            requested
        } else {
            requested.copy(id = "${requested.id}${Allocator.getFreshNumber()}")
        }

    fun freshQuantifierSym(requested: CVLExp.QuantifierExp) =
        requested.copy(param = freshParam(requested.param))

    fun freshName(requested: String): String = freshNameGenerator.generate(requested)

    private fun lookUpWithMethodIdWithCallContext(methodIdWithCallContext: ResolvedCallableName, lookup: (methodId: String) -> SymbolInfo?) =
        when (val context = methodIdWithCallContext.host) {
            is CvlSpecFile -> lookup(methodIdWithCallContext.methodId)
            is SolidityContract -> lookupMethodInContractEnv(
                context,
                methodIdWithCallContext.methodId,
            )?.let {
                if(it is CVLFunctionInfo && methodIdWithCallContext is ConcreteMethod) {
                    val unique = it.impFuncs.singleOrNull {
                        (it as? ContractFunction)?.methodSignature?.matchesContractAndParams(methodIdWithCallContext.signature) == true
                    } ?: return@let null
                    CVLFunctionInfo(
                        impFuncs = listOf(unique),
                        symbolValue = unique,
                        isTwoState = false
                    )
                } else {
                    it
                }
            }

            CvlBuiltIn,
            AllContracts,
            CurrentContract -> `impossible!`
        }

    fun lookUpWithMethodIdWithCallContext(
        methodIdWithCallContext: ResolvedCallableName,
        scope: CVLScope
    ): SymbolInfo? = lookUpWithMethodIdWithCallContext(methodIdWithCallContext) { host ->
        lookUp(host, FUNCTION_LIKE, scope)
    }

    fun lookUpWithMethodIdWithCallContext(
        methodIdWithCallContext: ResolvedCallableName,
        typeEnv: CVLTypeEnvironment
    ): SymbolInfo? = lookUpWithMethodIdWithCallContext(methodIdWithCallContext) { host ->
        lookUp(host, FUNCTION_LIKE, typeEnv)
    }

    /**
     * Return the [SymbolInfo] of a function with contractId.methodId
     * ContractId must be a symbolic reference to a contract therefore need to
     * first lookup the contractId, then lookup the method in the right contract
     */
    @Suppress("unused")
    fun lookUpMethodWithContractID(
        contractId: String,
        methodId: String,
        scope: CVLScope
    ): SymbolInfo? {
        return lookupMethodInContractEnv(lookUpContractIdentifierNamespaceSymbol(contractId, scope), methodId)
    }

    private fun lookupMethodInContractEnv(
        contractSym: SymbolInfo?,
        methodId: String,
    ): SymbolInfo? {
        return (contractSym?.symbolValue as? CVLImportedContract)?.solidityContractName?.let {
            lookupMethodInContractEnv(
                it, methodId
            )
        }
    }

    fun lookupMethodInContractEnv(
        contractSym: ContractReference?,
        methodId: String
    ): SymbolInfo? {
        if(contractSym != null) {
            val scope = getContractScope(contractSym)
            if (scope != null) {
                return lookUpFunctionLikeSymbol(methodId, scope)
            }
        }
        return null
    }

    private fun verifyUniqueFunctionLikeKey(scope: CVLScope, id: String, objectString: String, range: Range): VoidResult<CVLError> {
        val symbolTableKey = SymbolTableKey(scope, FUNCTION_LIKE, id)
        val currentContractScope = getContractScope(CurrentContract)!!
        val currentContractKey = SymbolTableKey(getContractScope(CurrentContract)!!, FUNCTION_LIKE, id)
        return if (backing.containsKey(symbolTableKey) || backing.containsKey(currentContractKey)) {
            // currently an important assumption for summary inlining
            CVLError.General(
                range,
                "The identifier $id has already been declared in scope $scope. Overloading not allowed for $objectString"
            ).asError()
        } else {
            ok
        }
    }
    fun register(sortDecl: SortDeclaration, scope: CVLScope): VoidResult<CVLError> {
        logger.info { "For decl sort ${sortDecl.sort.name}, registering in $scope" }
        checkNotFinalized()
        return checkName(sortDecl.sort.name, sortDecl.range).bind {
            registerSymbol(
                sortDecl.sort.name, SymbolInfo(sortDecl, sortDecl.range),
                NON_FUNCTION_LIKE, scope, sortDecl.range
            )
        }
    }

    fun register(typeDefinition: ContractTypeDefinition, scope: CVLScope): VoidResult<CVLError> {
        logger.info { "For type definition ${typeDefinition.name}, registering in $scope" }
        checkNotFinalized()
        return registerSymbol(
            typeDefinition.name, SymbolInfo(typeDefinition, Range.Empty()),
            NON_FUNCTION_LIKE, scope, Range.Empty()
        )
    }

    fun register(contract: ContractReference, slot: String, storage: VMTypeDescriptor) : VoidResult<CVLError> {
        logger.info {
            "In ${contract.name}, registering root slot $slot has type $storage"
        }
        checkNotFinalized()
        val symbolTableKey = SymbolTableKey(getContractScope(contract)!!, NON_FUNCTION_LIKE, slot)
        if(symbolTableKey in backing) {
            return CVLError.General(
                message = "Already registered slot with name $slot in contract $contract",
                range = Range.Empty()
            ).asError()
        }
        backing[symbolTableKey] = SymbolInfo.ContractStorageType(storage)
        return ok
    }

    fun registerImmutable(contract: ContractReference, immutableName: String, type: VMTypeDescriptor) : VoidResult<CVLError> {
        logger.info {
            "In ${contract.name}, registering immutable $immutableName with type $type"
        }
        checkNotFinalized()
        val symbolTableKey = SymbolTableKey(getContractScope(contract)!!, NON_FUNCTION_LIKE, immutableName)
        if(symbolTableKey in backing) {
            return CVLError.General(
                message = "Already registered a symbol with the name $immutableName in contract $contract, tried to register as an immutable now",
                range = Range.Empty()
            ).asError()
        }
        backing[symbolTableKey] = SymbolInfo.ContractImmutableType(type)
        return ok
    }

    fun register(inv: CVLInvariant, scope: CVLScope) : VoidResult<CVLError> {
        logger.info { "For invariant ${inv.id}, registering in $scope" }
        checkNotFinalized()

        reportFromUserInvOrRuleId(inv.id)

        return checkName(inv.id, Range.Empty()).bind {
            // we could have chosen to register this in the [FUNCTION_LIKE] namespace since it can be referred to
            // in a requireInvariant which syntactically looks "function-like". We chose to register it in the
            // NON_FUNCTION_LIKE table for consistency with rules
            val symbolTableKey = SymbolTableKey(scope, NON_FUNCTION_LIKE, inv.id)
            if (backing.containsKey(symbolTableKey)) {
                CVLError.General(
                    inv.range, "identifier ${inv.id} has already been declared in scope $scope"
                ).asError()
            } else {
                symbolTableKey.lift()
            }
        }.map { symbolTableKey ->
            backing[symbolTableKey] = NonValueSymbol(inv, inv.range)
        }
    }

    fun register(sub: CVLFunction, scope: CVLScope): VoidResult<CVLError> {
        logger.info { "For decl of $sub, registering in $scope" }
        checkNotFinalized()
        return checkName(sub.functionIdentifier, Range.Empty()).bind {
            // currently an important assumption for summary inlining
            verifyUniqueFunctionLikeKey(scope, sub.functionIdentifier.methodId, "functions", sub.range)
        }.bind {
            registerFunction(sub, scope)
        }
    }


    fun register(ghost: CVLGhostDeclaration, scope: CVLScope): VoidResult<CVLError> {
        return when (ghost) {
            is CVLGhostDeclaration.Function -> {
                logger.info { "For decl of ghost function $ghost, registering in $scope" }
                checkNotFinalized()
                return checkName(ghost.functionReference, Range.Empty()).bind {
                    verifyUniqueFunctionLikeKey(
                        scope,
                        ghost.functionReference.methodId,
                        "ghost functions",
                        ghost.range
                    )
                }.bind {
                    registerFunction(ghost, scope)
                }
            }
            is CVLGhostDeclaration.Variable,
            is CVLGhostDeclaration.Sum -> {
                logger.info { "For decl of ghost ${if (ghost is CVLGhostDeclaration.Variable) { "variable" }  else { "sum" } } ${ghost.id}, registering in $scope" }
                checkNotFinalized()
                checkName(ghost.id, Range.Empty()).bind {
                    val symbolTableKey = SymbolTableKey(scope, NON_FUNCTION_LIKE, ghost.id)
                    if (backing.containsKey(symbolTableKey)) {
                        CVLError.General(
                            ghost.range,
                            "Some symbol with name ${ghost.id} has already been declared in " + "scope $scope.",
                        ).asError()
                    } else {
                        registerSymbol(
                            ghost.id,
                            SymbolInfo(ghost, ghost.range, false),
                            NON_FUNCTION_LIKE,
                            scope,
                            ghost.range,
                        )
                    }
                }
            }
        }
    }

    fun register(
        rule: ICVLRule,
        scope: CVLScope,
        registerFromUserRules: Boolean,
        suppressAutoGenRuleExceptions: Boolean
    ): VoidResult<CVLError> {
        logger.info { "Registering rule $rule" }
        checkNotFinalized()
        val symbolTableKey = SymbolTableKey(scope, NON_FUNCTION_LIKE, rule.declarationId)
        val ruleIsFromUser = rule.ruleType.isFromUser()
        if (ruleIsFromUser && registerFromUserRules) {
            reportFromUserInvOrRuleId(rule.declarationId)
            return checkName(rule.declarationId, Range.Empty()).bind {
                val loc = when (rule) {
                    is CVLSingleRule -> {
                        rule.range
                    }

                    is AssertRule, is GroupRule, is StaticRule -> {
                        throw IllegalStateException(
                            "Expected SingleRuleWithCode, but got a from-user rule of a different type ($rule)"
                        )
                    }
                }
                if (backing.containsKey(symbolTableKey)) { // We assume here that, at this point, there are no auto-generated rules' ids in [backing]
                    CVLError.General(
                        loc, "Identifier ${rule.declarationId} has already been declared in scope $scope"
                    ).asError()
                } else {
                    backing[symbolTableKey] = NonValueSymbol(rule, rule.range)
                    ok
                }
            }
        } else if (!ruleIsFromUser && !registerFromUserRules) { // [rule] is auto-generated
            if (backing.containsKey(symbolTableKey)) {
                val existingSymbolHook = backing[symbolTableKey]!!.symbolValue
                if (existingSymbolHook is IRule && !existingSymbolHook.ruleType.isFromUser()) {
                    // Collision between two auto-generated rules :(((
                    if (!suppressAutoGenRuleExceptions) {
                        AutoGeneratedRuleException.autoGenRuleIdError(
                            "The identifier ${rule.declarationId} belongs to two distinct auto-generated rules " +
                                    "in scope $scope"
                        )
                    }
                } else if (existingSymbolHook is CVLSingleRule && existingSymbolHook.ruleType.isFromUser() &&
                    rule.ruleType is SpecType.Group &&
                    rule.ruleType.getOriginatingRule()?.declarationId == existingSymbolHook.declarationId &&
                    rule.ruleType.getOriginatingRule()?.range == existingSymbolHook.range
                ) {
                    /**
                     * We have a "pseudo-collision" between the auto-generated, Group [rule] and the from-user rule
                     * existingSymbolHook that lead to the generation of [rule].
                     * That is, existingSymbolHook has been reduced to [rule].
                     */
                } else if (existingSymbolHook is CVLInvariant && rule.ruleType is SpecType.Group.InvariantCheck &&
                    (rule.ruleType as SpecType.Group.InvariantCheck).originalInv.id == existingSymbolHook.id
                ) {
                    /*
                    * We have a "pseudo-collision" between the auto-generated, Group, invariant-check [rule], and
                    * the invariant existingSymbolHook that lead to the generation of [rule].
                    *
                    * */
                } else { // Some user-defined element collides with an auto-generated rule: treat this as a syntax error
                    val loc = when (existingSymbolHook) {
                        is HasRange -> {
                            existingSymbolHook.range
                        }
                        else -> Range.Empty()
                    }
                    return CVLError.General(
                        loc,
                        "The identifier ${rule.declarationId} has been reserved in scope $scope " +
                                "for ${
                                    if (rule.ruleType.getOriginatingInvariant() != null) {
                                        val origInv = rule.ruleType.getOriginatingInvariant()!!
                                        "checking ${origInv.id} (${origInv.range})"
                                    } else if (rule.ruleType.getOriginatingRule() != null) {
                                        val origRule = rule.ruleType.getOriginatingRule()!!
                                        "checking ${origRule.declarationId} (${origRule.range})"
                                    } else if (rule.ruleType is SpecType.Single.BuiltIn) {
                                        "an imported builtin rule"
                                    } else {
                                        null
                                    }
                                        ?: "an auto-generated rule"
                                }. Please use another name"
                    ).asError()
                }
            } else {
                backing[symbolTableKey] = NonValueSymbol(rule, rule.range)
            }
        }
        return ok
    }

    fun register(definition: CVLDefinition, scope: CVLScope): VoidResult<CVLError> {
        logger.info { "For definition $definition, registering in $scope" }
        checkNotFinalized()
        return checkName(definition.id, Range.Empty()).bind {
            verifyUniqueFunctionLikeKey(scope, definition.id, "definitions", definition.range)
        }.bind {
            registerFunction(definition, scope)
        }
    }

    /**
     * Registers identifiers that may include parametric method identifiers: these must be registered in both the
     * function-like symbol table (for when they are invoked) as well as in the non function-like symbol table
     * for instances when they are used as structs
     */
    private fun registerLocalVariableSymbol(
        id: String,
        type: CVLType,
        symbol: SymbolInfo,
        scope: CVLScope,
        range: Range,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ): VoidResult<CVLError> =
        if (type == EVMBuiltinTypes.method) {
                registerSymbol(
                    id, symbol, FUNCTION_LIKE, scope,
                    range, autoGeneratedScope, suppressAutoGenRuleExceptions
                ).map(registerSymbol(
                    id, symbol, NON_FUNCTION_LIKE, scope,
                    range, autoGeneratedScope, suppressAutoGenRuleExceptions
                ))
        } else {
            registerSymbol(
                id,
                symbol,
                NON_FUNCTION_LIKE,
                scope,
                range,
                autoGeneratedScope,
                suppressAutoGenRuleExceptions
            )
        }

    /**
     * @param autoGeneratedScope whether [scope] is a scope of an auto-generated rule (rather than a from-user rule)
     *  Returns true if the registration has been done without an identifier collision in [scope].
     */
    fun register(
        cmd: CVLCmd.Simple.Declaration,
        scope: CVLScope,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ): VoidResult<CVLError> {
        logger.info { "For decl $cmd, registering" }
        checkNotFinalized()
        return checkName(cmd.id, cmd.range).bind {
            registerLocalVariableSymbol(
                cmd.id,
                cmd.cvlType,
                SymbolInfo(cmd, cmd.range),
                scope,
                cmd.range,
                autoGeneratedScope,
                suppressAutoGenRuleExceptions
            )
        }
    }

    /**
     * @param autoGeneratedScope whether [scope] is a scope of an auto-generated rule (rather than a from-user rule)
     * Returns true if the registration has been done without an identifier collision in [scope].
     */
    fun register(
        cmd: CVLCmd.Simple.Definition, scope: CVLScope, autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ): VoidResult<CVLError> {
        logger.info { "For def $cmd, registering in $scope" }
        checkNotFinalized()
        return cmd.idL.map { checkName(it.getIdLhs().id, cmd.range) }.flatten().bind {
            if (cmd.type == null) {
                // cmd is a regular assignment rather than a declaration with an initialization --> do nothing
                ok
            } else {
                cmd.idL.map { lhs ->
                    registerLocalVariableSymbol(
                        lhs.getIdLhs().id,
                        cmd.type,
                        SymbolInfo(cmd, cmd.range),
                        scope,
                        cmd.range,
                        autoGeneratedScope,
                        suppressAutoGenRuleExceptions
                    )
                }.flattenToVoid()
            }
        }
    }

    private fun registerSymbol(
        id: String,
        symbol: SymbolInfo,
        namespace: SymbolTableNamespace,
        scope: CVLScope,
        range: Range,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ): VoidResult<CVLError> = collectingErrors {
        val key = SymbolTableKey(scope, namespace, id)
        backing[key]?.let {
            val error = DuplicateDeclaration(id, range, it.declaration)
            if (autoGeneratedScope && !suppressAutoGenRuleExceptions) {
                // throw an exception
                AutoGeneratedRuleException.idCollisionInAutoGenScope(error.message)
            }
            if (autoGeneratedScope) {
                // error should be present in the original rule as well; don't report it again
                return@let
            }
            returnError(error)
        }
        logger.info { "Registered in $scope, $id: $symbol" }
        backing[key] = symbol
    }

    fun registerParam(
        param: VMParam.Named,
        context: FromVMContext,
        scope: CVLScope,
        range: Range,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ) : VoidResult<CVLError> {
        if (param.id.isWildcard()) {
            // Wildcard params shouldn't get registered
            return ok
        }

        val nameChecked = if (!autoGeneratedScope) {
            checkName(param.id, range)
        } else {
            ok
        }
        return nameChecked.bind {
            val type = CVLType.VM(param.type, context)
            val paramVariable: CVLExp.VariableExp = CVLExp.VariableExp(param.name, CVLExpTag(scope, type, range))
            registerLocalVariableSymbol(
                param.name,
                type,
                SymbolInfo(paramVariable, range),
                scope,
                range,
                autoGeneratedScope,
                suppressAutoGenRuleExceptions
            )
        }

    }


    /**
     * @param autoGeneratedScope whether [scope] is a scope of an auto-generated rule (rather than a from-user rule)
     *
     * Returns true if the registration of [param] has been done without an identifier collision in [scope]
     */
    fun registerParam(
        param: CVLParam,
        scope: CVLScope,
        range: Range,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ) : VoidResult<CVLError> {
        checkNotFinalized()
        if (param.id.isWildcard()) {
            // Wildcard params shouldn't get registered
            return ok
        }

        val nameChecked = if (!autoGeneratedScope) {
            checkName(param.id, range)
        } else {
            ok
        }

        return nameChecked.bind {
            if (param.type == EVMBuiltinTypes.method) {
                registerSymbol(
                    param.id,
                    SymbolInfo(param, range),
                    FUNCTION_LIKE,
                    scope,
                    range,
                    autoGeneratedScope,
                    suppressAutoGenRuleExceptions
                ).map(
                    registerSymbol(
                        param.id,
                        SymbolInfo(param, range),
                        NON_FUNCTION_LIKE,
                        scope,
                        range,
                        autoGeneratedScope,
                        suppressAutoGenRuleExceptions
                    )
                )
            } else {
                registerSymbol(
                    param.id,
                    SymbolInfo(param, range),
                    NON_FUNCTION_LIKE,
                    scope,
                    range,
                    autoGeneratedScope,
                    suppressAutoGenRuleExceptions
                )
            }
        }
    }


    /**
     * TODO Nicer would be for CVL keywords to have their own class
     */
    fun registerCVLKeyword(keyword: CVLKeywords, scope: CVLScope): VoidResult<CVLError> {
        checkNotFinalized()
        return registerSymbol(
            keyword.keyword,
            SymbolInfo(keyword, Range.Empty()),
            NON_FUNCTION_LIKE,
            scope,
            Range.Empty()
        )
    }

    private fun <T, U> registerFunction(function: Function<T, U>, scope: CVLScope): CollectingResult<Unit, CVLError> {
        val symbolTableKey =
            SymbolTableKey(scope, FUNCTION_LIKE, function.functionIdentifier.methodId)

        /** register the method itself */
        val stEntry = backing[symbolTableKey]
        return if (stEntry == null) {
            // create a new st entry, as usual
            backing[symbolTableKey] = CVLFunctionInfo(function, listOf(function))
            ok
        } else if (function is ContractFunction) {
            // seems we have an overloaded function -- register the overloading
            stEntry as CVLFunctionInfo
            return stEntry.registerOverloading(function).map { functionInfo ->
                backing[symbolTableKey] = functionInfo
            }
        } else {
            ok
        }
    }

    /**
     * Question: do functions have their own namespace?? -- currently they don't..
     */
    fun register(importedFunction: ContractFunction, scope: CVLScope): VoidResult<CVLError> {
        checkNotFinalized()
        return checkName(importedFunction.functionIdentifier, Range.Empty()).bind {
            registerFunction(importedFunction, scope)
        }
    }

    fun register(importedContract: CVLImportedContract, scope: CVLScope): VoidResult<CVLError> {
        checkNotFinalized()
        val symbolTableKey =
            SymbolTableKey(
                scope,
                NON_FUNCTION_LIKE,
                importedContract.solidityContractVarId
            )
        return checkName(importedContract.solidityContractVarId, Range.Empty()).map {
            backing[symbolTableKey] = SymbolInfo(importedContract, importedContract.range)
        }
    }

    fun registerContract(contractName: ContractInstanceInSDC, scope: CVLScope): VoidResult<CVLError> {
        checkNotFinalized()
        val symbolTableKey =
            SymbolTableKey(
                scope,
                SymbolTableNamespace.CONTRACT_IDENTIFIER_NAMESPACE,
                contractName.name
            )
        return checkName(contractName.name, Range.Empty()).map {
            backing[symbolTableKey] = SymbolInfo(
                CVLContractNamespace(
                    contractName.name,
                    SolidityContract(contractName.name),
                    contractName.address,
                    Range.Empty()
                ), Range.Empty()
            )
        }
    }

    private fun checkNotFinalized() {
        if (isFinalized) {
            throw AssertionError("Attempt to update symbol table when it has been finalized already")
        }
    }

    fun finalize() {
        freshNameGenerator.finalize()
        isFinalized = true
    }


    fun addContractScope(contractName: ContractReference, scope: CVLScope): VoidResult<CVLError> {
        if (contractsScope.containsKey(contractName.name)) {
            return CVLError.General(
                Range.Empty(), "Contract name $contractName already has an entry in scope $scope"
            ).asError()
        }

        contractsScope[contractName.name] = scope
        return ok
    }

    fun getContractScope(contractName: ContractReference): CVLScope? {
        return contractsScope[contractName.name]
    }

    fun getAllContractScopes(): List<CVLScope> {
        return contractsScope.values.toList()
    }

    fun getAllContracts(): List<ContractInstanceInSDC> = getAllContractScopes().map { it.enclosingContract()!!.contract }

    fun getContractNameFromContractId(contractId: ContractReference): SolidityContract? {
        return getContractScope(contractId)?.enclosingContract()?.contract?.name?.let(::SolidityContract)
    }

    fun getAllContractAliases(): Set<String> {
        return backing.filter { it.key.namespace == NON_FUNCTION_LIKE && it.value.symbolValue is CVLImportedContract }.map {
            (it.value.symbolValue as CVLImportedContract).alias
        }.toSet()
    }

    sealed class SymbolInfo {
        abstract val symbolValue: Any
        abstract val isTwoState: Boolean

        // TODO CERT-3553: This information probably duplicates the information in [symbolValue], but the (lack of)
        //                 typing makes it very difficult to extract.
        abstract val declaration : Range

        abstract fun getCVLTypeOrNull(): CVLType?

        sealed class WithCVLType : SymbolInfo() {
            abstract fun getCVLType(): CVLType
            override fun getCVLTypeOrNull(): CVLType? = getCVLType()
        }

        data class CVLValueInfo(override val symbolValue: Any, override val declaration: Range, override val isTwoState: Boolean = false) : WithCVLType() {
            override fun getCVLType(): CVLType = when (symbolValue) {
                is CVLParam -> symbolValue.type
                is CVLCmd.Simple.Declaration -> symbolValue.cvlType
                is CVLCmd.Simple.Definition -> symbolValue.type
                    ?: throw AssertionError(
                        "should not have registered a definition that does not " +
                                "declare anything in the symbol table "
                    )
                is SortDeclaration -> symbolValue.sort
                is CVLGhostDeclaration.Function -> throw CVLTODO("this should be in CVLFunctionInfo I think, so dead code here pretty sure") // hook.type
                is ContractTypeDefinition -> symbolValue.type
                is CVLKeywords -> symbolValue.type
                is CVLExp.VariableExp -> symbolValue.getCVLType() // quantified var (see CVLTypeEnv)
                is CVLImportedContract -> CVLType.PureCVLType.Primitive.CodeContract(symbolValue.solidityContractName) //a contract is an address
                is CVLGhostDeclaration.Variable -> symbolValue.type
                else -> throw UnsupportedOperationException("missing case? ($symbolValue)")
            }
        }

        /**
         * @property symbolValue the name of the function
         */
        data class CVLFunctionInfo(
            override val symbolValue: Function<*, *>,
            val impFuncs: List<Function<*, *>>,
            override val isTwoState: Boolean = false
        ) : SymbolInfo() {
            override val declaration: Range = when(symbolValue) {
                    is CVLFunction -> symbolValue.range
                    is CVLGhostDeclaration.Function -> symbolValue.range
                    is CVLDefinition -> symbolValue.range
                    is ContractFunction -> Range.Empty()
                }

            override fun getCVLTypeOrNull(): CVLType? = if (symbolValue is CVLGhostDeclaration.Function) {
                CVLType.PureCVLType.Ghost.Function(symbolValue.paramTypes, symbolValue.ret)
            } else {
                null
            }

            /** returns a copy of this [CVLFunctionInfo] where the additional overloading was registered */
            fun <T> registerOverloading(impFunc: Function<T, *>): CollectingResult<CVLFunctionInfo, CVLError> =
                if (impFunc in impFuncs) {
                    // impFunc already registered --> return [this] (current symbol table) unchanged
                    this.lift()
                } else if(impFunc is ContractFunction) {
                    val potentialCopyIdx = impFuncs.indexOfFirst { impFunc.methodSignature.matchesContractAndParams((it as ContractFunction).methodSignature) }
                    val potentialCopy = potentialCopyIdx.takeIf { it != -1 }?.let(impFuncs::get)
                    if (potentialCopyIdx == -1) {
                        // no version of impFunc exists: register it
                        // TODO: it seems to happen that we add the same function overloading several times only with flipped envfree --> investigate...
                        CVLFunctionInfo(symbolValue, impFuncs + listOf(impFunc), isTwoState).lift()
                    } else {
                        check(potentialCopy is ContractFunction)
                        // some version of impFunc already exists [potentialCopy], merge some properties
                        // only allow this overloading if both functions are imported functions
                        /* TODO(jtoman): I do not think this merging use case is compelling: we do all our merging elsewhere */
                        CVLFunctionInfo(
                            symbolValue,
                            impFuncs.mapIndexedNotNull { idx, function ->
                                if (idx == potentialCopyIdx) {
                                    null
                                } else {
                                    function as ContractFunction
                                }
                            } + potentialCopy.copy(
                                definitelyNonPayable = potentialCopy.definitelyNonPayable || impFunc.definitelyNonPayable,
                                annotation = MethodQualifiers(
                                    envFree = potentialCopy.annotation.envFree || impFunc.annotation.envFree,
                                    library = potentialCopy.annotation.library,
                                    visibility = potentialCopy.annotation.visibility,
                                    virtual = potentialCopy.annotation.virtual
                                )
                            ),
                            isTwoState
                        ).lift()
                    }
                } else {
                    // Overloading of non-ContractFunctions disallowed
                    CVLError.General(
                        Range.Empty(),
                        "Tried to register two ambiguous function types $impFunc and ${impFuncs.first()}"
                    ).asError()
                }
        }

        /** used for storing the value of [CVLExp.Constant.SignatureLiteralExp]
         * TODO: maybe this could be merged with/purpose could be fulfilled by [CVLFunctionInfo]
         * */
        data class CVLFunctionIdentifierInfo(val evmExternalMethodInfo: EVMExternalMethodInfo, override val declaration: Range) : WithCVLType() {
            override val symbolValue: Any
                get() = evmExternalMethodInfo
            override val isTwoState: Boolean
                get() = false

            override fun getCVLType(): CVLType = EVMBuiltinTypes.method // TODO(jtoman): we went from struct literal to type, why?
        }

        data class NonValueSymbol(override val symbolValue: Any, override val declaration: Range) : SymbolInfo() {
            override val isTwoState: Boolean
                get() = false

            override fun getCVLTypeOrNull(): CVLType? = null
        }

        data class ContractStorageType(val storageType: VMTypeDescriptor) : SymbolInfo() {
            override val declaration = Range.Empty()

            override val symbolValue: Any
                get() = storageType

            override val isTwoState: Boolean
                get() = false
            override fun getCVLTypeOrNull(): CVLType? = null
        }

        data class ContractImmutableType(val immutableType: VMTypeDescriptor) : SymbolInfo() {
            override val declaration = Range.Empty()

            override val symbolValue: Any
                get() = immutableType

            override val isTwoState: Boolean
                get() = false
            override fun getCVLTypeOrNull(): CVLType? = null
        }

        companion object {
            operator fun invoke(hook: Any, declaration: Range, isTwoState: Boolean = false): SymbolInfo =
                when (hook) {
                    is Function<*, *> -> CVLFunctionInfo(hook, listOf(hook), isTwoState)
                    is EVMExternalMethodInfo -> CVLFunctionIdentifierInfo(hook, declaration)
                    is IRule, is CVLInvariant -> NonValueSymbol(hook, declaration)
                    else -> CVLValueInfo(hook, declaration, isTwoState)
                }
        }
    }
}
