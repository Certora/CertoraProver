/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package spec.cvlast

import bridge.ContractInstanceInSDC
import bridge.types.SolidityTypeDescription
import datastructures.stdcollections.*
import log.Logger
import log.LoggerTypes
import spec.CVLKeywords
import spec.CVLWarningLogger
import spec.cvlast.typechecker.CVLError
import spec.cvlast.typedescriptors.FromVMContext
import spec.rules.*
import utils.CollectingResult
import utils.CollectingResult.Companion.bind
import utils.CollectingResult.Companion.flattenToVoid
import utils.CollectingResult.Companion.map
import utils.CollectingResult.Companion.ok
import utils.ErrorCollector.Companion.collectingErrors
import utils.Range
import utils.VoidResult
import utils.mapToSet

private val logger = Logger(LoggerTypes.CVL_TYPE_CHECKER)

/**
 * Traverses the AST (only down to commands), fills the symbol table, annotates commands' locations with [CVLScope]s.
 *
 *
 * @param contractToItsFunctionsFromSpecAndContract map from a contract to its functions; a function declaration can
 *   come from the contract (Solidity) or from the methods block in our spec (CVL/Specify)
 */
class SymbolTableFiller(
    private val symbolTable: CVLSymbolTable,
    private val ast: CVLAst,
    private val contractToItsFunctionsFromSpecAndContract: Map<ContractInstanceInSDC, List<ContractFunction>>,
    private val primaryContract: String,
    private val contractsNames: List<ContractInstanceInSDC>,
) {
    fun traverseAst(): VoidResult<CVLError> {

        /** traverse rules,
         * - visit all declarations and fill the symbol table accordingly
         * Does not touch the input AST, but creates a new one.
         */

        //register methods of contracts used in spec file - current contract and imported contracts
        val contractsToRegister = contractToItsFunctionsFromSpecAndContract
        val registrationResults = mutableListOf<VoidResult<CVLError>>()

        registrationResults.add(registerIdentifiersDeclaredOutsideOfCVLSpec(contractsToRegister))

        //register available contracts in a new namespace(contractIdentifierNameSpace)
        contractsNames.mapTo(registrationResults) { contractName ->
            symbolTable.registerContract(
                contractName, ast.scope
            )
        }

        // add to symbol table contract variables
        ast.importedContracts.mapTo(registrationResults) { importedContract ->
            symbolTable.register(importedContract, ast.scope)
        }

        // We need to register "currentContract" as well
        registrationResults.add(
            symbolTable.register(
                CVLImportedContract(CVLKeywords.CURRENT_CONTRACT, SolidityContract(primaryContract), Range.Empty()), ast.scope
            )
        )

        // Register and traverse "from-user" rules
        // Note that the result of the rule and invariant traversal is used to determine whether to suppress
        // autogenerated-rule exceptions, which is why we store these results in separate variables
        val ruleRegistrationResults = ast.rules.map {
            logger.info { "Traversing rule ${it.declarationId}" }
            registerRuleId(it) { r: ICVLRule ->
                symbolTable.register(
                    r,
                    r.scope.innerScope!!,
                    registerFromUserRules = true,
                    suppressAutoGenRuleExceptions = false
                )
            }.bind(
                traverseRule(
                    it, traverseFromUserRule = true, suppressAutoGenRuleExceptions = false
                )
            )
        }

        val invariantRegistrationResults = ast.invs.map { inv ->
            logger.info { "Traversing invariant ${inv.id}" }
            traverseInvariant(inv)
        }

        // Traverse auto-generated rules (note: this is done after traversing from-user rules and invariants)
        val ruleOrInvariantRegistrationFailed = (ruleRegistrationResults + invariantRegistrationResults).flattenToVoid() is CollectingResult.Error
        ast.rules.mapTo(registrationResults) {
            traverseRule(
                it,
                traverseFromUserRule = false,
                suppressAutoGenRuleExceptions = it.ruleType.isDerived() && ruleOrInvariantRegistrationFailed
            )
        }
        registrationResults += ruleRegistrationResults + invariantRegistrationResults
        ast.sorts.mapTo(registrationResults) { sort ->
            logger.info { "Traversing sort $sort" }
            traverseSort(sort, ast.scope)
        }
        ast.ghosts.mapTo(registrationResults) { ghost ->
            logger.info { "Traversing ghost ${ghost.id}" }
            traverseGhost(ghost)
        }
        ast.definitions.mapTo(registrationResults) { definition ->
            logger.info { "Traversing definition ${definition.id}" }
            traverseDefinition(definition)
        }

        // IMPORTANT: hooks MUST go LAST as we may actually end up renaming variables as a result of _other_ scopes
        // that names here may *or may not* collide with at time of hook inlining
        ast.subs.mapTo(registrationResults) {
            logger.info { "Traversing CVL Function ${it.declarationId}" }
            traverseCVLFunction(it)
        }
        ast.hooks.mapTo(registrationResults) { hook ->
            logger.info { "Traversing hook ${hook.pattern}" }
            traverseHook(hook)
        }

        // Finally, register the ids of auto-generated rules. This comes last as we want to check id collisions
        // against all other elements, and give priority to ids of auto-generated rules over all other ids.
        ast.rules.mapTo(registrationResults) {
            registerRuleId(it) { r: ICVLRule ->
                symbolTable.register(
                    r,
                    r.scope.innerScope!!,
                    registerFromUserRules = false,
                    suppressAutoGenRuleExceptions = r.ruleType.isDerived() && symbolTable.fromUserInvsRulesIdsCollide()
                )
            }
        }

        ast.importedMethods.mapTo(registrationResults) { annot ->
            ((annot as? ConcreteMethodBlockAnnotation)?.summary as? SpecCallSummary.Exp)?.let { exp ->
                val params = exp.funParams.filterIsInstance<VMParam.Named>().map {
                    symbolTable.registerParam(
                        it,
                        when (annot.qualifiers.visibility) {
                            Visibility.INTERNAL -> FromVMContext.InternalSummaryArgBinding
                            Visibility.EXTERNAL -> FromVMContext.ExternalSummaryArgBinding
                        },
                        scope = exp.scope,
                        range = annot.range,
                        autoGeneratedScope = false,
                        suppressAutoGenRuleExceptions = true
                    )
                }.flattenToVoid()
                val withArgs = exp.withClause?.let {
                    symbolTable.registerParam(
                        it.param,
                        scope = exp.scope,
                        range = it.range,
                        autoGeneratedScope = false,
                        suppressAutoGenRuleExceptions = true
                    )
                } ?: ok
                val calledContract = symbolTable.registerCVLKeyword(CVLKeywords.calledContract, exp.scope)
                val executingContract = symbolTable.registerCVLKeyword(CVLKeywords.executingContract, exp.scope)
                listOf(params, withArgs, calledContract, executingContract).flattenToVoid()
            } ?: ok
        }
        return registrationResults.flattenToVoid()
    }

    /**
     * Add identifiers to the symbol table that are visible everywhere without them being declared in the CVL file.
     * (e.g. keywords, methods occurring in the contract), the functions from the methods section are registered here,
     * too.
     *
     * @param functionsFromSpecFileAndContracts imported functions of each contract from [CVLAst]'s "methods" block had to be massaged before
     *   being registered in the symbol table in this method
     */
    private fun registerIdentifiersDeclaredOutsideOfCVLSpec(functionsFromSpecFileAndContracts: Map<ContractInstanceInSDC, List<ContractFunction>>): VoidResult<CVLError> {
        val results = mutableListOf<VoidResult<CVLError>>()
        /** register all cvl keywords at ast scope */
        CVLKeywords.values().mapTo(results) {symbolTable.registerCVLKeyword(it, ast.scope) }

        /** for every contract open a scope    */
        /** register all imported methods at ast scope (lookup returns their result type) */
        functionsFromSpecFileAndContracts.forEach { (contract, functions) ->
            val contractScope = CVLScope.newScope().push(contract)
            val namedContract = SolidityContract(contract.name)
            results.add(symbolTable.addContractScope(namedContract, contractScope).bind {
                if (contract.name == primaryContract) {
                    // Add to the scope table an entry for currentContract so that `currentContract.foo` will also work for
                    // functions in the primary contract.
                    symbolTable.addContractScope(SolidityContract.Current, contractScope)
                } else {
                    ok
                }
            })
            functions.mapTo(results) { importedFunction ->
                check(importedFunction.annotation.visibility == Visibility.EXTERNAL) {
                    "Should only be registering external methods in the symbol table"
                }
                logger.info { "Registering new method from headers $importedFunction in scope $contractScope" }
                symbolTable.register(importedFunction, contractScope)
            }
            contract.solidityTypes
                .filterIsInstance<SolidityTypeDescription.UserDefined>() // Only register user-defined types
                .groupBy { it.qualifiedName }
                .mapNotNullTo(results) { (name, typeDescriptions) ->
                    if (typeDescriptions.mapToSet { it.toUserDefinedCVLType() }.size > 1) {
                        CVLWarningLogger.generalWarning(
                            "Type $name has several conflicting declarations, this type will not be usable within CVL. Definition sites:\n\t" +
                                typeDescriptions.joinToString("\n\t") { it.canonicalId }
                        )
                        return@mapNotNullTo null
                    }

                    // only types declared in this contract should be registered, none from super contracts
                    // a null contractName indicates that the type was declared at the file level--in this case
                    // we import it (which means those imported in super contracts will be available--pretty sure)
                    // a null toCVLType() means we aren't supporting that type yet
                    val type = typeDescriptions.first()
                    type.toUserDefinedCVLType().resultOrNull()?.let { theType ->
                        symbolTable.register(ContractTypeDefinition(type.qualifiedName, theType), contractScope)
                    }
                }

            val duplicateSlotNames = contract.storageLayout?.let { storage ->
                storage.storage.groupingBy { it.label }.eachCount().filter { it.value > 1 }.keys
            } ?: setOf()
            duplicateSlotNames.forEach { slotName ->
                CVLWarningLogger.generalWarning(
                    "Contract ${contract.name} has multiple storage slots with the same name - $slotName (multiple inheritance could cause this), " +
                        "they will be ignored"
                )
            }

            contract.storageLayout?.toTACStorageLayout()?.slots?.let { slots ->
                slots.filter { it.key !in duplicateSlotNames }.mapTo(results) { (slot, type) ->
                    type.typeDescriptor?.let { _ ->
                        symbolTable.register(namedContract, slot, type.typeDescriptor)
                    } ?: ok
                }
            }

            contract.transientStorageLayout?.toTACStorageLayout()?.slots?.let { slots ->
                slots.filter { it.key !in duplicateSlotNames }.mapTo(results) { (slot, type) ->
                    type.typeDescriptor?.let { _ ->
                        symbolTable.register(namedContract, slot, type.typeDescriptor)
                    } ?: ok
                }
            }

            contract.immutables.distinctBy { it.varname }
                .forEach { immutable ->
                    val type = immutable.type
                    symbolTable.registerImmutable(namedContract, immutable.varname, type.toVMTypeDescriptor())
                }
        }
        return results.flattenToVoid()
    }

    private fun traverseInvariant(inv: CVLInvariant): VoidResult<CVLError> {
        val collisionResult = mutableListOf<VoidResult<CVLError>>()
        inv.params.mapTo(collisionResult) { param ->
            logger.info { "Registering param $param in ${inv.scope}" }
            symbolTable.registerParam(param, inv.scope, inv.range).map(
                inv.proof.preserved.map { preserve ->
                    symbolTable.registerParam(param, preserve.scope, preserve.range)
                }.flattenToVoid()
            )
        }

        inv.proof.preserved.mapTo(collisionResult) { preserve ->
            // Note that we're not using the `namedParam` field because that one skips unnamed params, but we want
            // to catch those here
            preserve.withParams.map { param ->
                symbolTable.registerParam(param, preserve.scope, preserve.range)
            }.flattenToVoid().bind(
            preserve.params.map { param ->
                symbolTable.registerParam(param, preserve.scope, preserve.range)
            }.flattenToVoid())
        }

        inv.proof.preserved.flatMapTo(collisionResult) { preserve ->
            preserve.block.map { cmd ->
                traverseCmd(
                    cmd,
                    autoGeneratedScope = false,
                    suppressAutoGenRuleExceptions = false
                )
            }
        }

        return collisionResult.flattenToVoid().bind { symbolTable.register(inv, ast.scope) }
    }

    /**
     * Returns a [CVLError] if a method parameter has the same name as a function of one of the contracts in the scene.
     */
    private fun verifyMethodParamIsNotContractFunction(param: CVLParam, range: Range, source: String): VoidResult<CVLError> = collectingErrors {
        if (param.type != EVMBuiltinTypes.method) { return@collectingErrors }
        contractToItsFunctionsFromSpecAndContract.forEach { (contract, functions) ->
            functions.forEach {
                if (it.methodSignature.functionName == param.id) {
                    returnError(CVLError.General(
                        range,
                        "The $source parameter name `${param.id}` coincides with a method name in contract `${contract.name}`"
                    ))
                }
            }
        }
    }

    private fun traverseCVLFunction(sub: CVLFunction): VoidResult<CVLError> {
        return sub.params.map { param ->
            logger.info { "Registering subroutine param $param in ${sub.scope}" }
            verifyMethodParamIsNotContractFunction(param, sub.range, "function").bind {
                symbolTable.registerParam(param, sub.scope, sub.range)
            }
        }.flattenToVoid().bind {
            sub.block.map { cmd ->
                traverseCmd(cmd, autoGeneratedScope = false, suppressAutoGenRuleExceptions = false)
            }.flattenToVoid()
        }.bind {
            symbolTable.register(sub, ast.scope)
        }
    }

    private fun traverseRule(
        rule: ICVLRule,
        traverseFromUserRule: Boolean,
        suppressAutoGenRuleExceptions: Boolean
    ): VoidResult<CVLError> =
        when (rule) {
            is CVLSingleRule -> {
                if (traverseFromUserRule && rule.ruleType.isFromUser()) { // traverse from-user rule
                    traverseRule(rule, suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions)
                } else if (!traverseFromUserRule && !rule.ruleType.isFromUser()) { // traverse auto-generated rule
                    traverseRule(rule, suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions)
                } else {
                    ok
                }
            }
            is GroupRule -> {
                rule.rules.map {
                    traverseRule(
                        it,
                        traverseFromUserRule,
                        suppressAutoGenRuleExceptions
                    )
                }.flattenToVoid()
            }
            is DynamicGroupRule, // nothing to traverse in it
            is AssertRule, // nothing to traverse in it
            is StaticRule -> { // nothing to traverse in it
                ok
            }
        }

    private fun registerRuleId(rule: ICVLRule, registerRuleOp: (ICVLRule) -> VoidResult<CVLError>): VoidResult<CVLError> {
        return when (rule) {
            is GroupRule -> {
                rule.rules.map { registerRuleId(it, registerRuleOp) }.flattenToVoid()
            }
            is DynamicGroupRule, is CVLSingleRule, is AssertRule, is StaticRule -> {
                ok
            }
        }.bind(registerRuleOp(rule))
    }


    private fun traverseRule(
        rule: CVLSingleRule,
        suppressAutoGenRuleExceptions: Boolean
    ): VoidResult<CVLError> {
            val paramsToIdCollisions = rule.params.map { param ->
                logger.info { "Registering rule param $param in ${rule.scope}" }
                verifyMethodParamIsNotContractFunction(param, rule.range, "rule").bind {
                    symbolTable.registerParam(
                        param,
                        rule.scope,
                        rule.range,
                        autoGeneratedScope = !rule.ruleType.isFromUser(),
                        suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions
                    )
                }
        }.flattenToVoid()
        val traversedBlockResults = rule.block.map { cmd ->
            traverseCmd(
                cmd,
                autoGeneratedScope = !rule.ruleType.isFromUser(),
                suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions
            )
        }.flattenToVoid()

        return paramsToIdCollisions.map(traversedBlockResults)
    }

    /**
     * @param autoGeneratedScope whether [cmd] is in a scope of an auto-generated rule (rather than a from-user rule)
     * @param suppressAutoGenRuleExceptions whether the tool should throw an exception if there is a collision within generated rules
     */
    private fun traverseCmd(
        cmd: CVLCmd,
        autoGeneratedScope: Boolean,
        suppressAutoGenRuleExceptions: Boolean
    ): VoidResult<CVLError> {
        logger.info { "Traversing $cmd" }
        return when (cmd) {
            is CVLCmd.Composite.Block -> {
                cmd.block.map { traverseCmd(it, autoGeneratedScope, suppressAutoGenRuleExceptions) }.flattenToVoid()
            }
            is CVLCmd.Simple.Declaration -> {
                symbolTable.register(
                    cmd,
                    cmd.scope,
                    autoGeneratedScope = autoGeneratedScope,
                    suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions
                )
            }
            is CVLCmd.Simple.Definition -> {
                if (cmd.type != null) {
                    symbolTable.register(
                        cmd,
                        cmd.scope,
                        autoGeneratedScope = autoGeneratedScope,
                        suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions
                    )
                } else {
                    ok
                }
            }
            is CVLCmd.Composite.If -> {
                val traversedThenCmdResult = traverseCmd(cmd.thenCmd, autoGeneratedScope, suppressAutoGenRuleExceptions)
                val traversedElseCmdResult = traverseCmd(cmd.elseCmd, autoGeneratedScope, suppressAutoGenRuleExceptions)
                traversedThenCmdResult.map(traversedElseCmdResult)
            }
            else -> {
                ok
            }
        }
    }

    private fun traverseSort(sort: SortDeclaration, scope: CVLScope): VoidResult<CVLError> {
        return symbolTable.register(sort, scope)
    }

    private fun traverseGhost(ghost: CVLGhostDeclaration): VoidResult<CVLError> {
        return symbolTable.register(ghost, ghost.scope)
    }

    private fun traverseDefinition(definition: CVLDefinition): VoidResult<CVLError> {
        return symbolTable.register(definition, definition.scope!!)
    }

    private fun traverseHook(hook: CVLHook): VoidResult<CVLError> {
        return traverseHookPattern(hook.pattern, hook.scope, hook.range).map(
            hook.block.map {
                traverseCmd(
                    it, autoGeneratedScope = false, suppressAutoGenRuleExceptions = true
                )
            }.flattenToVoid()
        )
    }

    private fun traverseHookPattern(hookPattern: CVLHookPattern, scope: CVLScope, range: Range) : VoidResult<CVLError> {
        val initialRes =
            when (hookPattern) {
                is CVLHookPattern.StoragePattern -> {
                    symbolTable.registerParam(hookPattern.value, FromVMContext.HookValue, scope, range)
                    if (hookPattern is CVLHookPattern.StoragePattern.Store && hookPattern.previousValue != null) {
                        symbolTable.registerParam(hookPattern.previousValue, FromVMContext.HookValue, scope, range)
                    } else {
                        ok
                    }
                }
                is CVLHookPattern.Create -> symbolTable.registerParam(hookPattern.value, FromVMContext.HookValue, scope, range)
                is CVLHookPattern.Opcode -> {
                    hookPattern.params.map {
                        symbolTable.registerParam(it, FromVMContext.HookValue, scope, range)
                    }.flattenToVoid().bind(
                        if (hookPattern is PatternWithValue) {
                            symbolTable.registerParam(hookPattern.value, FromVMContext.HookValue, scope, range)
                        } else {
                            ok
                        },
                        symbolTable.registerCVLKeyword(
                            CVLKeywords.executingContract, scope
                        ),
                        if(hookPattern is OpcodeHookWithEnv) {
                            hookPattern.environmentParams().map {
                                symbolTable.registerParam(it, FromVMContext.HookValue, scope, range)
                            }.flattenToVoid()
                        } else {
                            ok
                        }
                    )
                }
            }

        fun traverseSlotPattern(slotPattern: CVLSlotPattern): VoidResult<CVLError> = when (slotPattern) {
            is CVLSlotPattern.MapAccess -> {
                symbolTable.registerParam(slotPattern.key, FromVMContext.HookValue, scope, range).map(
                    traverseSlotPattern(slotPattern.base)
                )
            }
            is CVLSlotPattern.ArrayAccess -> {
                symbolTable.registerParam(slotPattern.index, FromVMContext.HookValue, scope, range).map(
                    traverseSlotPattern(slotPattern.base)
                )
            }
            is CVLSlotPattern.StructAccess -> {
                traverseSlotPattern(slotPattern.base)
            }
            is CVLSlotPattern.Static -> { /* Nothing to do */
                ok
            }
            is CVLSlotPattern.FieldAccess -> traverseSlotPattern(slotPattern.base)
        }

        return initialRes.bind {
            if (hookPattern is CVLHookPattern.StoragePattern) {
                traverseSlotPattern(hookPattern.slot)
            } else {
                ok
            }
        }
    }
}
