/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package ksp.remapper

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAllSuperTypes
import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.*
import kotlin.math.absoluteValue
import ksp.isAnnotation


class RemapperProcessor(private val environment: SymbolProcessorEnvironment) : SymbolProcessor {
    companion object {
        private const val remapFuncName = "f"
        private const val remapperSig = """(Any, Int, () -> Int) -> Int"""
        private const val implName = "impl"

        const val mapperPackage = "vc.data"

        const val uniqSimpleName = "UniqueIdEntity"

        const val uniqIdName = "$mapperPackage.$uniqSimpleName"

        const val remapperName = "RemapperEntity"

        private fun dotter(nullable: Boolean): String = if (nullable) { "?." } else { "." }
    }

    private fun KSTypeReference.resolveThroughAliases() : KSType {
        val type = this.resolve()
        return when(val decl = type.declaration) {
            is KSTypeAlias -> decl.type.resolveThroughAliases()
            else -> type
        }
    }

    /**
     * Describes how to remap a value consistently.
     */
    private sealed class RemapSort {
        /**
         * Given a [token] to be remapped, generate the code to effect that remapping. It can be assumed that the remapper
         * function is available under the name [remapFuncName]
         */
        abstract fun remapAt(token: String) : String

        /**
         * The object being remapped implements [vc.data.UniqueIdEntity], and should be remapped directly.
         * If [nullable], the remapping should be done monadically.
         */
        data class Unique(val nullable: Boolean) : RemapSort() {
            override fun remapAt(token: String): String {
                return "$token${dotter(nullable)}mapId($remapFuncName)"
            }
        }

        /**
         * The object being remapped is remapped with a extension class in [fqn]. If [nullable], the
         * value being remapped might be null, so the remapping should is done monadically.
         */
        data class WithGenerated(val fqn: String, val nullable: Boolean) : RemapSort() {
            override fun remapAt(token: String): String {
                return if(this.nullable) {
                    "$token?.let { ${this.fqn}.$implName(it, $remapFuncName) }"
                } else {
                    "${this.fqn}.$implName($token, $remapFuncName)"
                }
            }
        }

        /**
         * The value being remapped is an integer generated by an allocator sequence, the identity of which is [name].
         * Thus, the value can be remapped directly with the [remapFuncName]
         */
        data class GeneratedBy(val name: String) : RemapSort() {
            override fun remapAt(token: String): String {
                return """
                     $remapFuncName($name, $token) {
                               allocator.Allocator.getFreshId($name)
                            }
                """.trimIndent()
            }
        }

        /**
         * The value being remapped is a [Collection], whose values are themselves remapped according to [child]. If [nullable],
         * the remapping must be done monadically.
         */
        sealed class Collection : RemapSort() {
            abstract val child: RemapSort
            abstract val nullable: Boolean

            abstract fun innerMapCall(childId: String): String

            override fun remapAt(token: String) : String {
                val childId = "t_${child.hashCode().absoluteValue}"
                return "$token${dotter(nullable)}${innerMapCall(childId)}"
            }

            /** the value of a (key, value) map element */
            data class MapValue(override val child: RemapSort, override val nullable: Boolean) : Collection() {
                override fun innerMapCall(childId: String) = "mapValues { (_, $childId) -> ${child.remapAt(childId)} }"
            }
            data class ListElement(override val child: RemapSort, override val nullable: Boolean) : Collection() {
                override fun innerMapCall(childId: String) = "map { $childId -> ${child.remapAt(childId)} }"
            }
            data class SetElement(override val child: RemapSort, override val nullable: Boolean) : Collection() {
                override fun innerMapCall(childId: String) = "map { $childId -> ${child.remapAt(childId)} }.toSet()"
            }
        }
    }

    /**
     * Given a type [kls] (assumed to be the type of a field within a class annotated with [allocator.GenerateRemapper]),
     * extract the remapper for that field (if applicable).
     */
    private fun remappable(kls: KSType, resolver: Resolver) = remappable(kls, kls.isMarkedNullable, resolver = resolver)

    /**
     * As above, but consider the type as nullable according to the explicit [nullable] argument.
     */
    private fun remappable(kls: KSType, nullable: Boolean, resolver: Resolver) : RemapSort? {
        if(kls.declaration is KSTypeAlias) {
            val resolvedType = (kls.declaration as KSTypeAlias).type.resolve()
            return remappable(resolvedType, nullable = nullable || resolvedType.isMarkedNullable, resolver)
        }
        if(kls.declaration !is KSClassDeclaration) {
            return null
        }
        val decl = kls.declaration as KSClassDeclaration
        val qualifiedName = decl.qualifiedName?.asString()
        return when {
            decl.classKind == ClassKind.CLASS && (decl.getAllSuperTypes().any {
                isClass(it, uniqSimpleName, uniqIdName)
            }) -> {
                RemapSort.Unique(nullable)
            }
            decl.annotations.any {
                isGenerateRemapper(it)
            } -> {
                RemapSort.WithGenerated(getFullExtensionName(resolver, a = decl, "Remapper"), nullable)
            }
            qualifiedName == "kotlin.collections.Map" -> {
                kls.arguments.getOrNull(1)?.type?.resolve()?.let {
                    remappable(it, resolver)
                }?.let {
                    RemapSort.Collection.MapValue(it, nullable = nullable)
                }
            }
            qualifiedName == "kotlin.collections.List" -> {
                val ty = kls.arguments.firstOrNull()?.type?.resolve() ?: return null
                val remap = remappable(ty, resolver) ?: return null
                RemapSort.Collection.ListElement(remap, nullable)
            }
            qualifiedName == "kotlin.collections.Set" -> {
                val ty = kls.arguments.firstOrNull()?.type?.resolve() ?: return null
                val remap = remappable(ty, resolver) ?: return null
                RemapSort.Collection.SetElement(remap, nullable)
            }
            else -> null
        }
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        handleRemapperGenerator(resolver)
        handleGeneratedBy(resolver)
        handleSourceAnnotations(resolver)
        resolver.getSymbolsWithAnnotation("allocator.GeneratedBy").mapNotNull {
            it as? KSPropertyDeclaration
        }.filter {
            isMetaKeyAnnotation(it) == null && !isGeneratedByField(it)
        }.forEach {
            environment.logger.error("Field ${it.simpleName.asString()} declared in ${it.parentDeclaration?.simpleName?.asString() ?: it.containingFile!!.fileName} cannot be marked with @GeneratedBy", it)
        }
        resolver.getAllFiles().forEach {
            it.accept(GenerationChecker(resolver), Unit)
        }
        return emptyList()
    }

    private fun handleSourceAnnotations(resolver: Resolver) {
        val sourceFiles = mutableListOf<KSFile>()
        val metaKeyCases = mutableListOf<Pair<String, String>>()
        val fieldCastCases = mutableMapOf<String, Triple<String, String, String>>()
        resolver.getSymbolsWithAnnotation("allocator.GeneratedBy").mapNotNull {
            it as? KSPropertyDeclaration
        }.filter {
            it.annotations.filter {
                isGeneratedByAnnot(it)
            }.any {
                it.arguments.single {
                    it.name?.asString() == "source"
                }.value == true
            }
        }.forEach { k ->
            k.containingFile?.let(sourceFiles::add)
            val keyGen = isMetaKeyAnnotation(k)
            if(keyGen != null) {
                metaKeyCases.add(keyGen.first to keyGen.third.name)
            } else {
                val parent = k.parentDeclaration as? KSClassDeclaration ?:
                    return@forEach environment.logger.error("Source annotation found on field ${k.simpleName.asString()}, but it doesn't have a parent declaration", k)
                val nm = parent.qualifiedName?.asString() ?: return@forEach environment.logger.error("Could not get name of parent class for field ${k.simpleName.asString()}", k)
                if(nm in fieldCastCases) {
                    return@forEach environment.logger.error("Duplicate source generation fields", k)
                }
                fieldCastCases[nm] = Triple(
                    nm, k.simpleName.asString(), extractGeneratedBy(k).name
                )
            }
        }
        if(sourceFiles.isEmpty()) {
            return
        }
        val out = environment.codeGenerator.createNewFile(
            Dependencies(true, *sourceFiles.toTypedArray()),
            "vc.data",
            "MetaSourceFinder",
            "kt"
        )

        val extractions = metaKeyCases.joinToString("\n") { (m, allocId) ->
            "$m == key -> $allocId to obj"
        } + "\nelse -> null"

        val instanceChecks = fieldCastCases.values.joinToString("\n") { (klass, fld, allocId) ->
            "is $klass -> $allocId to obj.$fld"
        } + "\nelse -> null"

        out.bufferedWriter().use { writer ->
            writer.write("""
                package vc.data
                import datastructures.stdcollections.*

                object MetaSourceFinder {
                    fun extractSource(key: tac.MetaKey<*>?, obj: Any): Pair<allocator.Allocator.Id, Int>? {
                       if(obj is Int) {
                          return when {
                             $extractions
                          }
                       }
                       return when(obj) {
                          $instanceChecks
                       }
                    }
                }
            """.trimIndent())
        }
    }

    private fun handleGeneratedBy(resolver: Resolver) {
        val gen = resolver.getSymbolsWithAnnotation("allocator.GeneratedBy").mapNotNull {
            it as? KSPropertyDeclaration
        }.mapNotNull {
            isMetaKeyAnnotation(it)
        }.toList()

        if(gen.isEmpty()) {
            return
        }

        val sourceFiles = gen.map { it.second }

        val keyName = "mk"

        val idName = "intMeta"

        val remappings = (gen.map { (m, _, gen) ->
            """
                $keyName == $m -> ${gen.remapAt(idName)}
            """.trimIndent()
        } + """
            else -> $idName
        """.trimIndent()).joinToString("\n")

        val out = environment.codeGenerator.createNewFile(Dependencies(true, *sourceFiles.toTypedArray()), "vc.data", "MetaRemapper", "kt")
        val writer = out.bufferedWriter()
        writer.write("""
            package vc.data
            import datastructures.stdcollections.*
            /**
            *   Generated by [${this::class.qualifiedName}]
            */
            object MetaRemapper {
                fun remapMeta($keyName: tac.MetaKey<*>, t: java.io.Serializable, $remapFuncName: $remapperSig): java.io.Serializable {
                   if(t !is Int) { return t }
                   val $idName = t
                   return when {
                      $remappings
                    }
                }
            }
        """.trimIndent())
        writer.flush()
        out.close()
    }

    private fun handleRemapperGenerator(resolver: Resolver) {
        val annot = resolver.getSymbolsWithAnnotation("allocator.GenerateRemapper").mapNotNull {
            it as? KSClassDeclaration
        }
        for (a in annot) {
            if (a.classKind != ClassKind.CLASS || (Modifier.DATA !in a.modifiers)) {
                environment.logger.error("Cannot use @GenerateRemapper on non-data class declarations", a)
                continue
            }
            val props = a.getDeclaredProperties().mapNotNull {
                remappable(it, resolver)
            }.toList()
            if (props.toList().isEmpty()) {
                environment.logger.warn("No properties found to remap in ${a.qualifiedName!!.asString()}", a)
                continue
            }
            val out = environment.codeGenerator.createNewFile(Dependencies(false, a.containingFile!!),
                a.packageName.asString(),
                "${a.simpleName.asString()}_Remapper",
                "kt")
            val remapperName = getRemapperName(resolver, a)
            val writer = out.bufferedWriter()
            val resultType = a.qualifiedName!!.asString()
            writer.write("""
                    package ${a.packageName.asString()}
                    import datastructures.stdcollections.*

                    object $remapperName {
                          @kotlin.jvm.JvmStatic
                          fun $implName(obj: ${a.qualifiedName!!.asString()}, $remapFuncName: $remapperSig) : $resultType {
                             return obj.copy(
                """.trimIndent())
            for ((fld, how) in props) {
                writer.write("$fld = ")
                val res = how.remapAt("obj.$fld")
                writer.write("$res,")
            }
            writer.write("""
                    )
                    }
                    }
                """.trimIndent())
            writer.flush()
            out.close()
        }
    }

    /**
     * Given a class [a] return the fully qualified, JVM name of the extension
     * class with the sub-name [suffix]
     */
    private fun getFullExtensionName(resolver: Resolver, a: KSClassDeclaration, suffix: String): String {
        return a.packageName.asString() + "." + this.getExtensionName(resolver, a, suffix)
    }

    private fun getRemapperName(
        resolver: Resolver,
        a: KSClassDeclaration,
    ): String {
        return getExtensionName(resolver, a, "Remapper")
    }

    /**
     * Given a class declaration [a], return the JVM name of the class [a] with the sub-name suffix [suffix].
     */
    private fun getExtensionName(resolver: Resolver, a: KSClassDeclaration, suffix: String): String {
        /**
         * The JVM signature of a class object is:
         *
         * L<fqn>;
         *
         * Where fqn is the fully qualified name of the class, with dots in packages replaced with '/'. The last component
         * of the list is guaranteed to be the (JVM) name of the class, which is what we are hoping to extract here.
         */
        @OptIn(KspExperimental::class)
        val nm = resolver.mapToJvmSignature(a)!!.let {
            it.substring(1, it.lastIndex)
        }.let {
            it.substring(it.lastIndexOf('/') + 1, it.length)
        }
        return "`${nm}\$$suffix`"
    }

    /**
     * Assuming [it] is a property annotated with [allocator.GeneratedBy] and:
     * 1. is of type MetaKey<Int> or MetaKey<CallId>
     * 2. appears witin an object declaration
     * This returns a triple of:
     * a. The fully qualified name of the field, i.e., for `package a.b; object TACMeta { @GeneratedBy(...) val MY_META : MetaKey<...> = ... }`, the string `a.b.TACMeta.MY_META`
     * b. The file containing this declaration
     * c. The [RemapSort.GeneratedBy] object describing how to consistently remap values from this sequence.
     */
    private fun isMetaKeyAnnotation(it: KSPropertyDeclaration) : Triple<String, KSFile, RemapSort.GeneratedBy>? {
        if((it.type.element as? KSClassifierReference)?.referencedName() == "MetaKey" &&
                    it.type.resolve().let {
                        it.arguments.size == 1 && it.arguments.first().type?.let(::isGeneratedByType) == true && (it.declaration as? KSClassDeclaration)?.qualifiedName?.asString() == "tac.MetaKey"
                    }) {
            val parent = it.parentDeclaration as? KSClassDeclaration ?: return null
            if(parent.classKind != ClassKind.OBJECT) {
                return null
            }
            if(it.isMutable) {
                return null
            }
            val qualified = it.qualifiedName?.asString() ?: return null
            return Triple(qualified, it.containingFile ?: return null, extractGeneratedBy(it))
        }
        return null
    }

    /**
     * Returns true if [it] has a [allocator.GeneratedBy] annotation and is the appropriate
     * type (as determined by [isGeneratedByType]. Returns false otherwise.
     */
    private fun isGeneratedByField(it: KSPropertyDeclaration): Boolean {
        return it.annotations.any {
            isGeneratedByAnnot(it)
        } && isGeneratedByType(it.type)
    }

    /**
     * Takes a property field [it] and a resolver [resolver]. If [it] is [remappable], then this returns
     * a pair of the field name and the [RemapSort] describing how to remap that field. Otherwise, returns null.
     */
    private fun remappable(it: KSPropertyDeclaration, resolver: Resolver): Pair<String, RemapSort>? {
        return when {
            isGeneratedByField(it) -> it.simpleName.asString() to extractGeneratedBy(it)
            else -> {
                val resolved = it.type.resolve()
                remappable(resolved, resolver)?.let { r ->
                    it.simpleName.asString() to r
                }
            }
        }
    }

    /**
     * Given a property annotated with [allocator.GeneratedBy], return the [RemapSort.GeneratedBy] class
     * that describes how to consistently re-map ids from the allocator sequence given by [allocator.GeneratedBy.by]
     */
    private fun extractGeneratedBy(it: KSPropertyDeclaration) = RemapSort.GeneratedBy(
        it.annotations.single {
            isGeneratedByAnnot(it)
        }.arguments.single {
            it.name?.asString() == "by"
        }.let {
            it.value!!.toString()
        }
    )

    /**
     * Checks whether the type of a field within [allocator.GeneratedBy] is of the correct type, i.e., Int or CallId (which we
     * assume is just Int).
     */
    private fun isGeneratedByType(type: KSTypeReference) : Boolean {
        return (type.element as? KSClassifierReference)?.referencedName()?.let {
            it == "Int" || it == "CallId"
        } == true
    }

    /**
     * Checks whether the type *reference* in [it] is [fqn]. [baseName] must be the "plain" name of the class given in [fqn],
     * and is used to make these checks cheaper.
     */
    private fun isClass(it: KSTypeReference, baseName: String, fqn: String): Boolean {
        check(fqn.endsWith(baseName))
        val elem = it.element
        return elem is KSClassifierReference && elem.referencedName() == baseName && isClass(it.resolve(), baseName, fqn)
    }

    /**
     * Checks whether the (resolved) type [it] has the name [fqn], i.e. [it] is the type with name [fqn]
     */
    private fun isClass(it: KSType, baseName: String, fqn: String): Boolean {
        check(fqn.endsWith(baseName))
        return it.declaration.simpleName.asString() == baseName && it.declaration.qualifiedName!!.asString() == fqn
    }

    private fun isGenerateRemapper(it: KSAnnotation) =
        isAnnotation(it, "GenerateRemapper", "allocator.GenerateRemapper")

    /**
     * Performs structural checks to ensure that, among other things:
     * 1. Data classes with potentially remappable fields are themselves remappable
     * 2. Remappers generated via [allocator.GenerateRemapper] are "complete"
     * 3. A class extending [vc.data.RemapperEntity] has a [allocator.GenerateRemapper] annotation
     */
    inner class GenerationChecker(private val resolver: Resolver) : KSVisitorVoid() {
        override fun visitFile(file: KSFile, data: Unit) {
            if(file.annotations.any {
                    isSuppressRemap(it)
                }) {
                return
            }
            this.visitDeclarationContainer(file, data)
        }

        override fun visitDeclarationContainer(declarationContainer: KSDeclarationContainer, data: Unit) {
            declarationContainer.declarations.forEach {
                visitDeclaration(it, data)
            }
        }

        override fun visitDeclaration(declaration: KSDeclaration, data: Unit) {
            if(declaration is KSClassDeclaration) {
                visitClassDeclaration(classDeclaration = declaration, data)
            }
            if(declaration is KSDeclarationContainer) {
                visitDeclarationContainer(declaration, data)
            }
        }

        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            if(classDeclaration.classKind != ClassKind.CLASS) {
                return
            }
            if(classDeclaration.superTypes.any {
                isClass(it, "$remapperName", "$mapperPackage.$remapperName")
                } && classDeclaration.annotations.none {
                    isGenerateRemapper(it)
                }) {
                environment.logger.error("Have unsafe use of $remapperName, no corresponding @GenerateRemapper annotation was found", classDeclaration)
            }
            if(Modifier.DATA !in classDeclaration.modifiers) {
                return
            }
            val usesGenerated = classDeclaration.annotations.any {
                isGenerateRemapper(it)
            }
            if(hasRemapper(classDeclaration) && !usesGenerated) {
                return
            }
            if(classDeclaration.annotations.any {
                    isSuppressRemap(it)
                }) {
                return
            }
            if(usesGenerated) {
                validateGenerated(kls = classDeclaration)
            } else {
                validateNoRemap(kls = classDeclaration)
            }
        }

        /**
         * Validates that the declaration [kls] annotated with [allocator.GenerateRemapper] is "complete", i.e., all
         * fields that could plausibly hold remappable values are remappable (i.e., this rules out the appearance of
         * remappable type as type parameters in custom/unsupported container classes)
         */
        private fun validateGenerated(kls: KSClassDeclaration) {
            kls.getDeclaredProperties().forEach {
                if(remappable(it, resolver) != null) {
                    return@forEach
                }
                val fld = it.type.resolve()
                if(fld.arguments.any { it.type?.resolveThroughAliases()?.let(::containsRemappable) == true }) {
                    environment.logger.error("Property ${it.simpleName.asString()} of ${kls.simpleName.asString()}" +
                            " cannot be auto-remapped, consider implementing the remapping manually, or add SuppressRemapWarning", it)
                }
            }
        }

        /**
         * Checks that [kls] (which is assumed to not be remappable according to [hasRemapper]) does not contain
         * a field that is remappable.
         */
        private fun validateNoRemap(kls: KSClassDeclaration) {
            kls.getDeclaredProperties().forEach {
                if(remappable(it, resolver) != null || it.type.resolve().let(::containsRemappable)) {
                    environment.logger.error("Property ${it.simpleName.asString()} of ${kls.simpleName.asString()} appears remappable, " +
                            "but this class is not (consider adding SuppressRemapWarning)",
                        it)
                }
            }
        }

        /**
         * Traverse the type arguments of a type, checking if they are remappable.
         */
        private fun containsRemappable(ty: KSType) : Boolean = containsRemappable(ty, mutableSetOf<KSType>())
        private fun containsRemappable(ty: KSType, visited: MutableSet<KSType>) : Boolean {
            if(!visited.add(ty)) {
                return false
            }
            if(remappable(ty, resolver) != null) {
                return true
            }
            return ty.arguments.any {
                it.type?.resolveThroughAliases()?.let { containsRemappable(it, visited) } == true
            }
        }


        /**
         * Indicates that the class declaration definitely can re-map, either via a generated remapper,
         * or by implementing the `UniqueIdEntity` interface
         */
        private fun hasRemapper(classDeclaration: KSClassDeclaration) =
            classDeclaration.annotations.any {
                isGenerateRemapper(it)
            } || classDeclaration.getAllSuperTypes().any {
                isClass(it, uniqSimpleName, uniqIdName)
            }
    }

    private fun isSuppressRemap(it: KSAnnotation) =
        isAnnotation(it, "SuppressRemapWarning", "allocator.SuppressRemapWarning")

    private fun isGeneratedByAnnot(it: KSAnnotation): Boolean {
        val shortName = "GeneratedBy"
        val qualified = "allocator.GeneratedBy"
        return isAnnotation(it, shortName, qualified)
    }
}
