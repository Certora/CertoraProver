/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package evm

import utils.divRoundUp
import java.math.BigInteger
import kotlin.math.log2
import kotlin.math.pow

// Convenience variables
const val BITS_IN_A_BYTE = 8

const val EVM_BITWIDTH256 = 256
val EVM_BITWIDTH256_BIGINT = EVM_BITWIDTH256.toBigInteger()

const val EVM_BYTES_IN_A_WORD = EVM_BITWIDTH256 / BITS_IN_A_BYTE

/** The constant 2^256.
 * Warning: Do _not_ introduce this as a constant in our code (e.g. in TAC) if it's not absolutely
 * necessary. It cannot be translated to BV logics (we're using the bitwidth of 256).
 * Usage as a modulo is probably ok and an exception to this rule. */
val EVM_MOD_GROUP256: BigInteger = BigInteger.TWO.pow(EVM_BITWIDTH256)

fun twoToThe(exponent: Int): BigInteger = BigInteger.TWO.pow(exponent)

/**
 * The constant 2^512
 */
val MAX_EVM_INT512 = BigInteger.TWO.pow(512 -1).minus(BigInteger.ONE)
val MIN_EVM_INT512 = MAX_EVM_INT512 + BigInteger.ONE
val MAX_UINT512 = BigInteger.TWO.pow(512).minus(BigInteger.ONE)
val TWO_TO_512 = BigInteger.TWO.pow(512)

/**
 * The constant 2^255 */
val EVM_MOD_GROUP255: BigInteger = BigInteger.TWO.pow(EVM_BITWIDTH256 - 1)
val MAX_EVM_INT256 = BigInteger.TWO.pow(EVM_BITWIDTH256 -1).minus(BigInteger.ONE)
val MIN_EVM_INT256_2S_COMPLEMENT = MAX_EVM_INT256 + BigInteger.ONE
val MAX_EVM_UINT256 = BigInteger.TWO.pow(EVM_BITWIDTH256).minus(BigInteger.ONE)
val MIN_EVM_INT256_AS_MATH_INT = MAX_EVM_INT256.negate().minus(BigInteger.ONE) // equal to -2^255
val powersOf2 = IntRange(0, EVM_BITWIDTH256).map { BigInteger.TWO.pow(it) }
const val EVM_WORD_SIZE_INT = 32
val EVM_WORD_SIZE = EVM_WORD_SIZE_INT.toBigInteger()
val EVM_ARRAY_ELEM_OFFSET = EVM_WORD_SIZE
fun BigInteger.alignToEVMWord() = if(this.mod(EVM_WORD_SIZE) == BigInteger.ZERO) {
    this
} else {
    this + (EVM_WORD_SIZE - this.mod(EVM_WORD_SIZE))
}
const val EVM_BYTE_SIZE_INT = 8
val EVM_BYTE_SIZE = EVM_BYTE_SIZE_INT.toBigInteger()

const val EVM_ADDRESS_SIZE = 160
const val DEFAULT_SIGHASH_SIZE_INT = 4
val DEFAULT_SIGHASH_SIZE = DEFAULT_SIGHASH_SIZE_INT.toBigInteger()
val ABI_SIZE_BOUND = BigInteger.TWO.pow(64)


// return 2^n - 1, where n is number of bits in the mask
fun MASK_SIZE(n: Int) = BigInteger.TWO.pow(n).minus(BigInteger.ONE)
// The way Python allocates addresses is by starting at address 0xce4604a aka Certora (12, 14, 04, 06, 00, 04, 10)
// Consecutive addresses are greater than that value
val MIN_USER_CONTRACT_ADDRESS = (
        (
                12 * 2.0.pow(24)
                        + 14 * 2.0.pow(20)
                        + 4 * 2.0.pow(16)
                        + 6 * 2.0.pow(12)
                        + 0
                        + 4 * 2.0.pow(4)
                        + 10 * 2.0.pow(0)
                )
                * 2.0.pow(100))

/*
The bitwidth of addresses generated by calls to the create() or created2() function cannot be greater than this number.
We want to avoid collisions of the returned value of hashed addresses in contract creation,
    so we limit the returned value to be smaller than the minimal user contract address.
    2^MAX_GENERATED_ADDRESS_BITWIDTH -1 < MIN_USER_CONTRACT_ADDRESS
 */
val MAX_GENERATED_ADDRESS_BITWIDTH = Math.ceil(log2(MIN_USER_CONTRACT_ADDRESS)).toInt()
val MAX_GENERATED_ADDRESS_BITWIDTH_inBytes get() = MAX_GENERATED_ADDRESS_BITWIDTH divRoundUp 8

// Precompiled contracts
val ECRECOVER_PRECOMPILED_ADDRESS = BigInteger.ONE
val SHA256_PRECOMPILED_ADDRESS = BigInteger.TWO
val IDENTITY_PRECOMPILED_ADDRESS = 4.toBigInteger()
